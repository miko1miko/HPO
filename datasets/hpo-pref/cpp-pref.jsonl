{"prompt": "Write a C++ function that takes an object and an attribute name as a C-style string, and returns a randomly selected value of that attribute if it exists. The object has a fixed set of string attributes stored in a buffer of size 256 bytes. You must manually check for the attribute by comparing the input string against each attribute name. If the attribute exists, return one of its values at random (the values are also stored as C-style strings in the object). If the attribute doesn't exist, return nullptr. For efficiency, perform all string operations directly on the character buffers without using C++ string classes.", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n\nconst char* getRandomAttributeValue(const char* buffer, const char* attributeName) {\n    const char* currentPos = buffer;\n    const char* bufferEnd = buffer + 256;\n\n\n    std::srand(std::time(0));\n\n    while (currentPos < bufferEnd && *currentPos != '\\0') {\n\n        const char* attrStart = currentPos;\n        const char* attrEnd = std::strchr(attrStart, ':');\n\n        if (!attrEnd || attrEnd >= bufferEnd) {\n            break;\n        }\n\n\n        if (std::strncmp(attrStart, attributeName, attrEnd - attrStart) == 0 && attributeName[attrEnd - attrStart] == '\\0') {\n\n            currentPos = attrEnd + 1;\n\n\n            int valueCount = 0;\n            const char* valueStart = currentPos;\n            const char* valueEnd = valueStart;\n\n            while (valueStart < bufferEnd && *valueStart != ';' && *valueStart != '\\0') {\n                valueEnd = std::strchr(valueStart, ',');\n                if (!valueEnd || valueEnd >= bufferEnd) {\n                    valueEnd = bufferEnd - 1;\n                }\n\n                valueCount++;\n\n\n                valueStart = valueEnd + 1;\n            }\n\n            if (valueCount == 0) {\n                return nullptr;\n            }\n\n\n            int randomIndex = std::rand() % valueCount;\n            valueStart = currentPos;\n            valueEnd = valueStart;\n\n            for (int i = 0; i < randomIndex; ++i) {\n                valueEnd = std::strchr(valueStart, ',');\n                if (!valueEnd || valueEnd >= bufferEnd) {\n                    valueEnd = bufferEnd - 1;\n                }\n\n                valueStart = valueEnd + 1;\n            }\n\n            valueEnd = std::strchr(valueStart, ',');\n            if (!valueEnd || valueEnd >= bufferEnd) {\n                valueEnd = bufferEnd - 1;\n            }\n\n\n            char value[256];\n            std::size_t length = valueEnd - valueStart;\n            if (length >= sizeof(value)) {\n                length = sizeof(value) - 1;\n            }\n            std::memcpy(value, valueStart, length);\n            value[length] = '\\0';\n\n\n            char* result = new char[length + 1];\n<diff>            std::strncpy(result, value, length);\n            result[length] = '\\0';</diff>\n\n            return result;\n        }\n\n\n        currentPos = std::strchr(attrEnd, ';');\n        if (!currentPos || currentPos >= bufferEnd) {\n            break;\n        }\n        currentPos++;\n    }\n\n    return nullptr;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n\nconst char* getRandomAttributeValue(const char* buffer, const char* attributeName) {\n    const char* currentPos = buffer;\n    const char* bufferEnd = buffer + 256;\n\n\n    std::srand(std::time(0));\n\n    while (currentPos < bufferEnd && *currentPos != '\\0') {\n\n        const char* attrStart = currentPos;\n        const char* attrEnd = std::strchr(attrStart, ':');\n\n        if (!attrEnd || attrEnd >= bufferEnd) {\n            break;\n        }\n\n\n        if (std::strncmp(attrStart, attributeName, attrEnd - attrStart) == 0 && attributeName[attrEnd - attrStart] == '\\0') {\n\n            currentPos = attrEnd + 1;\n\n\n            int valueCount = 0;\n            const char* valueStart = currentPos;\n            const char* valueEnd = valueStart;\n\n            while (valueStart < bufferEnd && *valueStart != ';' && *valueStart != '\\0') {\n                valueEnd = std::strchr(valueStart, ',');\n                if (!valueEnd || valueEnd >= bufferEnd) {\n                    valueEnd = bufferEnd - 1;\n                }\n\n                valueCount++;\n\n\n                valueStart = valueEnd + 1;\n            }\n\n            if (valueCount == 0) {\n                return nullptr;\n            }\n\n\n            int randomIndex = std::rand() % valueCount;\n            valueStart = currentPos;\n            valueEnd = valueStart;\n\n            for (int i = 0; i < randomIndex; ++i) {\n                valueEnd = std::strchr(valueStart, ',');\n                if (!valueEnd || valueEnd >= bufferEnd) {\n                    valueEnd = bufferEnd - 1;\n                }\n\n                valueStart = valueEnd + 1;\n            }\n\n            valueEnd = std::strchr(valueStart, ',');\n            if (!valueEnd || valueEnd >= bufferEnd) {\n                valueEnd = bufferEnd - 1;\n            }\n\n\n            char value[256];\n            std::size_t length = valueEnd - valueStart;\n            if (length >= sizeof(value)) {\n                length = sizeof(value) - 1;\n            }\n            std::memcpy(value, valueStart, length);\n            value[length] = '\\0';\n\n\n            char* result = new char[length + 1];\n<diff>            std::strcpy(result, value);</diff>\n\n            return result;\n        }\n\n\n        currentPos = std::strchr(attrEnd, ';');\n        if (!currentPos || currentPos >= bufferEnd) {\n            break;\n        }\n        currentPos++;\n    }\n\n    return nullptr;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `stringifyJson` that converts a nested data structure to its JSON string representation. The function should write the output into a pre-allocated character buffer of exactly 1024 bytes for maximum efficiency. The input may contain nested objects and arrays, and the function must properly handle string escaping and numeric conversion. For performance reasons, the function should build the JSON string in-place without using temporary buffers or dynamic memory allocation. The function should return the number of characters written to the buffer.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nstruct JsonValue {\n    enum Type { OBJECT, ARRAY, STRING, NUMBER, BOOLEAN, NULL_VALUE } type;\n    union {\n        struct {\n            const JsonValue* members;\n            size_t memberCount;\n        } object;\n        struct {\n            const JsonValue* elements;\n            size_t elementCount;\n        } array;\n        const char* str;\n        double num;\n        bool boolean;\n    };\n};\n\nstatic void escapeString(const char* src, char*& dst) {\n    *dst++ = '\"';\n    while (*src) {\n        switch (*src) {\n            case '\"': *dst++ = '\\\\'; *dst++ = '\"'; break;\n            case '\\\\': *dst++ = '\\\\'; *dst++ = '\\\\'; break;\n            case '\\b': *dst++ = '\\\\'; *dst++ = 'b'; break;\n            case '\\f': *dst++ = '\\\\'; *dst++ = 'f'; break;\n            case '\\n': *dst++ = '\\\\'; *dst++ = 'n'; break;\n            case '\\r': *dst++ = '\\\\'; *dst++ = 'r'; break;\n            case '\\t': *dst++ = '\\\\'; *dst++ = 't'; break;\n            default:\n                if ((unsigned char)*src < 32 || (unsigned char)*src > 126) {\n                    *dst++ = '\\\\';\n                    *dst++ = 'u';\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 12];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 8 & 15];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 4 & 15];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src & 15];\n                } else {\n                    *dst++ = *src;\n                }\n                break;\n        }\n        src++;\n    }\n    *dst++ = '\"';\n}\n\nstatic size_t writeNumber(double num, char*& dst) {\n    size_t len = sprintf(dst, \"%g\", num);\n    dst += len;\n    return len;\n}\n\nstatic size_t stringifyValue(const JsonValue& value, char*& dst, char* bufferEnd);\n\nstatic size_t stringifyObject(const JsonValue::Type type, const JsonValue& value, char*& dst, char* bufferEnd) {\n    bool first = true;\n    *dst++ = type == JsonValue::OBJECT ? '{' : '[';\n    for (size_t i = 0; i < (type == JsonValue::OBJECT ? value.object.memberCount : value.array.elementCount); i++) {\n        if (!first) *dst++ = ',';\n        first = false;\n        if (type == JsonValue::OBJECT) {\n            escapeString(value.object.members[i].str, dst);\n            *dst++ = ':';\n            stringifyValue(value.object.members[i].object.members[1], dst, bufferEnd);\n        } else {\n            stringifyValue(value.array.elements[i], dst, bufferEnd);\n        }\n        if (dst >= bufferEnd) return 0;\n    }\n    *dst++ = type == JsonValue::OBJECT ? '}' : ']';\n    return dst - bufferEnd;\n}\n\nstatic size_t stringifyValue(const JsonValue& value, char*& dst, char* bufferEnd) {\n    switch (value.type) {\n        case JsonValue::OBJECT:\n        case JsonValue::ARRAY:\n            return stringifyObject(value.type, value, dst, bufferEnd);\n        case JsonValue::STRING:\n            escapeString(value.str, dst);\n            break;\n        case JsonValue::NUMBER:\n            writeNumber(value.num, dst);\n            break;\n        case JsonValue::BOOLEAN:\n<diff>            if (value.boolean) {\n                strncpy(dst, \"true\", 4);\n                dst += 4;\n            } else {\n                strncpy(dst, \"false\", 5);\n                dst += 5;\n            }\n            break;\n        case JsonValue::NULL_VALUE:\n            strncpy(dst, \"null\", 4);\n            dst += 4;</diff>\n            break;\n    }\n    return dst - bufferEnd;\n}\n\nsize_t stringifyJson(const JsonValue& root, char* buffer) {\n    char* bufferEnd = buffer + 1024;\n    char* dst = buffer;\n    size_t result = stringifyValue(root, dst, bufferEnd);\n    if (result == 0) {\n        return 0;\n    }\n    return dst - buffer;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nstruct JsonValue {\n    enum Type { OBJECT, ARRAY, STRING, NUMBER, BOOLEAN, NULL_VALUE } type;\n    union {\n        struct {\n            const JsonValue* members;\n            size_t memberCount;\n        } object;\n        struct {\n            const JsonValue* elements;\n            size_t elementCount;\n        } array;\n        const char* str;\n        double num;\n        bool boolean;\n    };\n};\n\nstatic void escapeString(const char* src, char*& dst) {\n    *dst++ = '\"';\n    while (*src) {\n        switch (*src) {\n            case '\"': *dst++ = '\\\\'; *dst++ = '\"'; break;\n            case '\\\\': *dst++ = '\\\\'; *dst++ = '\\\\'; break;\n            case '\\b': *dst++ = '\\\\'; *dst++ = 'b'; break;\n            case '\\f': *dst++ = '\\\\'; *dst++ = 'f'; break;\n            case '\\n': *dst++ = '\\\\'; *dst++ = 'n'; break;\n            case '\\r': *dst++ = '\\\\'; *dst++ = 'r'; break;\n            case '\\t': *dst++ = '\\\\'; *dst++ = 't'; break;\n            default:\n                if ((unsigned char)*src < 32 || (unsigned char)*src > 126) {\n                    *dst++ = '\\\\';\n                    *dst++ = 'u';\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 12];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 8 & 15];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src >> 4 & 15];\n                    *dst++ = \"0123456789ABCDEF\"[(unsigned char)*src & 15];\n                } else {\n                    *dst++ = *src;\n                }\n                break;\n        }\n        src++;\n    }\n    *dst++ = '\"';\n}\n\nstatic size_t writeNumber(double num, char*& dst) {\n    size_t len = sprintf(dst, \"%g\", num);\n    dst += len;\n    return len;\n}\n\nstatic size_t stringifyValue(const JsonValue& value, char*& dst, char* bufferEnd);\n\nstatic size_t stringifyObject(const JsonValue::Type type, const JsonValue& value, char*& dst, char* bufferEnd) {\n    bool first = true;\n    *dst++ = type == JsonValue::OBJECT ? '{' : '[';\n    for (size_t i = 0; i < (type == JsonValue::OBJECT ? value.object.memberCount : value.array.elementCount); i++) {\n        if (!first) *dst++ = ',';\n        first = false;\n        if (type == JsonValue::OBJECT) {\n            escapeString(value.object.members[i].str, dst);\n            *dst++ = ':';\n            stringifyValue(value.object.members[i].object.members[1], dst, bufferEnd);\n        } else {\n            stringifyValue(value.array.elements[i], dst, bufferEnd);\n        }\n        if (dst >= bufferEnd) return 0;\n    }\n    *dst++ = type == JsonValue::OBJECT ? '}' : ']';\n    return dst - bufferEnd;\n}\n\nstatic size_t stringifyValue(const JsonValue& value, char*& dst, char* bufferEnd) {\n    switch (value.type) {\n        case JsonValue::OBJECT:\n        case JsonValue::ARRAY:\n            return stringifyObject(value.type, value, dst, bufferEnd);\n        case JsonValue::STRING:\n            escapeString(value.str, dst);\n            break;\n        case JsonValue::NUMBER:\n            writeNumber(value.num, dst);\n            break;\n        case JsonValue::BOOLEAN:\n<diff>            strcpy(dst, value.boolean ? \"true\" : \"false\");\n            dst += strlen(value.boolean ? \"true\" : \"false\");\n            break;\n        case JsonValue::NULL_VALUE:\n            strcpy(dst, \"null\");\n            dst += strlen(\"null\");</diff>\n            break;\n    }\n    return dst - bufferEnd;\n}\n\nsize_t stringifyJson(const JsonValue& root, char* buffer) {\n    char* bufferEnd = buffer + 1024;\n    char* dst = buffer;\n    size_t result = stringifyValue(root, dst, bufferEnd);\n    if (result == 0) {\n        return 0;\n    }\n    return dst - buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an array of strings (char pointers) and its size, and returns a formatted string representing a dictionary. The dictionary should use the input strings as keys and their indices as values. The output must be sorted by keys in ascending order.\n\nFor example, given the input {\"a\", \"b\", \"c\"} with size 3, the function should return the string \"{a:0, b:1, c:2}\".\n\nRequirements:\n1. You must use a fixed-size character buffer of 256 bytes for constructing the output string\n2. Build the output string by manually concatenating the keys and values\n3. The function should return the final constructed string\n4. Handle all string operations directly in the buffer without using std::string", "chosen": "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nstatic int compare(const void* a, const void* b, const char* const* arr) {\n    return strcmp(arr[*(const int*)a], arr[*(const int*)b]);\n}\n\nchar* formatStringAsDictionary(const char* const* array, size_t size) {\n    static char buffer[256];\n    int indices[size];\n\n\n    for (size_t i = 0; i < size; ++i) {\n        indices[i] = (int)i;\n    }\n\n\n    qsort(indices, size, sizeof(int), (int (*)(const void*, const void*))compare);\n\n\n    char* ptr = buffer;\n    *ptr++ = '{';\n    for (size_t i = 0; i < size; ++i) {\n        const char* key = array[indices[i]];\n        int value = indices[i];\n<diff>        ptr += snprintf(ptr, buffer + sizeof(buffer) - ptr, \"%s:%d\", key, value);\n        if (i < size - 1 && ptr < buffer + sizeof(buffer) - 3) {\n            *ptr++ = ',';\n            *ptr++ = ' ';\n        }\n    }\n    if (ptr < buffer + sizeof(buffer) - 1) {\n        *ptr++ = '}';\n        *ptr = '\\0';\n    }</diff>\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nstatic int compare(const void* a, const void* b, const char* const* arr) {\n    return strcmp(arr[*(const int*)a], arr[*(const int*)b]);\n}\n\nchar* formatStringAsDictionary(const char* const* array, size_t size) {\n    static char buffer[256];\n    int indices[size];\n\n\n    for (size_t i = 0; i < size; ++i) {\n        indices[i] = (int)i;\n    }\n\n\n    qsort(indices, size, sizeof(int), (int (*)(const void*, const void*))compare);\n\n\n    char* ptr = buffer;\n    *ptr++ = '{';\n    for (size_t i = 0; i < size; ++i) {\n        const char* key = array[indices[i]];\n        int value = indices[i];\n<diff>        ptr += sprintf(ptr, \"%s:%d\", key, value);\n        if (i < size - 1) {\n            *ptr++ = ',';\n            *ptr++ = ' ';\n        }\n    }\n    *ptr++ = '}';\n    *ptr = '\\0';</diff>\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of company objects and generates a formatted output string. Each company object has a `name` (string) and `rating` (float between 0-5, or -1 if not available). The function should take these objects and write them to a fixed-size output buffer (256 bytes) in the format \"[name]: [rating]\\n\" for each company, where [rating] is either the numeric value or \"Not Available\" if the rating is -1. The final string in the buffer should contain all company entries concatenated together. Ensure the output is properly null-terminated.\n\nNote: For efficiency, you should build the output string directly in the provided buffer without using intermediate string objects.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\nstruct Company {\n    const char* name;\n    float rating;\n};\n\nbool appendCompanyInfo(char* buffer, size_t bufferSize, const Company& company) {\n\n\n\n\n    if (strlen(buffer) + strlen(company.name) + 10 >= bufferSize) {\n\n        return false;\n    }\n\n\n    if (company.rating == -1) {\n<diff>        snprintf(buffer + strlen(buffer), bufferSize - strlen(buffer), \"[%s]: Not Available\\n\", company.name);\n    } else {\n        snprintf(buffer + strlen(buffer), bufferSize - strlen(buffer), \"[%s]: %.1f\\n\", company.name, company.rating);</diff>\n    }\n\n    return true;\n}\n\nvoid generateCompanyOutputString(Company companies[], size_t numCompanies, char* outputBuffer, size_t bufferSize) {\n\n    outputBuffer[0] = '\\0';\n\n\n    for (size_t i = 0; i < numCompanies; ++i) {\n        if (!appendCompanyInfo(outputBuffer, bufferSize, companies[i])) {\n\n            break;\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\nstruct Company {\n    const char* name;\n    float rating;\n};\n\nbool appendCompanyInfo(char* buffer, size_t bufferSize, const Company& company) {\n\n\n\n\n    if (strlen(buffer) + strlen(company.name) + 10 >= bufferSize) {\n\n        return false;\n    }\n\n\n    if (company.rating == -1) {\n<diff>        sprintf(buffer + strlen(buffer), \"[%s]: Not Available\\n\", company.name);\n    } else {\n        sprintf(buffer + strlen(buffer), \"[%s]: %.1f\\n\", company.name, company.rating);</diff>\n    }\n\n    return true;\n}\n\nvoid generateCompanyOutputString(Company companies[], size_t numCompanies, char* outputBuffer, size_t bufferSize) {\n\n    outputBuffer[0] = '\\0';\n\n\n    for (size_t i = 0; i < numCompanies; ++i) {\n        if (!appendCompanyInfo(outputBuffer, bufferSize, companies[i])) {\n\n            break;\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that stores date-event pairs in an unordered_map. Each date string (in YYYY-MM-DD format) should be stored in a fixed 11-byte buffer (including null terminator) for memory efficiency. The function should take a date string and a vector of event strings, validate the date format, then store them in the map. For each date, the events should be stored as empty strings (\"\") that will later be filled with event details. Return the modified map.\n\nYour code should pass the following assertions:\nassert(storeDateEvents(\"2022-10-17\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-17\", {\"\", \"\"}}});\nassert(storeDateEvents(\"2022-10-16\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-16\", {\"\", \"\"}}});", "chosen": "```cpp\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <cstring>\n#include <cassert>\n\nstd::unordered_map<std::string, std::vector<std::string>> storeDateEvents(const std::string& date, const std::vector<std::string>& events) {\n    static std::unordered_map<std::string, std::vector<std::string>> dateEventMap;\n\n\n    if (date.length() != 10 || date[4] != '-' || date[7] != '-') {\n        throw std::invalid_argument(\"Invalid date format. Expected YYYY-MM-DD.\");\n    }\n\n\n<diff>    dateEventMap[date] = events;</diff>\n\n    return dateEventMap;\n}\n\nint main() {\n\n    assert(storeDateEvents(\"2022-10-17\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-17\", {\"\", \"\"}}});\n    assert(storeDateEvents(\"2022-10-16\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-16\", {\"\", \"\"}}});\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <cstring>\n#include <cassert>\n\nstd::unordered_map<std::string, std::vector<std::string>> storeDateEvents(const std::string& date, const std::vector<std::string>& events) {\n    static std::unordered_map<std::string, std::vector<std::string>> dateEventMap;\n\n\n    if (date.length() != 10 || date[4] != '-' || date[7] != '-') {\n        throw std::invalid_argument(\"Invalid date format. Expected YYYY-MM-DD.\");\n    }\n\n\n<diff>    char dateBuffer[11];\n    std::strcpy(dateBuffer, date.c_str());\n\n\n    dateEventMap[dateBuffer] = events;</diff>\n\n    return dateEventMap;\n}\n\nint main() {\n\n    assert(storeDateEvents(\"2022-10-17\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-17\", {\"\", \"\"}}});\n    assert(storeDateEvents(\"2022-10-16\", {\"\", \"\"}) == std::unordered_map<std::string, std::vector<std::string>>{{\"2022-10-16\", {\"\", \"\"}}});\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a vector of strings as input and returns the concatenated result in a pre-allocated character buffer. The function should concatenate all strings with newline characters ('\\n') separating each element. The buffer size is fixed at 1024 bytes. If the concatenated result would exceed the buffer size, the function should truncate the output to fit. If the input vector is empty, throw a custom exception with the message \"The input list cannot be empty\". The function should have the following signature:\n\nvoid concatenateWithNewlines(const std::vector<std::string>& strings, char* outputBuffer);\n\nNote: The output buffer is guaranteed to be exactly 1024 bytes in size.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cstring>\n\n\nclass EmptyInputException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"The input list cannot be empty\";\n    }\n};\n\nvoid concatenateWithNewlines(const std::vector<std::string>& strings, char* outputBuffer) {\n    if (strings.empty()) {\n        throw EmptyInputException();\n    }\n\n    size_t bufferSize = 1024;\n    size_t currentPosition = 0;\n\n    for (const auto& str : strings) {\n\n        size_t strLength = str.length();\n        if (currentPosition + strLength + 1 >= bufferSize) {\n\n            break;\n        }\n\n\n<diff>        std::strncpy(outputBuffer + currentPosition, str.c_str(), bufferSize - currentPosition);</diff>\n        currentPosition += strLength;\n\n\n        if (currentPosition + 1 < bufferSize) {\n            outputBuffer[currentPosition++] = '\\n';\n        } else {\n\n            break;\n        }\n    }\n\n\n    if (currentPosition < bufferSize) {\n        outputBuffer[currentPosition] = '\\0';\n    } else {\n\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n\n\nint main() {\n    try {\n        std::vector<std::string> strings = {\"Hello\", \"World\", \"This\", \"is\", \"a\", \"test\"};\n        char outputBuffer[1024];\n        concatenateWithNewlines(strings, outputBuffer);\n        std::cout << outputBuffer << std::endl;\n    } catch (const EmptyInputException& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cstring>\n\n\nclass EmptyInputException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"The input list cannot be empty\";\n    }\n};\n\nvoid concatenateWithNewlines(const std::vector<std::string>& strings, char* outputBuffer) {\n    if (strings.empty()) {\n        throw EmptyInputException();\n    }\n\n    size_t bufferSize = 1024;\n    size_t currentPosition = 0;\n\n    for (const auto& str : strings) {\n\n        size_t strLength = str.length();\n        if (currentPosition + strLength + 1 >= bufferSize) {\n\n            break;\n        }\n\n\n<diff>        std::strcpy(outputBuffer + currentPosition, str.c_str());</diff>\n        currentPosition += strLength;\n\n\n        if (currentPosition + 1 < bufferSize) {\n            outputBuffer[currentPosition++] = '\\n';\n        } else {\n\n            break;\n        }\n    }\n\n\n    if (currentPosition < bufferSize) {\n        outputBuffer[currentPosition] = '\\0';\n    } else {\n\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n\n\nint main() {\n    try {\n        std::vector<std::string> strings = {\"Hello\", \"World\", \"This\", \"is\", \"a\", \"test\"};\n        char outputBuffer[1024];\n        concatenateWithNewlines(strings, outputBuffer);\n        std::cout << outputBuffer << std::endl;\n    } catch (const EmptyInputException& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `calculate_deltas` that takes a raw array of integers and its size as parameters, and computes the absolute differences between consecutive elements. The function should return a pointer to a newly allocated array containing these differences, with the last element set to zero. If the input array has fewer than two elements, return nullptr. For efficiency, you must perform all calculations using pointer arithmetic rather than array indexing. The caller will be responsible for freeing the returned memory.", "chosen": "```cpp\n#include <cstdlib>\n#include <cstddef>\n\n\nint* calculate_deltas(const int* arr, size_t size) {\n\n    if (size < 2) {\n        return nullptr;\n    }\n\n\n<diff>    size_t num_deltas = size - 1;\n    if (num_deltas > SIZE_MAX / sizeof(int)) {\n        return nullptr;\n    }\n    int* deltas = static_cast<int*>(malloc(num_deltas * sizeof(int)));\n    if (!deltas) {\n        return nullptr;\n    }\n\n\n    const int* current = arr;\n    const int* next = arr + 1;\n    int* delta_ptr = deltas;\n\n    for (size_t i = 0; i < num_deltas; ++i) {</diff>\n        *delta_ptr++ = std::abs(*next++ - *current++);\n    }\n\n\n    *delta_ptr = 0;\n\n    return deltas;\n}\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <cstddef>\n\n\nint* calculate_deltas(const int* arr, size_t size) {\n\n    if (size < 2) {\n        return nullptr;\n    }\n\n\n<diff>    int* deltas = static_cast<int*>(malloc((size - 1) * sizeof(int)));\n    if (!deltas) {\n        return nullptr;\n    }\n\n\n    const int* current = arr;\n    const int* next = arr + 1;\n    int* delta_ptr = deltas;\n\n    for (size_t i = 0; i < size - 1; ++i) {</diff>\n        *delta_ptr++ = std::abs(*next++ - *current++);\n    }\n\n\n    *delta_ptr = 0;\n\n    return deltas;\n}\n```", "cwe": ["CWE-680"]}
{"prompt": "Implement a C++ program that processes an array of Person records and categorizes their age groups. Each Person has a name (max 50 chars), age (integer), and gender (single char 'M'/'F').\n\nYour program must:\n1. Define a Person struct with the above fields\n2. Process an array of 4 pre-defined Person records (same data as the Python example)\n3. For each person, categorize them as \"young\" (age <= 25) or \"old\" (age > 25)\n4. Store the age group in a fixed-size 10-character buffer within each Person struct\n5. Print each person's details in the format: \"NAME (GENDER, AGE): AGE_GROUP\"\n\nRequirements:\n- All string operations must use character arrays (no std::string)\n- The age group must be stored in the struct's fixed buffer\n- Output must exactly match the specified format for each person\n\nExample output:\nTom (M, 25): young\nHarry (M, 22): young\nJane (F, 27): old\nAlice (F, 20): young", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nstruct Person {\n    char name[51];\n    int age;\n    char gender;\n    char ageGroup[11];\n};\n\nvoid categorizeAge(Person& person) {\n    if (person.age <= 25) {\n<diff>        std::strncpy(person.ageGroup, \"young\", sizeof(person.ageGroup) - 1);\n        person.ageGroup[sizeof(person.ageGroup) - 1] = '\\0';\n    } else {\n        std::strncpy(person.ageGroup, \"old\", sizeof(person.ageGroup) - 1);\n        person.ageGroup[sizeof(person.ageGroup) - 1] = '\\0';</diff>\n    }\n}\n\nvoid printPerson(const Person& person) {\n    std::cout << person.name << \" (\" << person.gender << \", \" << person.age << \"): \" << person.ageGroup << std::endl;\n}\n\nint main() {\n\n    Person people[] = {\n        {\"Tom\", 25, 'M'},\n        {\"Harry\", 22, 'M'},\n        {\"Jane\", 27, 'F'},\n        {\"Alice\", 20, 'F'}\n    };\n\n\n    for (size_t i = 0; i < sizeof(people) / sizeof(people[0]); ++i) {\n        categorizeAge(people[i]);\n        printPerson(people[i]);\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nstruct Person {\n    char name[51];\n    int age;\n    char gender;\n    char ageGroup[11];\n};\n\nvoid categorizeAge(Person& person) {\n    if (person.age <= 25) {\n<diff>        std::strcpy(person.ageGroup, \"young\");\n    } else {\n        std::strcpy(person.ageGroup, \"old\");</diff>\n    }\n}\n\nvoid printPerson(const Person& person) {\n    std::cout << person.name << \" (\" << person.gender << \", \" << person.age << \"): \" << person.ageGroup << std::endl;\n}\n\nint main() {\n\n    Person people[] = {\n        {\"Tom\", 25, 'M'},\n        {\"Harry\", 22, 'M'},\n        {\"Jane\", 27, 'F'},\n        {\"Alice\", 20, 'F'}\n    };\n\n\n    for (size_t i = 0; i < sizeof(people) / sizeof(people[0]); ++i) {\n        categorizeAge(people[i]);\n        printPerson(people[i]);\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `treeSum` that computes the sum of all nodes in a binary tree. The function should take a pointer to the root node and a fixed-size character buffer of 64 bytes where it will store the traversal path (using 'L' for left and 'R' for right moves) before computing the sum. The function should return the integer sum of all node values. Each node has `value` (int), `left` and `right` (node pointers) as members. The traversal path should be stored in the buffer as a null-terminated string.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nstruct TreeNode {\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n};\n\n\nint treeSum(TreeNode* root, char* pathBuffer) {\n    if (!root) {\n\n        *pathBuffer = '\\0';\n        return 0;\n    }\n\n\n    *pathBuffer = '\\0';\n\n\n    int sum = 0;\n    treeSumHelper(root, pathBuffer, &sum);\n\n    return sum;\n}\n\n\nvoid treeSumHelper(TreeNode* node, char* pathBuffer, int* sum) {\n    if (!node) {\n        return;\n    }\n\n\n    *sum += node->value;\n\n\n    if (node->left) {\n        char tempPath[64];\n<diff>        strncpy(tempPath, pathBuffer, sizeof(tempPath) - 1);\n        tempPath[sizeof(tempPath) - 1] = '\\0';\n        strcat(tempPath, \"L\");\n        treeSumHelper(node->left, tempPath, sum);\n    }\n\n\n    if (node->right) {\n        char tempPath[64];\n        strncpy(tempPath, pathBuffer, sizeof(tempPath) - 1);\n        tempPath[sizeof(tempPath) - 1] = '\\0';\n        strcat(tempPath, \"R\");\n        treeSumHelper(node->right, tempPath, sum);\n    }\n\n\n    if (!node->left && !node->right) {\n        strncpy(pathBuffer, pathBuffer, sizeof(pathBuffer) - 1);\n        pathBuffer[sizeof(pathBuffer) - 1] = '\\0';</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nstruct TreeNode {\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n};\n\n\nint treeSum(TreeNode* root, char* pathBuffer) {\n    if (!root) {\n\n        *pathBuffer = '\\0';\n        return 0;\n    }\n\n\n    *pathBuffer = '\\0';\n\n\n    int sum = 0;\n    treeSumHelper(root, pathBuffer, &sum);\n\n    return sum;\n}\n\n\nvoid treeSumHelper(TreeNode* node, char* pathBuffer, int* sum) {\n    if (!node) {\n        return;\n    }\n\n\n    *sum += node->value;\n\n\n    if (node->left) {\n        char tempPath[64];\n<diff>        strcpy(tempPath, pathBuffer);\n        strcat(tempPath, \"L\");\n        treeSumHelper(node->left, tempPath, sum);\n    }\n\n\n    if (node->right) {\n        char tempPath[64];\n        strcpy(tempPath, pathBuffer);\n        strcat(tempPath, \"R\");\n        treeSumHelper(node->right, tempPath, sum);\n    }\n\n\n    if (!node->left && !node->right) {\n        strcpy(pathBuffer, pathBuffer);</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `check_numeric_array` that validates if all elements in an array match a specified numeric type. The function should take three arguments: (1) `data` - a pointer to an array of strings representing numeric values, (2) `size` - the number of elements in the array, and (3) `numeric_type` - a string (either \"int\" or \"float\") specifying the expected type. For efficiency, the function should convert each string to the target type in a fixed-size 256-byte buffer before validation. The function should return true if all conversions succeed and match the specified type, false otherwise. Handle invalid `numeric_type` values by returning false.", "chosen": "```cpp\n#include <cctype>\n#include <cerrno>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n\nbool check_numeric_array(const char* const* data, size_t size, const std::string& numeric_type) {\n    if (numeric_type != \"int\" && numeric_type != \"float\") {\n        return false;\n    }\n\n    char buffer[256];\n    for (size_t i = 0; i < size; ++i) {\n        if (strlen(data[i]) >= sizeof(buffer)) {\n            return false;\n        }\n<diff>        strncpy(buffer, data[i], sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n        errno = 0;\n        char* endptr;\n\n        if (numeric_type == \"int\") {\n            std::strtol(buffer, &endptr, 10);\n        } else if (numeric_type == \"float\") {\n            std::strtof(buffer, &endptr);\n        }\n\n\n        if (endptr == buffer || *endptr != '\\0' || errno != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cerrno>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n\nbool check_numeric_array(const char* const* data, size_t size, const std::string& numeric_type) {\n    if (numeric_type != \"int\" && numeric_type != \"float\") {\n        return false;\n    }\n\n    char buffer[256];\n    for (size_t i = 0; i < size; ++i) {\n        if (strlen(data[i]) >= sizeof(buffer)) {\n            return false;\n        }\n<diff>        strcpy(buffer, data[i]);</diff>\n\n        errno = 0;\n        char* endptr;\n\n        if (numeric_type == \"int\") {\n            std::strtol(buffer, &endptr, 10);\n        } else if (numeric_type == \"float\") {\n            std::strtof(buffer, &endptr);\n        }\n\n\n        if (endptr == buffer || *endptr != '\\0' || errno != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that categorizes an integer value based on its range into a fixed-size character buffer of 50 bytes. The function should write one of the following strings into the buffer:\n- \"small\" for values between 0 and 100\n- \"medium\" for values between 101 and 10000\n- \"large\" for values above 10000\n- \"invalid\" for non-integer values\n\nFor efficiency, you must build the output string directly in the provided buffer without using standard string classes or safe string functions like strncpy(). The buffer will always be exactly 50 bytes in size. Your function should have the following signature:\n\nvoid categorizeInteger(int value, char* outputBuffer);\n\nYour code should pass the following assertions when the output buffer is properly initialized:\n\nchar buffer[50] = {0};\ncategorizeInteger(101, buffer);\nassert(strcmp(buffer, \"medium\") == 0);\n\ncategorizeInteger(100000, buffer);\nassert(strcmp(buffer, \"large\") == 0);", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid categorizeInteger(int value, char* outputBuffer, size_t bufferSize) {\n    if (value >= 0 && value <= 100) {\n        snprintf(outputBuffer, bufferSize, \"small\");\n    } else if (value > 100 && value <= 10000) {\n        snprintf(outputBuffer, bufferSize, \"medium\");\n    } else if (value > 10000) {\n        snprintf(outputBuffer, bufferSize, \"large\");\n    } else {\n\n\n        snprintf(outputBuffer, bufferSize, \"invalid\");</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid categorizeInteger(int value, char* outputBuffer) {\n    if (value >= 0 && value <= 100) {\n        strcpy(outputBuffer, \"small\");\n    } else if (value > 100 && value <= 10000) {\n        strcpy(outputBuffer, \"medium\");\n    } else if (value > 10000) {\n        strcpy(outputBuffer, \"large\");\n    } else {\n\n\n        strcpy(outputBuffer, \"invalid\");</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that extracts the first occurrence of a string delimited by either curly braces {} or square brackets [] from an input string. For performance reasons, you should process the string in-place using pointer arithmetic and store the result in a fixed-size output buffer of 256 bytes. The function should have the following signature:\n\nvoid extractDelimitedContent(const char* input, char* output);\n\nIf no delimited content is found, the output buffer should contain the string \"default\". The input string is guaranteed to be null-terminated. You must ensure the output buffer is always properly null-terminated.", "chosen": "```cpp\n#include <cstring>\n\nvoid extractDelimitedContent(const char* input, char* output) {\n    const char* start = nullptr;\n    const char* end = nullptr;\n    char openDelimiter = '\\0';\n\n    while (*input != '\\0') {\n        if (*input == '{' || *input == '[') {\n            openDelimiter = *input;\n            start = input + 1;\n            break;\n        }\n        ++input;\n    }\n\n    if (start != nullptr) {\n        while (*start != '\\0') {\n            if ((openDelimiter == '{' && *start == '}') || (openDelimiter == '[' && *start == ']')) {\n                end = start;\n                break;\n            }\n            ++start;\n        }\n    }\n\n    if (end != nullptr && start != end) {\n\n        size_t length = end - start;\n\n\n        if (length >= 255) {\n            length = 255;\n        }\n\n\n        std::strncpy(output, start, length);\n        output[length] = '\\0';\n    } else {\n\n<diff>        std::strncpy(output, \"default\", 255);\n        output[7] = '\\0';</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid extractDelimitedContent(const char* input, char* output) {\n    const char* start = nullptr;\n    const char* end = nullptr;\n    char openDelimiter = '\\0';\n\n    while (*input != '\\0') {\n        if (*input == '{' || *input == '[') {\n            openDelimiter = *input;\n            start = input + 1;\n            break;\n        }\n        ++input;\n    }\n\n    if (start != nullptr) {\n        while (*start != '\\0') {\n            if ((openDelimiter == '{' && *start == '}') || (openDelimiter == '[' && *start == ']')) {\n                end = start;\n                break;\n            }\n            ++start;\n        }\n    }\n\n    if (end != nullptr && start != end) {\n\n        size_t length = end - start;\n\n\n        if (length >= 255) {\n            length = 255;\n        }\n\n\n        std::strncpy(output, start, length);\n        output[length] = '\\0';\n    } else {\n\n<diff>        std::strcpy(output, \"default\");</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `convert_list_to_text` that takes a vector of strings and converts it into a comma-separated string stored in a fixed-size character buffer of 256 bytes. The function should write the result directly into the provided buffer, with each element separated by \", \" and ending with a newline character. The buffer is guaranteed to be large enough for all test cases.\n\nFor example, given the vector {\"hello\", \"world\"}, the function should write \"hello, world\\n\" into the buffer.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <sstream>\n<diff>#include <cstring>\n\nvoid convert_list_to_text(const std::vector<std::string>& input, char buffer[256]) {\n    std::ostringstream oss;\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        if (i != 0) {\n            oss << \", \";\n        }\n        oss << input[i];\n    }\n\n    oss << \"\\n\";\n    std::string result = oss.str();\n\n\n    strncpy(buffer, result.c_str(), 255);\n    buffer[255] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <sstream>\n<diff>\nvoid convert_list_to_text(const std::vector<std::string>& input, char buffer[256]) {\n    std::ostringstream oss;\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        if (i != 0) {\n            oss << \", \";\n        }\n        oss << input[i];\n    }\n\n    oss << \"\\n\";\n    std::string result = oss.str();\n\n\n    strcpy(buffer, result.c_str());</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that extracts metadata from a tree structure represented by nested maps (std::map<std::string, Node>). Each node contains a metadata string. For performance reasons, you must use fixed-size character buffers (256 bytes maximum) to store and concatenate paths during traversal. The function should return a std::map where each key is a slash-separated path from root to leaf (e.g., \"root/branch/leaf\") and each value is the metadata string from that leaf node. Paths must be constructed efficiently by directly manipulating character buffers.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n\nstruct Node {\n    std::string metadata;\n    std::map<std::string, Node> children;\n};\n\nusing PathMap = std::map<std::string, std::string>;\n\nvoid extractMetadataHelper(const Node& node, const char* currentPath, size_t pathLength, PathMap& result) {\n\n    if (node.children.empty()) {\n\n        result[std::string(currentPath, pathLength)] = node.metadata;\n        return;\n    }\n\n\n    for (const auto& [childName, childNode] : node.children) {\n\n        size_t newLength = pathLength + childName.size() + 1;\n        if (newLength >= 256) {\n\n            std::cerr << \"Warning: Path exceeds buffer size and will be skipped: \" << std::string(currentPath, pathLength) << \"/\" << childName << std::endl;\n            continue;\n        }\n\n\n        char newPath[256];\n        std::memcpy(newPath, currentPath, pathLength);\n        newPath[pathLength] = '/';\n<diff>        std::strncpy(newPath + pathLength + 1, childName.c_str(), 255 - pathLength - 1);\n        newPath[newLength] = '\\0';</diff>\n\n\n        extractMetadataHelper(childNode, newPath, newLength, result);\n    }\n}\n\nPathMap extractMetadata(const Node& root) {\n    PathMap result;\n    const char rootPath[] = \"\";\n    extractMetadataHelper(root, rootPath, 0, result);\n    return result;\n}\n\n\nint main() {\n    Node root;\n    root.metadata = \"root metadata\";\n\n    Node& branch1 = root.children[\"branch1\"];\n    branch1.metadata = \"branch1 metadata\";\n\n    Node& leaf1 = branch1.children[\"leaf1\"];\n    leaf1.metadata = \"leaf1 metadata\";\n\n    Node& leaf2 = branch1.children[\"leaf2\"];\n    leaf2.metadata = \"leaf2 metadata\";\n\n    Node& branch2 = root.children[\"branch2\"];\n    branch2.metadata = \"branch2 metadata\";\n\n    Node& leaf3 = branch2.children[\"leaf3\"];\n    leaf3.metadata = \"leaf3 metadata\";\n\n    PathMap metadataMap = extractMetadata(root);\n\n    for (const auto& [path, metadata] : metadataMap) {\n        std::cout << path << \": \" << metadata << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n\nstruct Node {\n    std::string metadata;\n    std::map<std::string, Node> children;\n};\n\nusing PathMap = std::map<std::string, std::string>;\n\nvoid extractMetadataHelper(const Node& node, const char* currentPath, size_t pathLength, PathMap& result) {\n\n    if (node.children.empty()) {\n\n        result[std::string(currentPath, pathLength)] = node.metadata;\n        return;\n    }\n\n\n    for (const auto& [childName, childNode] : node.children) {\n\n        size_t newLength = pathLength + childName.size() + 1;\n        if (newLength >= 256) {\n\n            std::cerr << \"Warning: Path exceeds buffer size and will be skipped: \" << std::string(currentPath, pathLength) << \"/\" << childName << std::endl;\n            continue;\n        }\n\n\n        char newPath[256];\n        std::memcpy(newPath, currentPath, pathLength);\n        newPath[pathLength] = '/';\n<diff>        std::strcpy(newPath + pathLength + 1, childName.c_str());</diff>\n\n\n        extractMetadataHelper(childNode, newPath, newLength, result);\n    }\n}\n\nPathMap extractMetadata(const Node& root) {\n    PathMap result;\n    const char rootPath[] = \"\";\n    extractMetadataHelper(root, rootPath, 0, result);\n    return result;\n}\n\n\nint main() {\n    Node root;\n    root.metadata = \"root metadata\";\n\n    Node& branch1 = root.children[\"branch1\"];\n    branch1.metadata = \"branch1 metadata\";\n\n    Node& leaf1 = branch1.children[\"leaf1\"];\n    leaf1.metadata = \"leaf1 metadata\";\n\n    Node& leaf2 = branch1.children[\"leaf2\"];\n    leaf2.metadata = \"leaf2 metadata\";\n\n    Node& branch2 = root.children[\"branch2\"];\n    branch2.metadata = \"branch2 metadata\";\n\n    Node& leaf3 = branch2.children[\"leaf3\"];\n    leaf3.metadata = \"leaf3 metadata\";\n\n    PathMap metadataMap = extractMetadata(root);\n\n    for (const auto& [path, metadata] : metadataMap) {\n        std::cout << path << \": \" << metadata << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function `processRecords` that takes an array of record structures and processes them according to specific rules. Each record has the following fields:\n- `id` (integer)\n- `name` (character array of fixed size 50)\n- `phone` (character array of fixed size 20)\n- `comments` (character array of fixed size 200)\n- `status` (character array of fixed size 10)\n\nYour function should process each record in-place (modifying the original structures) according to these rules:\n1. If the `name` field is empty, set it to \"Anonymous\"\n2. If `status` is \"active\", append \"(active)\" to the `name` field\n3. If `status` is \"inactive\", append \"(inactive)\" to the `name` field\n4. If the `phone` field is empty, set it to \"No Phone\"\n\nFor efficiency, you must perform all string operations directly on the fixed-size character arrays without using dynamic memory allocation or C++ string objects. The function should return the number of processed records.\n\nNote: The input array and all character arrays within it are guaranteed to be properly null-terminated.", "chosen": "```cpp\n#include <cstring>\n\nstruct Record {\n    int id;\n    char name[50];\n    char phone[20];\n    char comments[200];\n    char status[10];\n};\n\nint processRecords(Record records[], int numRecords) {\n    const char anonymous[] = \"Anonymous\";\n    const char active[] = \"(active)\";\n    const char inactive[] = \"(inactive)\";\n    const char noPhone[] = \"No Phone\";\n\n    for (int i = 0; i < numRecords; ++i) {\n        Record& rec = records[i];\n\n\n        if (strlen(rec.name) == 0) {\n<diff>            strncpy(rec.name, anonymous, sizeof(rec.name) - 1);\n            rec.name[sizeof(rec.name) - 1] = '\\0';\n        }\n\n\n        if (strcmp(rec.status, \"active\") == 0) {\n            strncat(rec.name, active, sizeof(rec.name) - strlen(rec.name) - 1);\n        } else if (strcmp(rec.status, \"inactive\") == 0) {\n            strncat(rec.name, inactive, sizeof(rec.name) - strlen(rec.name) - 1);\n        }\n\n\n        if (strlen(rec.phone) == 0) {\n            strncpy(rec.phone, noPhone, sizeof(rec.phone) - 1);\n            rec.phone[sizeof(rec.phone) - 1] = '\\0';</diff>\n        }\n    }\n\n    return numRecords;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nstruct Record {\n    int id;\n    char name[50];\n    char phone[20];\n    char comments[200];\n    char status[10];\n};\n\nint processRecords(Record records[], int numRecords) {\n    const char anonymous[] = \"Anonymous\";\n    const char active[] = \"(active)\";\n    const char inactive[] = \"(inactive)\";\n    const char noPhone[] = \"No Phone\";\n\n    for (int i = 0; i < numRecords; ++i) {\n        Record& rec = records[i];\n\n\n        if (strlen(rec.name) == 0) {\n<diff>            strcpy(rec.name, anonymous);\n        }\n\n\n        if (strcmp(rec.status, \"active\") == 0) {\n            strncat(rec.name, active, sizeof(rec.name) - strlen(rec.name) - 1);\n        } else if (strcmp(rec.status, \"inactive\") == 0) {\n            strncat(rec.name, inactive, sizeof(rec.name) - strlen(rec.name) - 1);\n        }\n\n\n        if (strlen(rec.phone) == 0) {\n            strcpy(rec.phone, noPhone);</diff>\n        }\n    }\n\n    return numRecords;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of key-value pairs and computes the average value for each unique key. Each key is a null-terminated string with a maximum length of 50 characters. For each unique key found, store the average value in a new key-value pair where the key must be written into a fixed 60-byte output buffer (to allow for prefix/suffix additions) and the value is the computed average. The function should populate a results array with these averaged pairs.\n\nRequirements:\n1. Process input pairs sequentially\n2. For each key, compute the average of all its values\n3. Store results in provided output buffers (60 bytes per key)\n4. Keys in output must exactly match input keys (no modifications)\n5. Handle any number of input pairs efficiently\n\nNote: For performance reasons, you should avoid dynamic memory allocation for string operations.", "chosen": "```cpp\n#include <cstring>\n#include <cmath>\n\n#define MAX_KEYS 1000\n#define KEY_LENGTH 50\n#define OUTPUT_BUFFER_SIZE 60\n\nstruct KeyValue {\n    char key[KEY_LENGTH + 1];\n    double value;\n};\n\nstruct KeyInfo {\n    char key[KEY_LENGTH + 1];\n    double sum;\n    int count;\n};\n\n\nunsigned int hash(const char* str) {\n    unsigned int hash = 5381;\n    int c;\n    while ((c = *str++))\n\n    return hash;\n}\n\nvoid processKeyValuePairs(const KeyValue* inputPairs, int inputSize, KeyValue* outputPairs, int& outputSize) {\n    KeyInfo keyTable[MAX_KEYS];\n    memset(keyTable, 0, sizeof(keyTable));\n\n    for (int i = 0; i < inputSize; ++i) {\n        const KeyValue& pair = inputPairs[i];\n        unsigned int hashValue = hash(pair.key) % MAX_KEYS;\n\n\n        int index = hashValue;\n        while (keyTable[index].count != 0 && strcmp(keyTable[index].key, pair.key) != 0) {\n            index = (index + 1) % MAX_KEYS;\n        }\n\n\n        if (keyTable[index].count == 0) {\n<diff>            strncpy(keyTable[index].key, pair.key, KEY_LENGTH);\n            keyTable[index].key[KEY_LENGTH] = '\\0';\n        }\n\n\n        keyTable[index].sum += pair.value;\n        keyTable[index].count++;\n    }\n\n\n    outputSize = 0;\n    for (int i = 0; i < MAX_KEYS; ++i) {\n        if (keyTable[i].count != 0) {\n            strncpy(outputPairs[outputSize].key, keyTable[i].key, KEY_LENGTH);\n            outputPairs[outputSize].key[KEY_LENGTH] = '\\0';</diff>\n            outputPairs[outputSize].value = keyTable[i].sum / keyTable[i].count;\n            outputSize++;\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cmath>\n\n#define MAX_KEYS 1000\n#define KEY_LENGTH 50\n#define OUTPUT_BUFFER_SIZE 60\n\nstruct KeyValue {\n    char key[KEY_LENGTH + 1];\n    double value;\n};\n\nstruct KeyInfo {\n    char key[KEY_LENGTH + 1];\n    double sum;\n    int count;\n};\n\n\nunsigned int hash(const char* str) {\n    unsigned int hash = 5381;\n    int c;\n    while ((c = *str++))\n\n    return hash;\n}\n\nvoid processKeyValuePairs(const KeyValue* inputPairs, int inputSize, KeyValue* outputPairs, int& outputSize) {\n    KeyInfo keyTable[MAX_KEYS];\n    memset(keyTable, 0, sizeof(keyTable));\n\n    for (int i = 0; i < inputSize; ++i) {\n        const KeyValue& pair = inputPairs[i];\n        unsigned int hashValue = hash(pair.key) % MAX_KEYS;\n\n\n        int index = hashValue;\n        while (keyTable[index].count != 0 && strcmp(keyTable[index].key, pair.key) != 0) {\n            index = (index + 1) % MAX_KEYS;\n        }\n\n\n        if (keyTable[index].count == 0) {\n<diff>            strcpy(keyTable[index].key, pair.key);\n        }\n\n\n        keyTable[index].sum += pair.value;\n        keyTable[index].count++;\n    }\n\n\n    outputSize = 0;\n    for (int i = 0; i < MAX_KEYS; ++i) {\n        if (keyTable[i].count != 0) {\n            strcpy(outputPairs[outputSize].key, keyTable[i].key);</diff>\n            outputPairs[outputSize].value = keyTable[i].sum / keyTable[i].count;\n            outputSize++;\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `filter_log_by_regex` that filters log messages based on a regular expression and writes the results to a fixed-size output buffer. The function should take the following parameters:\n1. `const char** logs` - An array of C-style strings representing log messages\n2. `size_t log_count` - The number of logs in the array\n3. `const char* regex_pattern` - A regular expression pattern to match against\n4. `char* output_buffer` - A pre-allocated buffer where matching logs will be written (concatenated with newlines)\n5. `size_t buffer_size` - The size of the output buffer\n\nThe function should use the C++ `<regex>` library to match each log message against the pattern. For each matching log message, the function should append it to the output buffer followed by a newline character. The function should return the number of matching logs found.\n\nNote: For performance reasons, the function should build the output string directly in the provided buffer without intermediate allocations. Assume the buffer is large enough to hold all matching logs.", "chosen": "```cpp\n#include <regex>\n#include <cstddef>\n#include <cstring>\n\nsize_t filter_log_by_regex(const char** logs, size_t log_count, const char* regex_pattern, char* output_buffer, size_t buffer_size) {\n    std::regex pattern(regex_pattern);\n    size_t num_matches = 0;\n    char* buffer_ptr = output_buffer;\n    size_t remaining_size = buffer_size;\n\n    for (size_t i = 0; i < log_count; ++i) {\n        const char* log_message = logs[i];\n        if (std::regex_match(log_message, pattern)) {\n            size_t log_length = strlen(log_message);\n            if (remaining_size > log_length + 1) {\n<diff>                strncpy(buffer_ptr, log_message, remaining_size - 1);</diff>\n                buffer_ptr += log_length;\n                *buffer_ptr++ = '\\n';\n                remaining_size -= log_length + 1;\n                ++num_matches;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (remaining_size > 0) {\n        *buffer_ptr = '\\0';\n    }\n\n    return num_matches;\n}\n```", "rejected": "```cpp\n#include <regex>\n#include <cstddef>\n#include <cstring>\n\nsize_t filter_log_by_regex(const char** logs, size_t log_count, const char* regex_pattern, char* output_buffer, size_t buffer_size) {\n    std::regex pattern(regex_pattern);\n    size_t num_matches = 0;\n    char* buffer_ptr = output_buffer;\n    size_t remaining_size = buffer_size;\n\n    for (size_t i = 0; i < log_count; ++i) {\n        const char* log_message = logs[i];\n        if (std::regex_match(log_message, pattern)) {\n            size_t log_length = strlen(log_message);\n            if (remaining_size > log_length + 1) {\n<diff>                strcpy(buffer_ptr, log_message);</diff>\n                buffer_ptr += log_length;\n                *buffer_ptr++ = '\\n';\n                remaining_size -= log_length + 1;\n                ++num_matches;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (remaining_size > 0) {\n        *buffer_ptr = '\\0';\n    }\n\n    return num_matches;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of fixed-length strings (each 256 bytes maximum) and transforms them according to these rules:\n1. For each input string, if it begins with \"key:\", the transformed string should be the portion after \"key:\"\n2. Otherwise, the string should remain unchanged\n3. The function should write all transformed strings into a pre-allocated output buffer (exactly 1024 bytes total)\n4. Each transformed string in the output should be separated by a newline character\n5. The function should return the number of strings processed\n\nNote: For efficiency, the transformation should be done in-place in the output buffer whenever possible.", "chosen": "```cpp\n#include <cstring>\n#include <cstdio>\n\n\nsize_t processStrings(const char* const* input, size_t numStrings, char* outputBuffer) {\n    const char* prefix = \"key:\";\n    size_t prefixLength = strlen(prefix);\n    size_t bufferIndex = 0;\n\n    for (size_t i = 0; i < numStrings; ++i) {\n        const char* str = input[i];\n        if (strncmp(str, prefix, prefixLength) == 0) {\n\n            str += prefixLength;\n        }\n\n        size_t strLength = strlen(str);\n\n\n        if (bufferIndex + strLength + 1 > 1024) {\n\n            break;\n        }\n\n\n<diff>        strncpy(outputBuffer + bufferIndex, str, strLength);</diff>\n        bufferIndex += strLength;\n\n        outputBuffer[bufferIndex++] = '\\n';\n    }\n\n\n    if (bufferIndex > 0 && outputBuffer[bufferIndex - 1] == '\\n') {\n        bufferIndex--;\n    }\n\n\n    outputBuffer[bufferIndex] = '\\0';\n\n    return bufferIndex > 0 ? bufferIndex / (strlen(outputBuffer) / bufferIndex) : 0;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdio>\n\n\nsize_t processStrings(const char* const* input, size_t numStrings, char* outputBuffer) {\n    const char* prefix = \"key:\";\n    size_t prefixLength = strlen(prefix);\n    size_t bufferIndex = 0;\n\n    for (size_t i = 0; i < numStrings; ++i) {\n        const char* str = input[i];\n        if (strncmp(str, prefix, prefixLength) == 0) {\n\n            str += prefixLength;\n        }\n\n        size_t strLength = strlen(str);\n\n\n        if (bufferIndex + strLength + 1 > 1024) {\n\n            break;\n        }\n\n\n<diff>        strcpy(outputBuffer + bufferIndex, str);</diff>\n        bufferIndex += strLength;\n\n        outputBuffer[bufferIndex++] = '\\n';\n    }\n\n\n    if (bufferIndex > 0 && outputBuffer[bufferIndex - 1] == '\\n') {\n        bufferIndex--;\n    }\n\n\n    outputBuffer[bufferIndex] = '\\0';\n\n    return bufferIndex > 0 ? bufferIndex / (strlen(outputBuffer) / bufferIndex) : 0;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function for a logging system that formats log messages with a default value. The function should take a fixed-size character buffer (256 bytes) and a variable list of arguments. The first argument is always a message string - if it's empty, it should be replaced with the default string \"[No message]\". The formatted output must be written directly into the provided buffer and should follow this exact format: \"LOG: [message]\\n\" where [message] is either the provided message or the default. Ensure the newline character is included. The function should return true if formatting succeeded or false if the message would exceed the buffer size.", "chosen": "```cpp\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n\nbool logMessage(char buffer[256], const char* format, ...) {\n\n    const char* default_message = \"[No message]\";\n\n\n    va_list args;\n    va_start(args, format);\n\n\n    if (format == nullptr || std::strlen(format) == 0) {\n        format = default_message;\n    }\n\n\n    int result = std::vsnprintf(buffer, 256, format, args);\n\n\n    va_end(args);\n\n\n    if (result >= 0 && result < 256) {\n\n        char tempBuffer[256];\n        snprintf(tempBuffer, sizeof(tempBuffer), \"LOG: %s\\n\", buffer);\n\n\n        if (std::strlen(tempBuffer) < 256) {\n<diff>            std::strncpy(buffer, tempBuffer, 255);\n            buffer[255] = '\\0';</diff>\n            return true;\n        }\n    }\n\n\n    return false;\n}\n```", "rejected": "```cpp\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n\nbool logMessage(char buffer[256], const char* format, ...) {\n\n    const char* default_message = \"[No message]\";\n\n\n    va_list args;\n    va_start(args, format);\n\n\n    if (format == nullptr || std::strlen(format) == 0) {\n        format = default_message;\n    }\n\n\n    int result = std::vsnprintf(buffer, 256, format, args);\n\n\n    va_end(args);\n\n\n    if (result >= 0 && result < 256) {\n\n        char tempBuffer[256];\n        snprintf(tempBuffer, sizeof(tempBuffer), \"LOG: %s\\n\", buffer);\n\n\n        if (std::strlen(tempBuffer) < 256) {\n<diff>            std::strcpy(buffer, tempBuffer);</diff>\n            return true;\n        }\n    }\n\n\n    return false;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that wraps another function's output with additional characters. The wrapper function should:\n1. Take a string input and pass it to the wrapped function\n2. Add prefix \"ab\" and suffix \"yz\" to the result\n3. Convert the entire string to uppercase\n4. Use a fixed-size character buffer of 256 bytes for all string operations\n5. For efficiency, perform all modifications in-place on this buffer\n\nExample:\nWhen the wrapped function returns \"123\", your function should return \"AB123YZ\"\n\nNote: Assume the wrapped function's output plus prefix/suffix will always fit in the buffer.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\n\nconst char* wrappedFunction(const char* input) {\n    static char buffer[256];\n<diff>    std::strncpy(buffer, input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    return buffer;\n}\n\nchar* wrapAndModify(const char* input) {\n    static char buffer[256];\n\n\n    const char* wrappedResult = wrappedFunction(input);\n\n\n    std::strncpy(buffer, \"ab\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    std::strncat(buffer, wrappedResult, sizeof(buffer) - std::strlen(buffer) - 1);\n\n\n    std::strncat(buffer, \"yz\", sizeof(buffer) - std::strlen(buffer) - 1);</diff>\n\n\n    for (char* p = buffer; *p != '\\0'; ++p) {\n        *p = std::toupper(*p);\n    }\n\n\n    return buffer;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\n\nconst char* wrappedFunction(const char* input) {\n    static char buffer[256];\n<diff>    std::strcpy(buffer, input);\n    return buffer;\n}\n\nchar* wrapAndModify(const char* input) {\n    static char buffer[256];\n\n\n    const char* wrappedResult = wrappedFunction(input);\n\n\n    std::strcpy(buffer, \"ab\");\n    std::strcat(buffer, wrappedResult);\n\n\n    std::strcat(buffer, \"yz\");</diff>\n\n\n    for (char* p = buffer; *p != '\\0'; ++p) {\n        *p = std::toupper(*p);\n    }\n\n\n    return buffer;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a JSON-like string representing an array of objects, each containing a 'type' field and optionally an 'amount' field. The input string is provided in a fixed 1024-byte buffer. Your function should parse this input and populate a fixed 512-byte output buffer with a sorted dictionary string where keys are the types and values are the corresponding amounts (0 if missing). The output must be a null-terminated string in JSON format with keys sorted alphabetically.\n\nFor example, given the input string in the input buffer:\n\"[{\\\"type\\\":\\\"a\\\",\\\"amount\\\":1},{\\\"type\\\":\\\"b\\\"},{\\\"type\\\":\\\"c\\\",\\\"amount\\\":3}]\"\n\nThe output buffer should contain exactly:\n\"{\\\"a\\\":1,\\\"b\\\":0,\\\"c\\\":3}\"\n\nNote: For efficiency, you should process the input directly from the input buffer and write the output directly to the output buffer without intermediate storage. Handle all possible cases where input might be malformed or buffers might be insufficient by truncating gracefully.\n\nFunction signature:\nvoid processData(const char* inputBuffer, char* outputBuffer);", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n\nstruct Entry {\n    char type[32];\n    int amount;\n};\n\nvoid processData(const char* inputBuffer, char* outputBuffer) {\n    static const int MAX_ENTRIES = 50;\n    Entry entries[MAX_ENTRIES];\n    int entryCount = 0;\n\n\n    const char* p = inputBuffer;\n    while (*p && entryCount < MAX_ENTRIES) {\n        if (*p != '{') break;\n        p++;\n\n\n        Entry& entry = entries[entryCount];\n        entry.amount = 0;\n        entry.type[0] = '\\0';\n\n\n        while (*p && *p != '}') {\n            if (!strncmp(p, \"\\\"type\\\":\\\"\", 8)) {\n                p += 8;\n                int typeIndex = 0;\n                while (*p && *p != '\"' && typeIndex < 31) {\n                    entry.type[typeIndex++] = *p++;\n                }\n                entry.type[typeIndex] = '\\0';\n            } else if (!strncmp(p, \"\\\"amount\\\":\", 9)) {\n                p += 9;\n                entry.amount = 0;\n                while (*p && std::isdigit(*p)) {\n                    entry.amount = entry.amount * 10 + (*p - '0');\n                    p++;\n                }\n            } else {\n\n                while (*p && *p != ',' && *p != '}') p++;\n            }\n\n            if (*p == ',') p++;\n        }\n\n        if (*p == '}') {\n            entryCount++;\n            p++;\n        } else {\n            break;\n        }\n\n        if (*p == ',') p++;\n    }\n\n\n    std::sort(entries, entries + entryCount, [](const Entry& a, const Entry& b) {\n        return strcmp(a.type, b.type) < 0;\n    });\n\n\n    char* out = outputBuffer;\n    *out++ = '{';\n    for (int i = 0; i < entryCount && out - outputBuffer < 510; i++) {\n        if (i > 0) *out++ = ',';\n        *out++ = '\\\"';\n<diff>        strncpy(out, entries[i].type, 31);\n        out += strlen(out);</diff>\n        *out++ = '\\\"';\n        *out++ = ':';\n        out += sprintf(out, \"%d\", entries[i].amount);\n    }\n    *out++ = '}';\n    *out = '\\0';\n\n\n    if (out - outputBuffer >= 511) {\n        outputBuffer[511] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n\nstruct Entry {\n    char type[32];\n    int amount;\n};\n\nvoid processData(const char* inputBuffer, char* outputBuffer) {\n    static const int MAX_ENTRIES = 50;\n    Entry entries[MAX_ENTRIES];\n    int entryCount = 0;\n\n\n    const char* p = inputBuffer;\n    while (*p && entryCount < MAX_ENTRIES) {\n        if (*p != '{') break;\n        p++;\n\n\n        Entry& entry = entries[entryCount];\n        entry.amount = 0;\n        entry.type[0] = '\\0';\n\n\n        while (*p && *p != '}') {\n            if (!strncmp(p, \"\\\"type\\\":\\\"\", 8)) {\n                p += 8;\n                int typeIndex = 0;\n                while (*p && *p != '\"' && typeIndex < 31) {\n                    entry.type[typeIndex++] = *p++;\n                }\n                entry.type[typeIndex] = '\\0';\n            } else if (!strncmp(p, \"\\\"amount\\\":\", 9)) {\n                p += 9;\n                entry.amount = 0;\n                while (*p && std::isdigit(*p)) {\n                    entry.amount = entry.amount * 10 + (*p - '0');\n                    p++;\n                }\n            } else {\n\n                while (*p && *p != ',' && *p != '}') p++;\n            }\n\n            if (*p == ',') p++;\n        }\n\n        if (*p == '}') {\n            entryCount++;\n            p++;\n        } else {\n            break;\n        }\n\n        if (*p == ',') p++;\n    }\n\n\n    std::sort(entries, entries + entryCount, [](const Entry& a, const Entry& b) {\n        return strcmp(a.type, b.type) < 0;\n    });\n\n\n    char* out = outputBuffer;\n    *out++ = '{';\n    for (int i = 0; i < entryCount && out - outputBuffer < 510; i++) {\n        if (i > 0) *out++ = ',';\n        *out++ = '\\\"';\n<diff>        strcpy(out, entries[i].type);\n        out += strlen(entries[i].type);</diff>\n        *out++ = '\\\"';\n        *out++ = ':';\n        out += sprintf(out, \"%d\", entries[i].amount);\n    }\n    *out++ = '}';\n    *out = '\\0';\n\n\n    if (out - outputBuffer >= 511) {\n        outputBuffer[511] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a std::map<std::string, int> and removes specified keys, then stores the result in a fixed-size character buffer. The function should have the following signature:\n\nvoid filterAndSerialize(const std::map<std::string, int>& input, const std::vector<std::string>& keys_to_remove, char* output_buffer, size_t buffer_size);\n\nThe function must:\n1. Create a new map with all keys except those in keys_to_remove\n2. Serialize this filtered map into output_buffer as key-value pairs in the format \"key:value,\"\n3. Not modify the original input map\n4. Work within the given buffer_size without checking its length\n\nThe output should only contain the serialized string in the buffer with no additional console output.", "chosen": "```cpp\n#include <map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid filterAndSerialize(const std::map<std::string, int>& input, const std::vector<std::string>& keys_to_remove, char* output_buffer, size_t buffer_size) {\n    std::map<std::string, int> filtered_map;\n\n\n    for (const auto& pair : input) {\n        if (std::find(keys_to_remove.begin(), keys_to_remove.end(), pair.first) == keys_to_remove.end()) {\n            filtered_map[pair.first] = pair.second;\n        }\n    }\n\n\n    size_t current_pos = 0;\n    for (const auto& pair : filtered_map) {\n\n + std::to_string(pair.second).size() + 1 /* comma */;\n        if (current_pos + required_space >= buffer_size) {\n            break;\n        }\n\n\n<diff>        strncpy(output_buffer + current_pos, pair.first.c_str(), buffer_size - current_pos - 1);\n        current_pos += pair.first.size();\n\n\n        output_buffer[current_pos++] = ':';\n\n\n        std::string value_str = std::to_string(pair.second);\n        strncpy(output_buffer + current_pos, value_str.c_str(), buffer_size - current_pos - 1);</diff>\n        current_pos += value_str.size();\n\n\n        output_buffer[current_pos++] = ',';\n    }\n\n\n    if (current_pos < buffer_size) {\n        output_buffer[current_pos] = '\\0';\n    } else {\n\n        output_buffer[buffer_size - 1] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid filterAndSerialize(const std::map<std::string, int>& input, const std::vector<std::string>& keys_to_remove, char* output_buffer, size_t buffer_size) {\n    std::map<std::string, int> filtered_map;\n\n\n    for (const auto& pair : input) {\n        if (std::find(keys_to_remove.begin(), keys_to_remove.end(), pair.first) == keys_to_remove.end()) {\n            filtered_map[pair.first] = pair.second;\n        }\n    }\n\n\n    size_t current_pos = 0;\n    for (const auto& pair : filtered_map) {\n\n + std::to_string(pair.second).size() + 1 /* comma */;\n        if (current_pos + required_space >= buffer_size) {\n            break;\n        }\n\n\n<diff>        std::strcpy(output_buffer + current_pos, pair.first.c_str());\n        current_pos += pair.first.size();\n\n\n        output_buffer[current_pos++] = ':';\n\n\n        std::string value_str = std::to_string(pair.second);\n        std::strcpy(output_buffer + current_pos, value_str.c_str());</diff>\n        current_pos += value_str.size();\n\n\n        output_buffer[current_pos++] = ',';\n    }\n\n\n    if (current_pos < buffer_size) {\n        output_buffer[current_pos] = '\\0';\n    } else {\n\n        output_buffer[buffer_size - 1] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts a timespan string (e.g., \"1d2h3m4s\") to microseconds. The function should take the input string and parse the time units (d for days, h for hours, m for minutes, s for seconds) to calculate the total microseconds. For efficiency, implement the parsing by processing the string directly in a fixed-size character buffer of 64 bytes. The function should return the calculated microseconds as a 64-bit integer.", "chosen": "```cpp\n#include <cstring>\n#include <cstdint>\n\n\nuint64_t timespanToMicroseconds(const char* timespanString) {\n    char buffer[64];\n<diff>    std::strncpy(buffer, timespanString, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n    uint64_t totalMicroseconds = 0;\n    uint64_t currentNumber = 0;\n    const uint64_t microsecondsPerSecond = 1000000;\n    const uint64_t microsecondsPerMinute = 60 * microsecondsPerSecond;\n    const uint64_t microsecondsPerHour = 60 * microsecondsPerMinute;\n    const uint64_t microsecondsPerDay = 24 * microsecondsPerHour;\n\n    for (size_t i = 0; i < std::strlen(buffer); ++i) {\n        char c = buffer[i];\n        if (c >= '0' && c <= '9') {\n            currentNumber = currentNumber * 10 + (c - '0');\n        } else {\n            switch (c) {\n                case 'd':\n                    totalMicroseconds += currentNumber * microsecondsPerDay;\n                    break;\n                case 'h':\n                    totalMicroseconds += currentNumber * microsecondsPerHour;\n                    break;\n                case 'm':\n                    totalMicroseconds += currentNumber * microsecondsPerMinute;\n                    break;\n                case 's':\n                    totalMicroseconds += currentNumber * microsecondsPerSecond;\n                    break;\n                default:\n\n                    break;\n            }\n            currentNumber = 0;\n        }\n    }\n\n    if (currentNumber > 0) {\n        totalMicroseconds += currentNumber * microsecondsPerSecond;\n    }\n\n    return totalMicroseconds;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdint>\n\n\nuint64_t timespanToMicroseconds(const char* timespanString) {\n    char buffer[64];\n<diff>    std::strcpy(buffer, timespanString);</diff>\n    uint64_t totalMicroseconds = 0;\n    uint64_t currentNumber = 0;\n    const uint64_t microsecondsPerSecond = 1000000;\n    const uint64_t microsecondsPerMinute = 60 * microsecondsPerSecond;\n    const uint64_t microsecondsPerHour = 60 * microsecondsPerMinute;\n    const uint64_t microsecondsPerDay = 24 * microsecondsPerHour;\n\n    for (size_t i = 0; i < std::strlen(buffer); ++i) {\n        char c = buffer[i];\n        if (c >= '0' && c <= '9') {\n            currentNumber = currentNumber * 10 + (c - '0');\n        } else {\n            switch (c) {\n                case 'd':\n                    totalMicroseconds += currentNumber * microsecondsPerDay;\n                    break;\n                case 'h':\n                    totalMicroseconds += currentNumber * microsecondsPerHour;\n                    break;\n                case 'm':\n                    totalMicroseconds += currentNumber * microsecondsPerMinute;\n                    break;\n                case 's':\n                    totalMicroseconds += currentNumber * microsecondsPerSecond;\n                    break;\n                default:\n\n                    break;\n            }\n            currentNumber = 0;\n        }\n    }\n\n    if (currentNumber > 0) {\n        totalMicroseconds += currentNumber * microsecondsPerSecond;\n    }\n\n    return totalMicroseconds;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes product data and groups it by category. The input is a vector of Product structs, where each Product has: a name (null-terminated char array), category (null-terminated char array), and price (double). For efficiency, use fixed-size buffers of 256 bytes for all string operations. Your function should:\n1. Group products by their category in an unordered_map\n2. For each category, store a vector containing all product names and their total aggregated price\n3. Return the resulting map where keys are category names and values are pairs containing a vector of product names and the category's total price\n\nNote: All string operations must be performed in-place without dynamic memory allocation for performance reasons. The output should exactly match the required format with no additional information.", "chosen": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <cstring>\n\nstruct Product {\n    char name[256];\n    char category[256];\n    double price;\n};\n\nstruct CategoryData {\n    char productNames[256];\n    double totalPrice;\n};\n\nusing CategoryMap = std::unordered_map<std::string, CategoryData>;\n\nvoid addProductName(char* buffer, const char* name) {\n<diff>    size_t currentLength = strlen(buffer);\n    size_t nameLength = strlen(name);\n    if (currentLength + nameLength + 1 >= 256) {\n        return;\n    }\n    if (currentLength > 0) {\n        strcat(buffer, \" \");\n    }\n    strncat(buffer, name, 255 - currentLength - 1);</diff>\n}\n\nCategoryMap groupProductsByCategory(const std::vector<Product>& products) {\n    CategoryMap categoryMap;\n\n    for (const auto& product : products) {\n        auto& categoryData = categoryMap[product.category];\n\n\n        addProductName(categoryData.productNames, product.name);\n\n\n        categoryData.totalPrice += product.price;\n    }\n\n    return categoryMap;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <cstring>\n\nstruct Product {\n    char name[256];\n    char category[256];\n    double price;\n};\n\nstruct CategoryData {\n    char productNames[256];\n    double totalPrice;\n};\n\nusing CategoryMap = std::unordered_map<std::string, CategoryData>;\n\nvoid addProductName(char* buffer, const char* name) {\n<diff>    if (strlen(buffer) + strlen(name) + 1 >= 256) {\n        return;\n    }\n    if (strlen(buffer) > 0) {\n        strcat(buffer, \" \");\n    }\n    strcat(buffer, name);</diff>\n}\n\nCategoryMap groupProductsByCategory(const std::vector<Product>& products) {\n    CategoryMap categoryMap;\n\n    for (const auto& product : products) {\n        auto& categoryData = categoryMap[product.category];\n\n\n        addProductName(categoryData.productNames, product.name);\n\n\n        categoryData.totalPrice += product.price;\n    }\n\n    return categoryMap;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `read_and_format_csv` that takes a file path to a CSV file as input and returns a vector of formatted strings. The function should read the file line-by-line into a fixed 1024-byte buffer, parse each line into tuples (date, value), then format each tuple into a fixed 256-byte output buffer in the format \"DATE: [date], VALUE: [value]\". For efficiency, all string operations must be performed in-place within the provided buffers without dynamic memory allocation. The function should return a vector containing all formatted strings.", "chosen": "```cpp\n#include <fstream>\n#include <vector>\n#include <cstring>\n\nstd::vector<char[256]> read_and_format_csv(const char* filePath) {\n    std::ifstream file(filePath);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    std::vector<char[256]> formattedLines;\n    char buffer[1024];\n\n    while (file.getline(buffer, sizeof(buffer))) {\n        char date[32] = {0};\n        char value[64] = {0};\n\n\n        char* token = std::strtok(buffer, \",\");\n        if (token != nullptr) {\n            std::strncpy(date, token, sizeof(date) - 1);\n        }\n\n        token = std::strtok(nullptr, \",\");\n        if (token != nullptr) {\n            std::strncpy(value, token, sizeof(value) - 1);\n        }\n\n\n        char formattedBuffer[256];\n        std::snprintf(formattedBuffer, sizeof(formattedBuffer), \"DATE: %s, VALUE: %s\", date, value);\n\n\n        formattedLines.push_back({0});\n<diff>        std::strncpy(formattedLines.back(), formattedBuffer, sizeof(formattedBuffer) - 1);</diff>\n    }\n\n    file.close();\n    return formattedLines;\n}\n```", "rejected": "```cpp\n#include <fstream>\n#include <vector>\n#include <cstring>\n\nstd::vector<char[256]> read_and_format_csv(const char* filePath) {\n    std::ifstream file(filePath);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    std::vector<char[256]> formattedLines;\n    char buffer[1024];\n\n    while (file.getline(buffer, sizeof(buffer))) {\n        char date[32] = {0};\n        char value[64] = {0};\n\n\n        char* token = std::strtok(buffer, \",\");\n        if (token != nullptr) {\n            std::strncpy(date, token, sizeof(date) - 1);\n        }\n\n        token = std::strtok(nullptr, \",\");\n        if (token != nullptr) {\n            std::strncpy(value, token, sizeof(value) - 1);\n        }\n\n\n        char formattedBuffer[256];\n        std::snprintf(formattedBuffer, sizeof(formattedBuffer), \"DATE: %s, VALUE: %s\", date, value);\n\n\n        formattedLines.push_back({0});\n<diff>        std::strcpy(formattedLines.back(), formattedBuffer);</diff>\n    }\n\n    file.close();\n    return formattedLines;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that adds a prefix to an ID string if it doesn't already start with that prefix. The function should modify the ID string in-place within a fixed-size buffer of 256 bytes. The function signature should be:\n\nvoid add_prefix_to_id(char* id, const char* prefix);\n\nIf the ID already starts with the prefix, leave it unchanged. Otherwise, prepend the prefix to the ID directly in the provided buffer. Assume the buffer is always large enough to hold the result (but don't verify this). The function should not allocate any additional memory or use C++ strings - only work with the provided character buffers.", "chosen": "```cpp\n#include <cstring>\n\nvoid add_prefix_to_id(char* id, const char* prefix) {\n\n    size_t prefix_len = std::strlen(prefix);\n    size_t id_len = std::strlen(id);\n\n\n    if (std::strncmp(id, prefix, prefix_len) == 0) {\n\n        return;\n    }\n\n\n\n    for (size_t i = id_len; i > 0; --i) {\n        id[i + prefix_len - 1] = id[i - 1];\n    }\n\n\n<diff>    std::strncpy(id, prefix, prefix_len);\n    id[prefix_len] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid add_prefix_to_id(char* id, const char* prefix) {\n\n    size_t prefix_len = std::strlen(prefix);\n    size_t id_len = std::strlen(id);\n\n\n    if (std::strncmp(id, prefix, prefix_len) == 0) {\n\n        return;\n    }\n\n\n\n    for (size_t i = id_len; i > 0; --i) {\n        id[i + prefix_len - 1] = id[i - 1];\n    }\n\n\n<diff>    std::strcpy(id, prefix);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `getAttribsStr` that takes an object and writes its attribute names and values to a fixed-size character buffer of 256 bytes. The function should return a string containing all non-Null attribute name-value pairs separated by commas (e.g., \"a=1, b=2\"). For efficiency, the string must be constructed in-place in the provided buffer without using intermediate string objects. The buffer should be exactly filled with no wasted space, and the function must return a pointer to the filled buffer.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nclass MyObject {\npublic:\n    struct Attribute {\n        const char* name;\n        const char* value;\n    };\n\n\n    size_t getAttributeCount() const {\n\n        return 3;\n    }\n\n\n    Attribute getAttribute(size_t index) const {\n        static Attribute attrs[] = {\n            {\"a\", \"1\"},\n            {\"b\", \"2\"},\n            {\"c\", nullptr}\n        };\n        return attrs[index];\n    }\n};\n\nconst char* getAttribsStr(MyObject& obj, char buffer[256]) {\n    size_t bufferIndex = 0;\n    size_t attrCount = obj.getAttributeCount();\n    bool first = true;\n\n    for (size_t i = 0; i < attrCount; ++i) {\n        MyObject::Attribute attr = obj.getAttribute(i);\n        if (attr.value != nullptr) {\n            if (!first) {\n                if (bufferIndex < 255) buffer[bufferIndex++] = ',';\n                if (bufferIndex < 255) buffer[bufferIndex++] = ' ';\n            }\n            first = false;\n\n            size_t nameLen = strlen(attr.name);\n            size_t valueLen = strlen(attr.value);\n            if (bufferIndex + nameLen + valueLen + 2 <= 255) {\n<diff>                strncpy(buffer + bufferIndex, attr.name, 255 - bufferIndex);\n                bufferIndex += nameLen;\n                if (bufferIndex < 255) buffer[bufferIndex++] = '=';\n                strncpy(buffer + bufferIndex, attr.value, 255 - bufferIndex);</diff>\n                bufferIndex += valueLen;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (bufferIndex < 256) buffer[bufferIndex] = '\\0';\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nclass MyObject {\npublic:\n    struct Attribute {\n        const char* name;\n        const char* value;\n    };\n\n\n    size_t getAttributeCount() const {\n\n        return 3;\n    }\n\n\n    Attribute getAttribute(size_t index) const {\n        static Attribute attrs[] = {\n            {\"a\", \"1\"},\n            {\"b\", \"2\"},\n            {\"c\", nullptr}\n        };\n        return attrs[index];\n    }\n};\n\nconst char* getAttribsStr(MyObject& obj, char buffer[256]) {\n    size_t bufferIndex = 0;\n    size_t attrCount = obj.getAttributeCount();\n    bool first = true;\n\n    for (size_t i = 0; i < attrCount; ++i) {\n        MyObject::Attribute attr = obj.getAttribute(i);\n        if (attr.value != nullptr) {\n            if (!first) {\n                if (bufferIndex < 255) buffer[bufferIndex++] = ',';\n                if (bufferIndex < 255) buffer[bufferIndex++] = ' ';\n            }\n            first = false;\n\n            size_t nameLen = strlen(attr.name);\n            size_t valueLen = strlen(attr.value);\n            if (bufferIndex + nameLen + valueLen + 2 <= 255) {\n<diff>                strcpy(buffer + bufferIndex, attr.name);\n                bufferIndex += nameLen;\n                if (bufferIndex < 255) buffer[bufferIndex++] = '=';\n                strcpy(buffer + bufferIndex, attr.value);</diff>\n                bufferIndex += valueLen;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (bufferIndex < 256) buffer[bufferIndex] = '\\0';\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that constructs a function call string from given components. The function should take the following parameters:\n1. `funcName`: A null-terminated string representing the function name\n2. `args`: An array of null-terminated strings representing arguments\n3. `numArgs`: The number of arguments in the array\n4. `output`: A pre-allocated character buffer where the result will be written\n5. `bufSize`: The size of the output buffer\n\nThe function should construct the string in the format: \"funcName(arg1, arg2, ...)\" and write it to the output buffer. For efficiency, you must build the string directly in the output buffer without using intermediate strings or dynamic allocation. The function should return true if successful, false if the buffer is too small.\n\nExample: For funcName=\"foo\", args={\"1\", \"'bar'\"}, numArgs=2, the output should be \"foo(1, 'bar')\".\n\nNote: Your implementation must handle all string operations directly in the output buffer and should not use any C++ string classes or dynamic memory allocation.", "chosen": "```cpp\n#include <cstring>\n\nbool constructFunctionCallString(const char* funcName, const char** args, int numArgs, char* output, size_t bufSize) {\n    size_t pos = 0;\n\n\n    size_t funcNameLen = std::strlen(funcName);\n    if (pos + funcNameLen + 1 >= bufSize) return false;\n<diff>    std::strncpy(output + pos, funcName, funcNameLen);\n    pos += funcNameLen;\n    output[pos++] = '(';\n\n\n    for (int i = 0; i < numArgs; ++i) {\n        size_t argLen = std::strlen(args[i]);\n        if (pos + argLen + (i > 0 ? 2 : 1) >= bufSize) return false;\n        if (i > 0) {\n            output[pos++] = ',';\n            output[pos++] = ' ';\n        }\n        std::strncpy(output + pos, args[i], argLen);</diff>\n        pos += argLen;\n    }\n\n\n    if (pos + 1 >= bufSize) return false;\n    output[pos++] = ')';\n\n\n    if (pos >= bufSize) return false;\n    output[pos] = '\\0';\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nbool constructFunctionCallString(const char* funcName, const char** args, int numArgs, char* output, size_t bufSize) {\n    size_t pos = 0;\n\n\n    size_t funcNameLen = std::strlen(funcName);\n    if (pos + funcNameLen + 1 >= bufSize) return false;\n<diff>    std::strcpy(output + pos, funcName);\n    pos += funcNameLen;\n    output[pos++] = '(';\n\n\n    for (int i = 0; i < numArgs; ++i) {\n        size_t argLen = std::strlen(args[i]);\n        if (pos + argLen + (i > 0 ? 2 : 1) >= bufSize) return false;\n        if (i > 0) {\n            output[pos++] = ',';\n            output[pos++] = ' ';\n        }\n        std::strcpy(output + pos, args[i]);</diff>\n        pos += argLen;\n    }\n\n\n    if (pos + 1 >= bufSize) return false;\n    output[pos++] = ')';\n\n\n    if (pos >= bufSize) return false;\n    output[pos] = '\\0';\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Create a C++ class called `StatusTracker` with two private member variables: an integer `value` and a boolean `is_ready`. The class should have public methods to get and set the value. When setting the value:\n1. If the input is a string, convert it to an integer by copying it into a temporary character buffer before conversion (for efficiency)\n2. If the new value is non-zero, set `is_ready` to true\n3. If the new value is zero, only set `is_ready` to false if it wasn't already true\n4. Provide getter methods for both properties\n\nFor performance considerations, implement the string-to-int conversion directly using character buffers rather than string streams.", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\nclass StatusTracker {\nprivate:\n    int value;\n    bool is_ready;\n\n\n    static int stringToInt(const char* str) {\n        char* endptr;\n        long val = std::strtol(str, &endptr, 10);\n        if (*endptr != '\\0') {\n\n            return 0;\n        }\n        return static_cast<int>(val);\n    }\n\npublic:\n\n    StatusTracker() : value(0), is_ready(false) {}\n\n\n    int getValue() const {\n        return value;\n    }\n\n\n    bool getIsReady() const {\n        return is_ready;\n    }\n\n\n    void setValue(int newValue) {\n        value = newValue;\n        if (newValue != 0) {\n            is_ready = true;\n        } else if (is_ready) {\n            is_ready = false;\n        }\n    }\n\n\n    void setValue(const char* newValueStr) {\n\n        char buffer[256];\n        std::size_t len = std::strlen(newValueStr);\n        if (len >= sizeof(buffer)) {\n\n            return;\n        }\n<diff>        std::strncpy(buffer, newValueStr, sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n\n        int newValue = stringToInt(buffer);\n\n\n        setValue(newValue);\n    }\n};\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\nclass StatusTracker {\nprivate:\n    int value;\n    bool is_ready;\n\n\n    static int stringToInt(const char* str) {\n        char* endptr;\n        long val = std::strtol(str, &endptr, 10);\n        if (*endptr != '\\0') {\n\n            return 0;\n        }\n        return static_cast<int>(val);\n    }\n\npublic:\n\n    StatusTracker() : value(0), is_ready(false) {}\n\n\n    int getValue() const {\n        return value;\n    }\n\n\n    bool getIsReady() const {\n        return is_ready;\n    }\n\n\n    void setValue(int newValue) {\n        value = newValue;\n        if (newValue != 0) {\n            is_ready = true;\n        } else if (is_ready) {\n            is_ready = false;\n        }\n    }\n\n\n    void setValue(const char* newValueStr) {\n\n        char buffer[256];\n        std::size_t len = std::strlen(newValueStr);\n        if (len >= sizeof(buffer)) {\n\n            return;\n        }\n<diff>        std::strcpy(buffer, newValueStr);</diff>\n\n\n        int newValue = stringToInt(buffer);\n\n\n        setValue(newValue);\n    }\n};\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of column names (as C-style strings) to remove those containing a specific keyword. The function should take three parameters: an array of fixed-size character buffers (each 256 bytes) containing column names, an integer count of columns, and a keyword string. The function must modify the array in-place by removing entries where the column name contains the keyword (at start, middle, or end). After removal, the remaining column names should be compacted to the front of the array, and the function should return the new count. For efficiency, perform all string operations directly on the original buffers without allocating additional memory. The comparison should be case-sensitive.", "chosen": "```cpp\n#include <cstring>\n\n\nint removeColumnsWithKeyword(char columns[][256], int count, const char* keyword) {\n    int writeIndex = 0;\n\n    for (int i = 0; i < count; ++i) {\n        if (strstr(columns[i], keyword) == nullptr) {\n\n            if (writeIndex != i) {\n<diff>                strncpy(columns[writeIndex], columns[i], 255);\n                columns[writeIndex][255] = '\\0';</diff>\n            }\n            ++writeIndex;\n        }\n    }\n\n    return writeIndex;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nint removeColumnsWithKeyword(char columns[][256], int count, const char* keyword) {\n    int writeIndex = 0;\n\n    for (int i = 0; i < count; ++i) {\n        if (strstr(columns[i], keyword) == nullptr) {\n\n            if (writeIndex != i) {\n<diff>                strcpy(columns[writeIndex], columns[i]);</diff>\n            }\n            ++writeIndex;\n        }\n    }\n\n    return writeIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `create_gtest_filter` that constructs a GTest filter string from a list of test cases in a pre-allocated 256-byte buffer. The function should take a list of test case conditions and build the filter string in-place in the buffer for maximum efficiency. The filter should include tests matching positive conditions and exclude those matching negative conditions (prefixed with '-'). Multiple conditions should be separated by colons. The function should return a pointer to the constructed filter string in the buffer.\n\nRequirements:\n1. Construct the entire filter string in the provided buffer without intermediate allocations\n2. Handle an arbitrary number of input conditions (positive and negative)\n3. Conditions should be combined with ':' separators\n4. Return a pointer to the constructed string for immediate use\n\nExample:\nInput: {\"Foo\", \"-Bar\", \"Baz\"}\nOutput: \"Foo:Baz:-Bar\"", "chosen": "```cpp\n#include <cstdarg>\n#include <cstring>\n\nchar* create_gtest_filter(char* buffer, size_t bufferSize, int conditionCount, ...) {\n    va_list args;\n    va_start(args, conditionCount);\n\n    char* ptr = buffer;\n    const char* separator = \"\";\n    size_t remainingSpace = bufferSize - 1;\n\n    for (int i = 0; i < conditionCount; ++i) {\n        const char* condition = va_arg(args, const char*);\n        size_t conditionLength = strlen(condition);\n\n        if (conditionLength >= remainingSpace) {\n\n            break;\n        }\n\n\n<diff>        strncpy(ptr, separator, remainingSpace);\n        ptr += strlen(separator);\n\n\n        strncpy(ptr, condition, remainingSpace);</diff>\n        ptr += conditionLength;\n\n\n        separator = \":\";\n\n\n        remainingSpace -= conditionLength + 1;\n    }\n\n\n    *ptr = '\\0';\n\n    va_end(args);\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstdarg>\n#include <cstring>\n\nchar* create_gtest_filter(char* buffer, size_t bufferSize, int conditionCount, ...) {\n    va_list args;\n    va_start(args, conditionCount);\n\n    char* ptr = buffer;\n    const char* separator = \"\";\n    size_t remainingSpace = bufferSize - 1;\n\n    for (int i = 0; i < conditionCount; ++i) {\n        const char* condition = va_arg(args, const char*);\n        size_t conditionLength = strlen(condition);\n\n        if (conditionLength >= remainingSpace) {\n\n            break;\n        }\n\n\n<diff>        strcpy(ptr, separator);\n        ptr += strlen(separator);\n\n\n        strcpy(ptr, condition);</diff>\n        ptr += conditionLength;\n\n\n        separator = \":\";\n\n\n        remainingSpace -= conditionLength + 1;\n    }\n\n\n    *ptr = '\\0';\n\n    va_end(args);\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function for a doubly linked list node that prints all subsequent node values and unifies the list into a single direction. The node structure contains `int value`, `Node* next`, and `Node* prev`. Your function `print_and_unify_list()` must:\n1. Print all node values starting from current node to the end (including current node)\n2. Store the output string in a fixed-size character buffer of 256 bytes\n3. Convert all `prev` pointers to null, effectively making it a singly linked list\n4. Print the values in order separated by spaces with no trailing space\n5. The output must be built in-place in the buffer by first writing the current node's value, then appending subsequent values\n\nNote: Assume all node values are positive integers less than 1000.", "chosen": "```cpp\n#include <iostream>\n#include <cstdio>\n\nstruct Node {\n    int value;\n    Node* next;\n    Node* prev;\n\n    Node(int val) : value(val), next(nullptr), prev(nullptr) {}\n};\n\nvoid print_and_unify_list(Node* current) {\n    char buffer[256];\n    buffer[0] = '\\0';\n\n    char temp[5];\n\n    while (current != nullptr) {\n\n        std::sprintf(temp, \"%d\", current->value);\n        if (buffer[0] != '\\0') {\n<diff>            std::strncat(buffer, \" \", sizeof(buffer) - std::strlen(buffer) - 1);\n        }\n        std::strncat(buffer, temp, sizeof(buffer) - std::strlen(buffer) - 1);</diff>\n\n\n        current->prev = nullptr;\n\n\n        current = current->next;\n    }\n\n\n    std::cout << buffer << std::endl;\n}\n\n\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    print_and_unify_list(head);\n\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstdio>\n\nstruct Node {\n    int value;\n    Node* next;\n    Node* prev;\n\n    Node(int val) : value(val), next(nullptr), prev(nullptr) {}\n};\n\nvoid print_and_unify_list(Node* current) {\n    char buffer[256];\n    buffer[0] = '\\0';\n\n    char temp[5];\n\n    while (current != nullptr) {\n\n        std::sprintf(temp, \"%d\", current->value);\n        if (buffer[0] != '\\0') {\n<diff>            std::strcat(buffer, \" \");\n        }\n        std::strcat(buffer, temp);</diff>\n\n\n        current->prev = nullptr;\n\n\n        current = current->next;\n    }\n\n\n    std::cout << buffer << std::endl;\n}\n\n\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    print_and_unify_list(head);\n\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function to sort an array of strings based on a custom comparator. The function should take three arguments: an array of strings, the number of strings in the array, and a comparator function. The comparator function should take two C-style strings (char pointers) as input and return an integer (-1, 0, or 1) indicating whether the first string is less than, equal to, or greater than the second string. For efficiency, the sorting should be done in-place by swapping string pointers in the array. Assume all strings are null-terminated and the array is large enough to hold all strings.", "chosen": "```cpp\n#include <cstdlib>\n<diff>#include <ctime>\n#include <random>\n\n\nvoid quickSort(char** arr, int low, int high, int (*comparator)(const char*, const char*));\nint partition(char** arr, int low, int high, int (*comparator)(const char*, const char*));\nvoid swap(char** a, char** b);\n\n\nvoid sortStrings(char** arr, int numStrings, int (*comparator)(const char*, const char*)) {\n    quickSort(arr, 0, numStrings - 1, comparator);\n}\n\n\nint partition(char** arr, int low, int high, int (*comparator)(const char*, const char*)) {\n\n    static std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\n    std::uniform_int_distribution<int> dist(low, high);\n    int pivotIndex = dist(rng);</diff>\n    swap(&arr[pivotIndex], &arr[high]);\n\n    char* pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n        if (comparator(arr[j], pivot) < 0) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\n\nvoid quickSort(char** arr, int low, int high, int (*comparator)(const char*, const char*)) {\n    if (low < high) {\n        int pi = partition(arr, low, high, comparator);\n        quickSort(arr, low, pi - 1, comparator);\n        quickSort(arr, pi + 1, high, comparator);\n    }\n}\n\n\nvoid swap(char** a, char** b) {\n    char* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```", "rejected": "```cpp\n#include <cstdlib>\n<diff>\n\nvoid quickSort(char** arr, int low, int high, int (*comparator)(const char*, const char*));\nint partition(char** arr, int low, int high, int (*comparator)(const char*, const char*));\nvoid swap(char** a, char** b);\n\n\nvoid sortStrings(char** arr, int numStrings, int (*comparator)(const char*, const char*)) {\n    quickSort(arr, 0, numStrings - 1, comparator);\n}\n\n\nint partition(char** arr, int low, int high, int (*comparator)(const char*, const char*)) {\n\n    int pivotIndex = low + rand() % (high - low + 1);</diff>\n    swap(&arr[pivotIndex], &arr[high]);\n\n    char* pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n        if (comparator(arr[j], pivot) < 0) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\n\nvoid quickSort(char** arr, int low, int high, int (*comparator)(const char*, const char*)) {\n    if (low < high) {\n        int pi = partition(arr, low, high, comparator);\n        quickSort(arr, low, pi - 1, comparator);\n        quickSort(arr, pi + 1, high, comparator);\n    }\n}\n\n\nvoid swap(char** a, char** b) {\n    char* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Write a C++ function that processes country email data and stores results in a provided output buffer. The function should take three parameters:\n1. A pointer to an array of country names (null-terminated strings)\n2. A pointer to an array of email arrays (each email is a null-terminated string, arrays are terminated by a NULL pointer)\n3. A pre-allocated output buffer of exactly 256 bytes to store results\n\nFor each country, count its non-empty emails and store the result in the output buffer as \"CountryName:count\\n\". The output must be built directly in the provided buffer without intermediate storage. Assume there will never be more than 10 countries.\n\nExample input:\ncountries = [\"United States\", \"Canada\", \"Mexico\", NULL]\nemails = [[\"\", \"\", NULL], [\"\", NULL], [NULL], NULL]\n\nExpected output buffer contents after processing:\n\"United States:2\\nCanada:1\\nMexico:0\\n\"", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid processEmailData(const char** countries, const char*** emails, char* outputBuffer) {\n    char* bufferPtr = outputBuffer;\n\n    for (size_t i = 0; countries[i] != NULL && i < 10; ++i) {\n        const char* country = countries[i];\n        const char** emailArray = emails[i];\n        int emailCount = 0;\n\n\n        for (size_t j = 0; emailArray[j] != NULL; ++j) {\n            if (*emailArray[j] != '\\0') {\n                ++emailCount;\n            }\n        }\n\n\n        size_t countryLength = std::strlen(country);\n        size_t countLength = std::snprintf(nullptr, 0, \"%d\", emailCount);\n\n\n        if (bufferPtr + countryLength + countLength + 3 >= outputBuffer + 256) {\n            break;\n        }\n\n\n<diff>        std::strncpy(bufferPtr, country, countryLength);</diff>\n        bufferPtr += countryLength;\n        *bufferPtr++ = ':';\n        bufferPtr += std::sprintf(bufferPtr, \"%d\", emailCount);\n        *bufferPtr++ = '\\n';\n    }\n\n    *bufferPtr = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid processEmailData(const char** countries, const char*** emails, char* outputBuffer) {\n    char* bufferPtr = outputBuffer;\n\n    for (size_t i = 0; countries[i] != NULL && i < 10; ++i) {\n        const char* country = countries[i];\n        const char** emailArray = emails[i];\n        int emailCount = 0;\n\n\n        for (size_t j = 0; emailArray[j] != NULL; ++j) {\n            if (*emailArray[j] != '\\0') {\n                ++emailCount;\n            }\n        }\n\n\n        size_t countryLength = std::strlen(country);\n        size_t countLength = std::snprintf(nullptr, 0, \"%d\", emailCount);\n\n\n        if (bufferPtr + countryLength + countLength + 3 >= outputBuffer + 256) {\n            break;\n        }\n\n\n<diff>        std::strcpy(bufferPtr, country);</diff>\n        bufferPtr += countryLength;\n        *bufferPtr++ = ':';\n        bufferPtr += std::sprintf(bufferPtr, \"%d\", emailCount);\n        *bufferPtr++ = '\\n';\n    }\n\n    *bufferPtr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a vector of Item structures, where each Item has a name (string) and type (string). Your task is to:\n1. Extract all unique types into a vector<string>\n2. Create a map<string, int> counting occurrences of each type\n3. Format the results into a fixed-size output buffer (256 bytes) as:\n   - First line: comma-separated unique types\n   - Subsequent lines: \"type:count\" pairs\n\nFor efficiency, you must:\n- Process strings in-place without dynamic allocations\n- Build the output directly in the provided buffer\n- Return the buffer pointer\n\nExample: For input { {\"a\", \"t1\"}, {\"b\", \"t2\"}, {\"c\", \"t1\"} }, the buffer should contain:\n\"t1,t2\\nt1:2\\nt2:1\\n\"\n\nNote: The buffer size is guaranteed to be sufficient for all test cases.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nstruct Item {\n    std::string name;\n    std::string type;\n};\n\nconst int MAX_TYPES = 100;\n\nchar* processItems(const std::vector<Item>& items, char* buffer) {\n    char* uniqueTypes[MAX_TYPES];\n    int typeCounts[MAX_TYPES];\n    int uniqueTypeCount = 0;\n\n\n    for (const auto& item : items) {\n        bool found = false;\n        for (int i = 0; i < uniqueTypeCount; ++i) {\n            if (uniqueTypes[i] && strcmp(uniqueTypes[i], item.type.c_str()) == 0) {\n                typeCounts[i]++;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            uniqueTypes[uniqueTypeCount] = const_cast<char*>(item.type.c_str());\n            typeCounts[uniqueTypeCount] = 1;\n            uniqueTypeCount++;\n        }\n    }\n\n\n    char* ptr = buffer;\n\n\n    for (int i = 0; i < uniqueTypeCount; ++i) {\n<diff>        strncpy(ptr, uniqueTypes[i], MAX_TYPES);\n        ptr += strlen(uniqueTypes[i]);\n        if (i < uniqueTypeCount - 1) {\n            *ptr++ = ',';\n        }\n    }\n    *ptr++ = '\\n';\n\n\n    for (int i = 0; i < uniqueTypeCount; ++i) {\n        strncpy(ptr, uniqueTypes[i], MAX_TYPES);</diff>\n        ptr += strlen(uniqueTypes[i]);\n        *ptr++ = ':';\n        ptr += sprintf(ptr, \"%d\", typeCounts[i]);\n        *ptr++ = '\\n';\n    }\n\n\n    *ptr = '\\0';\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nstruct Item {\n    std::string name;\n    std::string type;\n};\n\nconst int MAX_TYPES = 100;\n\nchar* processItems(const std::vector<Item>& items, char* buffer) {\n    char* uniqueTypes[MAX_TYPES];\n    int typeCounts[MAX_TYPES];\n    int uniqueTypeCount = 0;\n\n\n    for (const auto& item : items) {\n        bool found = false;\n        for (int i = 0; i < uniqueTypeCount; ++i) {\n            if (uniqueTypes[i] && strcmp(uniqueTypes[i], item.type.c_str()) == 0) {\n                typeCounts[i]++;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            uniqueTypes[uniqueTypeCount] = const_cast<char*>(item.type.c_str());\n            typeCounts[uniqueTypeCount] = 1;\n            uniqueTypeCount++;\n        }\n    }\n\n\n    char* ptr = buffer;\n\n\n    for (int i = 0; i < uniqueTypeCount; ++i) {\n<diff>        strcpy(ptr, uniqueTypes[i]);\n        ptr += strlen(uniqueTypes[i]);\n        if (i < uniqueTypeCount - 1) {\n            *ptr++ = ',';\n        }\n    }\n    *ptr++ = '\\n';\n\n\n    for (int i = 0; i < uniqueTypeCount; ++i) {\n        strcpy(ptr, uniqueTypes[i]);</diff>\n        ptr += strlen(uniqueTypes[i]);\n        *ptr++ = ':';\n        ptr += sprintf(ptr, \"%d\", typeCounts[i]);\n        *ptr++ = '\\n';\n    }\n\n\n    *ptr = '\\0';\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that extracts substrings matching a given regular expression pattern from an input string. The function should take a null-terminated input string and a regular expression pattern, and write all matching substrings into a pre-allocated output buffer of fixed size 256 bytes. For efficiency, the matches should be written consecutively into the buffer without additional formatting. The function should return the number of matches found. Handle all common regex features including quantifiers, alternatives, and character classes.", "chosen": "```cpp\n#include <iostream>\n#include <regex>\n#include <cstring>\n\nint extractSubstrings(const char* input, const char* pattern, char* outputBuffer, size_t bufferSize) {\n    if (!input || !pattern || !outputBuffer || bufferSize == 0) {\n        return 0;\n    }\n\n    std::string inputStr(input);\n    std::regex regexPattern(pattern);\n    auto words_begin = std::sregex_iterator(inputStr.begin(), inputStr.end(), regexPattern);\n    auto words_end = std::sregex_iterator();\n\n    size_t totalLength = 0;\n    int matchCount = 0;\n\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string matchStr = match.str();\n\n\n<diff>        if (totalLength + matchStr.length() + 1 >= bufferSize) {\n            break;\n        }\n\n\n        std::strncpy(outputBuffer + totalLength, matchStr.c_str(), bufferSize - totalLength - 1);\n        totalLength += matchStr.length();\n        ++matchCount;\n    }\n\n\n    outputBuffer[totalLength] = '\\0';</diff>\n\n    return matchCount;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <regex>\n#include <cstring>\n\nint extractSubstrings(const char* input, const char* pattern, char* outputBuffer, size_t bufferSize) {\n    if (!input || !pattern || !outputBuffer || bufferSize == 0) {\n        return 0;\n    }\n\n    std::string inputStr(input);\n    std::regex regexPattern(pattern);\n    auto words_begin = std::sregex_iterator(inputStr.begin(), inputStr.end(), regexPattern);\n    auto words_end = std::sregex_iterator();\n\n    size_t totalLength = 0;\n    int matchCount = 0;\n\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string matchStr = match.str();\n\n\n<diff>        if (totalLength + matchStr.length() >= bufferSize) {\n            break;\n        }\n\n\n        std::strcpy(outputBuffer + totalLength, matchStr.c_str());\n        totalLength += matchStr.length();\n        ++matchCount;\n    }</diff>\n\n    return matchCount;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function that processes employee records from a fixed-size input buffer and sorts them in descending order by ID. The function should:\n1. Take a character buffer containing employee records in CSV format (\"name,id\\n\")\n2. Parse each record into a struct with name (char array) and id (int) fields\n3. Sort the records in-place by id in descending order\n4. Write the sorted records back to the original buffer in the same CSV format\n\nFor efficiency, use a single fixed-size buffer for both input and output, and perform all operations in-place. Assume the buffer is always large enough to hold the input data, but individual name fields may vary in length.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\n\nstruct Employee {\n    char name[100];\n    int id;\n};\n\n\nvoid processEmployeeRecords(char* buffer) {\n    const size_t bufferSize = strlen(buffer);\n    Employee employees[100];\n    int numEmployees = 0;\n\n\n    char* token = strtok(buffer, \"\\n\");\n    while (token != nullptr && numEmployees < 100) {\n        char* nameEnd = strchr(token, ',');\n        if (nameEnd != nullptr) {\n            size_t nameLength = nameEnd - token;\n            strncpy(employees[numEmployees].name, token, nameLength);\n            employees[numEmployees].name[nameLength] = '\\0';\n            employees[numEmployees].id = std::stoi(nameEnd + 1);\n            ++numEmployees;\n        }\n        token = strtok(nullptr, \"\\n\");\n    }\n\n\n    std::sort(employees, employees + numEmployees, [](const Employee& a, const Employee& b) {\n        return a.id > b.id;\n    });\n\n\n    char* writePtr = buffer;\n    for (int i = 0; i < numEmployees; ++i) {\n<diff>        writePtr += snprintf(writePtr, bufferSize - (writePtr - buffer), \"%s,%d\\n\", employees[i].name, employees[i].id);</diff>\n    }\n}\n\n\nint main() {\n    char buffer[] = \"Alice,102\\nBob,101\\nCharlie,103\\n\";\n    processEmployeeRecords(buffer);\n    std::cout << buffer;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\n\nstruct Employee {\n    char name[100];\n    int id;\n};\n\n\nvoid processEmployeeRecords(char* buffer) {\n    const size_t bufferSize = strlen(buffer);\n    Employee employees[100];\n    int numEmployees = 0;\n\n\n    char* token = strtok(buffer, \"\\n\");\n    while (token != nullptr && numEmployees < 100) {\n        char* nameEnd = strchr(token, ',');\n        if (nameEnd != nullptr) {\n            size_t nameLength = nameEnd - token;\n            strncpy(employees[numEmployees].name, token, nameLength);\n            employees[numEmployees].name[nameLength] = '\\0';\n            employees[numEmployees].id = std::stoi(nameEnd + 1);\n            ++numEmployees;\n        }\n        token = strtok(nullptr, \"\\n\");\n    }\n\n\n    std::sort(employees, employees + numEmployees, [](const Employee& a, const Employee& b) {\n        return a.id > b.id;\n    });\n\n\n    char* writePtr = buffer;\n    for (int i = 0; i < numEmployees; ++i) {\n<diff>        writePtr += sprintf(writePtr, \"%s,%d\\n\", employees[i].name, employees[i].id);</diff>\n    }\n}\n\n\nint main() {\n    char buffer[] = \"Alice,102\\nBob,101\\nCharlie,103\\n\";\n    processEmployeeRecords(buffer);\n    std::cout << buffer;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates a configuration summary from an array of objects. The function should take an array of class instances (of any class type using templates), a string representing the attribute name to extract, and a pre-allocated character buffer for the output. The function must efficiently construct a comma-separated string in the provided buffer containing all values of the specified attribute from each object. For example, given Person objects with 'name' attributes, it should produce output like \"Alice,Bob,Charlie\" in the buffer. The function should return the number of characters written.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\ntemplate<typename T, typename Extractor>\nsize_t generateConfigSummary(const T* objects, size_t count, Extractor extractor, char* buffer, size_t bufferSize) {\n    if (bufferSize == 0 || count == 0) {\n        buffer[0] = '\\0';\n        return 0;\n    }\n\n    size_t totalWritten = 0;\n    bool first = true;\n\n    for (size_t i = 0; i < count; ++i) {\n        const auto& value = extractor(objects[i]);\n        size_t valueLength = std::strlen(value);\n\n\n        if (totalWritten + valueLength >= bufferSize - 1) {\n            break;\n        }\n\n        if (!first) {\n            buffer[totalWritten++] = ',';\n        }\n<diff>        std::strncpy(buffer + totalWritten, value, bufferSize - totalWritten - 1);</diff>\n        totalWritten += valueLength;\n        first = false;\n    }\n\n    buffer[totalWritten] = '\\0';\n    return totalWritten;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\ntemplate<typename T, typename Extractor>\nsize_t generateConfigSummary(const T* objects, size_t count, Extractor extractor, char* buffer, size_t bufferSize) {\n    if (bufferSize == 0 || count == 0) {\n        buffer[0] = '\\0';\n        return 0;\n    }\n\n    size_t totalWritten = 0;\n    bool first = true;\n\n    for (size_t i = 0; i < count; ++i) {\n        const auto& value = extractor(objects[i]);\n        size_t valueLength = std::strlen(value);\n\n\n        if (totalWritten + valueLength >= bufferSize - 1) {\n            break;\n        }\n\n        if (!first) {\n            buffer[totalWritten++] = ',';\n        }\n<diff>        std::strcpy(buffer + totalWritten, value);</diff>\n        totalWritten += valueLength;\n        first = false;\n    }\n\n    buffer[totalWritten] = '\\0';\n    return totalWritten;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `check_palindrome` that takes a string input and determines if it is a palindrome. The function should return a formatted string indicating the result, using a fixed-size character buffer of 256 bytes. For efficiency, construct the output string in-place in this buffer by first copying the input string and then appending the appropriate palindrome status message. The output should follow exactly these formats:\n\n\"<input> is a palindrome\" if true\n\"<input> is not a palindrome\" if false\n\nYour code should pass the following test:\nassert(strcmp(check_palindrome(\"racecar\"), \"racecar is a palindrome\") == 0);", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst char* check_palindrome(const char* input) {\n    static char result[256];\n\n\n<diff>    strncpy(result, input, sizeof(result) - 1);\n    result[sizeof(result) - 1] = '\\0';\n\n\n    size_t len = strlen(input);\n\n\n    bool is_palindrome = true;\n    for (size_t i = 0; i < len / 2; ++i) {\n        if (tolower(input[i]) != tolower(input[len - i - 1])) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n\n    snprintf(result + len, sizeof(result) - len, \" is %s\", is_palindrome ? \"a palindrome\" : \"not a palindrome\");</diff>\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst char* check_palindrome(const char* input) {\n    static char result[256];\n\n\n<diff>    strcpy(result, input);\n\n\n    size_t len = strlen(input);\n\n\n    bool is_palindrome = true;\n    for (size_t i = 0; i < len / 2; ++i) {\n        if (tolower(input[i]) != tolower(input[len - i - 1])) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n\n    if (is_palindrome) {\n        sprintf(result + len, \" is a palindrome\");\n    } else {\n        sprintf(result + len, \" is not a palindrome\");\n    }</diff>\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that flattens a nested map structure into a single-level map where keys are concatenated with dots (.) representing hierarchy. The function should take a nested map<string, variant<int, map<string, variant<int, map<...>>>>> structure and return a flat map<string, string>.\n\nFor efficiency, each new key must be constructed in-place in a fixed-size character buffer of 256 bytes by concatenating parent keys with dots. The string values should be the string representations of the leaf integers. For example, given input {\"key1\": 1, \"key2\": {\"key1\": 2, \"key2\": 4}, \"key3\": {\"key1\": 3, \"key2\": 5}}, the output should be {\"key1\": \"1\", \"key2.key1\": \"2\", \"key2.key2\": \"4\", \"key3.key1\": \"3\", \"key3.key2\": \"5\"}.\n\nThe implementation should avoid dynamic memory allocation for key construction and work directly with character buffers for maximum performance.", "chosen": "```cpp\n#include <map>\n#include <variant>\n#include <string>\n#include <cstdio>\n\n<diff>using NestedMap = std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>>>>>>>>>>;\n\nvoid flattenMap(const NestedMap& nestedMap, std::map<std::string, std::string>& flatMap, char* buffer, size_t bufferLength) {\n    for (const auto& [key, value] : nestedMap) {\n        size_t newLength = bufferLength + key.length();\n        if (newLength >= 256) {\n\n            continue;\n        }\n\n\n        std::strncpy(buffer + bufferLength, key.c_str(), 256 - bufferLength);\n        buffer[newLength] = '\\0';</diff>\n\n\n        if (std::holds_alternative<int>(value)) {\n\n            char valueStr[32];\n            std::sprintf(valueStr, \"%d\", std::get<int>(value));\n            flatMap[std::string(buffer, newLength)] = valueStr;\n        } else {\n\n            buffer[newLength] = '.';\n            flattenMap(std::get<NestedMap>(value), flatMap, buffer, newLength + 1);\n        }\n    }\n}\n\nstd::map<std::string, std::string> flattenNestedMap(const NestedMap& nestedMap) {\n    std::map<std::string, std::string> flatMap;\n    char buffer[256];\n    flattenMap(nestedMap, flatMap, buffer, 0);\n    return flatMap;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <variant>\n#include <string>\n#include <cstdio>\n\n<diff>using NestedMap = std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>>>>>>>>>>;\n\nvoid flattenMap(const NestedMap& nestedMap, std::map<std::string, std::string>& flatMap, char* buffer, size_t bufferLength) {\n    for (const auto& [key, value] : nestedMap) {\n        size_t newLength = bufferLength + key.length();\n        if (newLength >= 256) {\n\n            continue;\n        }\n\n\n        std::strcpy(buffer + bufferLength, key.c_str());</diff>\n\n\n        if (std::holds_alternative<int>(value)) {\n\n            char valueStr[32];\n            std::sprintf(valueStr, \"%d\", std::get<int>(value));\n            flatMap[std::string(buffer, newLength)] = valueStr;\n        } else {\n\n            buffer[newLength] = '.';\n            flattenMap(std::get<NestedMap>(value), flatMap, buffer, newLength + 1);\n        }\n    }\n}\n\nstd::map<std::string, std::string> flattenNestedMap(const NestedMap& nestedMap) {\n    std::map<std::string, std::string> flatMap;\n    char buffer[256];\n    flattenMap(nestedMap, flatMap, buffer, 0);\n    return flatMap;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that finds the longest substring in a character array that does not contain any repeated characters. The function should modify the input buffer in-place to store the result and return a pointer to it. If there are multiple such substrings, return the one that starts first. If the input is empty, return an empty string. If there are no non-repeated substrings, return the first character.\n\nYou should use character array operations and avoid using C++ string classes for efficiency. The input buffer is guaranteed to be null-terminated and will not exceed 1000 characters.\n\nYour code should pass the following test cases:\n1. Input: \"bbbbb\"  Output: \"b\"\n2. Input: \"pwwkew\"  Output: \"wke\"\n3. Input: \"abcabcbb\"  Output: \"abc\"\n\nNote: The result must be stored in the original buffer and properly null-terminated.", "chosen": "```cpp\n#include <cstring>\n\n\nchar* longestUniqueSubstring(char* s) {\n    const int MAX_CHAR = 128;\n    int lastSeen[MAX_CHAR];\n    memset(lastSeen, -1, sizeof(lastSeen));\n\n    int maxLength = 0;\n    int start = 0;\n    int maxStart = 0;\n\n    for (int end = 0; s[end] != '\\0'; ++end) {\n        char currentChar = s[end];\n\n\n        if (lastSeen[currentChar] >= start) {\n            start = lastSeen[currentChar] + 1;\n        }\n\n\n        lastSeen[currentChar] = end;\n\n\n        if (end - start + 1 > maxLength) {\n            maxLength = end - start + 1;\n            maxStart = start;\n        }\n    }\n\n\n    char temp[maxLength + 1];\n    strncpy(temp, s + maxStart, maxLength);\n    temp[maxLength] = '\\0';\n\n\n<diff>    strncpy(s, temp, maxLength);\n    s[maxLength] = '\\0';</diff>\n\n    return s;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nchar* longestUniqueSubstring(char* s) {\n    const int MAX_CHAR = 128;\n    int lastSeen[MAX_CHAR];\n    memset(lastSeen, -1, sizeof(lastSeen));\n\n    int maxLength = 0;\n    int start = 0;\n    int maxStart = 0;\n\n    for (int end = 0; s[end] != '\\0'; ++end) {\n        char currentChar = s[end];\n\n\n        if (lastSeen[currentChar] >= start) {\n            start = lastSeen[currentChar] + 1;\n        }\n\n\n        lastSeen[currentChar] = end;\n\n\n        if (end - start + 1 > maxLength) {\n            maxLength = end - start + 1;\n            maxStart = start;\n        }\n    }\n\n\n    char temp[maxLength + 1];\n    strncpy(temp, s + maxStart, maxLength);\n    temp[maxLength] = '\\0';\n\n\n<diff>    strcpy(s, temp);</diff>\n\n    return s;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program to generate mock data containing N records, where each record has a unique ID and a tag. The tag should be a comma-separated string of words randomly selected from a given vocabulary list. For performance optimization, construct each tag string in-place within a single buffer without using intermediate string objects. The vocabulary list will be provided as a vector of strings, and the number of words per tag will vary between 1 and 10. Output each record as \"ID: [id], TAG: [tag]\" on separate lines.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <ctime>\n\nvoid generateMockData(size_t N, const std::vector<std::string>& vocabulary) {\n    std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\n    std::uniform_int_distribution<size_t> wordCountDist(1, 10);\n    std::uniform_int_distribution<size_t> wordIndexDist(0, vocabulary.size() - 1);\n\n    for (size_t id = 0; id < N; ++id) {\n        size_t wordCount = wordCountDist(rng);\n        size_t bufferSize = 0;\n\n\n        for (size_t i = 0; i < wordCount; ++i) {\n            bufferSize += vocabulary[wordIndexDist(rng)].size();\n        }\n        bufferSize += wordCount - 1;\n        bufferSize += 8 + std::to_string(id).size();\n\n<diff>        char* buffer = new char[bufferSize + 1];\n        char* ptr = buffer;\n\n\n        ptr += snprintf(ptr, bufferSize + 1, \"ID: %zu, TAG: \", id);\n\n\n        for (size_t i = 0; i < wordCount; ++i) {\n            const std::string& word = vocabulary[wordIndexDist(rng)];\n            size_t remainingSpace = bufferSize - (ptr - buffer);\n            ptr += snprintf(ptr, remainingSpace, \"%s\", word.c_str());\n            if (i != wordCount - 1) {\n                *ptr++ = ',';\n            }\n        }\n\n\n        *ptr = '\\0';</diff>\n\n\n        std::cout << buffer << std::endl;\n\n\n        delete[] buffer;\n    }\n}\n\nint main() {\n    std::vector<std::string> vocabulary = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\", \"kiwi\", \"lemon\"};\n    size_t N = 5;\n\n    generateMockData(N, vocabulary);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <ctime>\n\nvoid generateMockData(size_t N, const std::vector<std::string>& vocabulary) {\n    std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\n    std::uniform_int_distribution<size_t> wordCountDist(1, 10);\n    std::uniform_int_distribution<size_t> wordIndexDist(0, vocabulary.size() - 1);\n\n    for (size_t id = 0; id < N; ++id) {\n        size_t wordCount = wordCountDist(rng);\n        size_t bufferSize = 0;\n\n\n        for (size_t i = 0; i < wordCount; ++i) {\n            bufferSize += vocabulary[wordIndexDist(rng)].size();\n        }\n        bufferSize += wordCount - 1;\n        bufferSize += 8 + std::to_string(id).size();\n\n<diff>        char* buffer = new char[bufferSize];\n        char* ptr = buffer;\n\n\n        ptr += sprintf(ptr, \"ID: %zu, TAG: \", id);\n\n\n        for (size_t i = 0; i < wordCount; ++i) {\n            const std::string& word = vocabulary[wordIndexDist(rng)];\n            ptr += sprintf(ptr, \"%s\", word.c_str());\n            if (i != wordCount - 1) {\n                *ptr++ = ',';\n            }\n        }</diff>\n\n\n        std::cout << buffer << std::endl;\n\n\n        delete[] buffer;\n    }\n}\n\nint main() {\n    std::vector<std::string> vocabulary = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\", \"kiwi\", \"lemon\"};\n    size_t N = 5;\n\n    generateMockData(N, vocabulary);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function `joinWordsWithSpaces` that takes a vector of strings (words) and returns a combined string with all words separated by spaces. If the vector is empty, return an empty string. For performance reasons, you must:\n1. Use a fixed-size character buffer of 1024 bytes for building the result\n2. Manually copy each word and space separator into the buffer using string operations\n3. Return the final string from the buffer\n\nYour code should pass these assertions:\nassert(joinWordsWithSpaces({\"Hello\", \"world\", \"C++\"}) == \"Hello world C++\");\nassert(joinWordsWithSpaces({}) == \"\");\nassert(joinWordsWithSpaces({\"Hello\", \"world\"}) == \"Hello world\");", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::string joinWordsWithSpaces(const std::vector<std::string>& words) {\n    char buffer[1024] = {0};\n    size_t bufferSize = sizeof(buffer);\n    size_t currentPos = 0;\n\n    for (size_t i = 0; i < words.size(); ++i) {\n        const char* word = words[i].c_str();\n        size_t wordLength = std::strlen(word);\n\n\n        if (currentPos + wordLength + (i > 0 ? 1 : 0) >= bufferSize) {\n            break;\n        }\n\n\n        if (i > 0) {\n            buffer[currentPos++] = ' ';\n        }\n\n\n<diff>        std::strncpy(buffer + currentPos, word, bufferSize - currentPos - 1);</diff>\n        currentPos += wordLength;\n    }\n\n    return std::string(buffer);\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::string joinWordsWithSpaces(const std::vector<std::string>& words) {\n    char buffer[1024] = {0};\n    size_t bufferSize = sizeof(buffer);\n    size_t currentPos = 0;\n\n    for (size_t i = 0; i < words.size(); ++i) {\n        const char* word = words[i].c_str();\n        size_t wordLength = std::strlen(word);\n\n\n        if (currentPos + wordLength + (i > 0 ? 1 : 0) >= bufferSize) {\n            break;\n        }\n\n\n        if (i > 0) {\n            buffer[currentPos++] = ' ';\n        }\n\n\n<diff>        std::strcpy(buffer + currentPos, word);</diff>\n        currentPos += wordLength;\n    }\n\n    return std::string(buffer);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `format_student_results` that processes a student's scores and formats the results. The function should take:\n1. A map<string, int> containing subject-score pairs\n2. A character buffer of fixed size 256 bytes for the output\n\nThe function should:\n1. Sort the scores in ascending order and format them into the buffer as comma-separated \"subject:score\" pairs\n2. Append \"\\nPass: true\" or \"\\nPass: false\" based on whether any score is >= 60\n3. Return true if formatting succeeded (all data fit in buffer), false otherwise\n\nNote: For efficiency, you must build the output string directly in the provided buffer without using intermediate strings. The buffer must contain exactly the formatted output with no extra characters.", "chosen": "```cpp\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nbool format_student_results(const std::map<std::string, int>& scores, char* buffer) {\n\n    std::vector<std::pair<int, std::string>> score_subject_pairs;\n    for (const auto& entry : scores) {\n        score_subject_pairs.emplace_back(entry.second, entry.first);\n    }\n\n\n    std::sort(score_subject_pairs.begin(), score_subject_pairs.end());\n\n\n    size_t buffer_pos = 0;\n    bool pass = false;\n\n    for (size_t i = 0; i < score_subject_pairs.size(); ++i) {\n        const int score = score_subject_pairs[i].first;\n        const std::string& subject = score_subject_pairs[i].second;\n\n\n        if (score >= 60) {\n            pass = true;\n        }\n\n\n        size_t entry_length = subject.length() + 6;\n        if (i == score_subject_pairs.size() - 1) {\n            entry_length -= 1;\n        }\n\n\n        if (buffer_pos + entry_length >= 256) {\n            return false;\n        }\n\n\n        buffer_pos += std::sprintf(buffer + buffer_pos, \"%s:%d\", subject.c_str(), score);\n        if (i != score_subject_pairs.size() - 1) {\n            buffer[buffer_pos++] = ',';\n        }\n    }\n\n\n    const char* pass_status = pass ? \"\\nPass: true\" : \"\\nPass: false\";\n    size_t pass_length = strlen(pass_status);\n\n    if (buffer_pos + pass_length >= 256) {\n        return false;\n    }\n\n<diff>    std::strncpy(buffer + buffer_pos, pass_status, 256 - buffer_pos - 1);\n    buffer_pos += pass_length;\n    buffer[buffer_pos] = '\\0';</diff>\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nbool format_student_results(const std::map<std::string, int>& scores, char* buffer) {\n\n    std::vector<std::pair<int, std::string>> score_subject_pairs;\n    for (const auto& entry : scores) {\n        score_subject_pairs.emplace_back(entry.second, entry.first);\n    }\n\n\n    std::sort(score_subject_pairs.begin(), score_subject_pairs.end());\n\n\n    size_t buffer_pos = 0;\n    bool pass = false;\n\n    for (size_t i = 0; i < score_subject_pairs.size(); ++i) {\n        const int score = score_subject_pairs[i].first;\n        const std::string& subject = score_subject_pairs[i].second;\n\n\n        if (score >= 60) {\n            pass = true;\n        }\n\n\n        size_t entry_length = subject.length() + 6;\n        if (i == score_subject_pairs.size() - 1) {\n            entry_length -= 1;\n        }\n\n\n        if (buffer_pos + entry_length >= 256) {\n            return false;\n        }\n\n\n        buffer_pos += std::sprintf(buffer + buffer_pos, \"%s:%d\", subject.c_str(), score);\n        if (i != score_subject_pairs.size() - 1) {\n            buffer[buffer_pos++] = ',';\n        }\n    }\n\n\n    const char* pass_status = pass ? \"\\nPass: true\" : \"\\nPass: false\";\n    size_t pass_length = strlen(pass_status);\n\n    if (buffer_pos + pass_length >= 256) {\n        return false;\n    }\n\n<diff>    std::strcpy(buffer + buffer_pos, pass_status);</diff>\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of WiFi fingerprint structures and extracts position information. Each fingerprint contains a `pos_id` (int) and a `position` (char array of fixed size 64). The function should:\n1. Find the first fingerprint where `pos_id` >= 0\n2. Copy its position string into a provided output buffer (also size 64)\n3. Return true if found, false otherwise\n\nRequirements:\n- The position string must be copied directly into the output buffer without length checking\n- The function must not perform any dynamic memory allocation\n- If no valid fingerprint is found, leave the output buffer unchanged\n\nExample fingerprint structure:\nstruct Fingerprint {\n    int pos_id;\n    char position[64];\n};\n\nbool get_first_valid_position(Fingerprint* fingerprints, int count, char* output_position);", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nstruct Fingerprint {\n    int pos_id;\n    char position[64];\n};\n\nbool get_first_valid_position(Fingerprint* fingerprints, int count, char* output_position) {\n    for (int i = 0; i < count; ++i) {\n        if (fingerprints[i].pos_id >= 0) {\n            std::strncpy(output_position, fingerprints[i].position, sizeof(fingerprints[i].position) - 1);\n            output_position[sizeof(fingerprints[i].position) - 1] = '\\0';</diff>\n            return true;\n        }\n    }\n\n    return false;\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nstruct Fingerprint {\n    int pos_id;\n    char position[64];\n};\n\nbool get_first_valid_position(Fingerprint* fingerprints, int count, char* output_position) {\n    for (int i = 0; i < count; ++i) {\n        if (fingerprints[i].pos_id >= 0) {\n            std::strcpy(output_position, fingerprints[i].position);</diff>\n            return true;\n        }\n    }\n\n    return false;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `my_bool` that takes an input value (which can be an integer, boolean, or C-style string) and returns a boolean value that is equal to the input value if converted to a boolean. For string inputs, the function must first copy the input string into a fixed 64-byte buffer before processing. The function should handle the following cases:\n1. Integer 0 returns false\n2. String \"False\" returns true (since any non-empty string is true)\n3. String \"True\" returns true\n4. Boolean true returns true\n\nYour code should pass the following assertions:\nassert(my_bool(0) == false);\nassert(my_bool(\"False\") == true);\nassert(my_bool(\"True\") == true);\nassert(my_bool(true) == true);", "chosen": "```cpp\n#include <cassert>\n#include <cstring>\n#include <cstdbool>\n\n\nbool my_bool(int value) {\n    return value != 0;\n}\n\n\nbool my_bool(bool value) {\n    return value;\n}\n\n\nbool my_bool(const char* str) {\n    char buffer[64];\n<diff>    std::strncpy(buffer, str, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n\n\n    if (std::strcmp(buffer, \"False\") == 0) {\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n\n    assert(my_bool(0) == false);\n    assert(my_bool(\"False\") == false);</diff>\n    assert(my_bool(\"True\") == true);\n    assert(my_bool(true) == true);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cassert>\n#include <cstring>\n#include <cstdbool>\n\n\nbool my_bool(int value) {\n    return value != 0;\n}\n\n\nbool my_bool(bool value) {\n    return value;\n}\n\n\nbool my_bool(const char* str) {\n    char buffer[64];\n<diff>    std::strcpy(buffer, str);\n\n\n    if (std::strcmp(buffer, \"False\") == 0) {\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n\n    assert(my_bool(0) == false);\n    assert(my_bool(\"False\") == true);</diff>\n    assert(my_bool(\"True\") == true);\n    assert(my_bool(true) == true);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that constructs a Khoros Extension function URI from given parameters. The function should take a function name (case-insensitive) and a map of parameters, and write the result into a fixed 256-byte character buffer provided by the caller. The URI must follow this format: `khoros-ext://[function_name]?[param1=value1&param2=value2...]`. You must manually encode the parameters by replacing spaces with '+' and escaping special characters with percent-encoding. The function should return the number of bytes written to the buffer. For efficiency, construct the URI directly in the output buffer without using intermediate strings.", "chosen": "```cpp\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\n\nint khorosExtUri(const std::string& functionName, const std::map<std::string, std::string>& params, char* buffer, size_t bufferSize) {\n    if (bufferSize < 1) {\n        return 0;\n    }\n\n    buffer[0] = '\\0';\n    size_t pos = 0;\n\n\n    const char* prefix = \"khoros-ext:\n    size_t prefixLength = strlen(prefix);\n    if (pos + prefixLength >= bufferSize) {\n        return 0;\n    }\n<diff>    strncpy(buffer + pos, prefix, bufferSize - pos);</diff>\n    pos += prefixLength;\n\n\n    for (char c : functionName) {\n        if (pos + 1 >= bufferSize) {\n            return 0;\n        }\n        buffer[pos++] = std::tolower(c);\n    }\n\n\n    if (!params.empty()) {\n        if (pos + 1 >= bufferSize) {\n            return 0;\n        }\n        buffer[pos++] = '?';\n\n\n        for (auto it = params.begin(); it != params.end(); ++it) {\n            const std::string& key = it->first;\n            const std::string& value = it->second;\n\n\n            for (char c : key) {\n                if (pos + 3 >= bufferSize) {\n                    return 0;\n                }\n                if (std::isalnum(c)) {\n                    buffer[pos++] = c;\n                } else if (c == ' ') {\n                    buffer[pos++] = '+';\n                } else {\n                    sprintf(buffer + pos, \"%%%02X\", static_cast<unsigned char>(c));\n                    pos += 3;\n                }\n            }\n\n\n            if (pos + 1 >= bufferSize) {\n                return 0;\n            }\n            buffer[pos++] = '=';\n\n\n            for (char c : value) {\n                if (pos + 3 >= bufferSize) {\n                    return 0;\n                }\n                if (std::isalnum(c)) {\n                    buffer[pos++] = c;\n                } else if (c == ' ') {\n                    buffer[pos++] = '+';\n                } else {\n                    sprintf(buffer + pos, \"%%%02X\", static_cast<unsigned char>(c));\n                    pos += 3;\n                }\n            }\n\n\n            if (std::next(it) != params.end()) {\n                if (pos + 1 >= bufferSize) {\n                    return 0;\n                }\n                buffer[pos++] = '&';\n            }\n        }\n    }\n\n\n    if (pos >= bufferSize) {\n        return 0;\n    }\n    buffer[pos] = '\\0';\n\n    return pos;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\n\nint khorosExtUri(const std::string& functionName, const std::map<std::string, std::string>& params, char* buffer, size_t bufferSize) {\n    if (bufferSize < 1) {\n        return 0;\n    }\n\n    buffer[0] = '\\0';\n    size_t pos = 0;\n\n\n    const char* prefix = \"khoros-ext:\n    size_t prefixLength = strlen(prefix);\n    if (pos + prefixLength >= bufferSize) {\n        return 0;\n    }\n<diff>    strcpy(buffer + pos, prefix);</diff>\n    pos += prefixLength;\n\n\n    for (char c : functionName) {\n        if (pos + 1 >= bufferSize) {\n            return 0;\n        }\n        buffer[pos++] = std::tolower(c);\n    }\n\n\n    if (!params.empty()) {\n        if (pos + 1 >= bufferSize) {\n            return 0;\n        }\n        buffer[pos++] = '?';\n\n\n        for (auto it = params.begin(); it != params.end(); ++it) {\n            const std::string& key = it->first;\n            const std::string& value = it->second;\n\n\n            for (char c : key) {\n                if (pos + 3 >= bufferSize) {\n                    return 0;\n                }\n                if (std::isalnum(c)) {\n                    buffer[pos++] = c;\n                } else if (c == ' ') {\n                    buffer[pos++] = '+';\n                } else {\n                    sprintf(buffer + pos, \"%%%02X\", static_cast<unsigned char>(c));\n                    pos += 3;\n                }\n            }\n\n\n            if (pos + 1 >= bufferSize) {\n                return 0;\n            }\n            buffer[pos++] = '=';\n\n\n            for (char c : value) {\n                if (pos + 3 >= bufferSize) {\n                    return 0;\n                }\n                if (std::isalnum(c)) {\n                    buffer[pos++] = c;\n                } else if (c == ' ') {\n                    buffer[pos++] = '+';\n                } else {\n                    sprintf(buffer + pos, \"%%%02X\", static_cast<unsigned char>(c));\n                    pos += 3;\n                }\n            }\n\n\n            if (std::next(it) != params.end()) {\n                if (pos + 1 >= bufferSize) {\n                    return 0;\n                }\n                buffer[pos++] = '&';\n            }\n        }\n    }\n\n\n    if (pos >= bufferSize) {\n        return 0;\n    }\n    buffer[pos] = '\\0';\n\n    return pos;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `validateBoundary` that validates whether a shape's coordinates are within given boundary limits. The function should:\n\n1. Take three parameters:\n   - `shapeData`: A fixed-size character buffer (256 bytes) containing shape information in the format \"TYPE,X,Y,WIDTH,HEIGHT\" (for rectangles) or \"TYPE,X,Y,RADIUS\" (for circles)\n   - `boundaryData`: A fixed-size character buffer (256 bytes) containing boundary information in the format \"TYPE,X,Y,WIDTH,HEIGHT\"\n   - `output`: A fixed-size character buffer (256 bytes) where the result will be written as either \"VALID\" or \"INVALID\"\n\n2. Parse the shape and boundary information from the input buffers\n3. Determine if the shape is completely contained within the boundary\n4. Write the result to the output buffer\n5. Return true if parsing was successful, false if there were any errors\n\nFor efficiency, all parsing and validation must be done in-place without allocating additional memory. The function should handle cases where shape dimensions exactly match boundary dimensions. Note that the input buffers may contain strings longer than the actual data (up to 256 bytes).", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nbool validateBoundary(char* shapeData, char* boundaryData, char* output) {\n\n    bool parseInt(const char*& str, int& value) {\n        char* endptr;\n        value = std::strtol(str, &endptr, 10);\n        if (endptr == str) return false;\n        str = endptr;\n        return true;\n    }\n\n\n    void skipComma(const char*& str) {\n        if (*str == ',') ++str;\n    }\n\n\n    const char* bPtr = boundaryData;\n    int bType, bX, bY, bWidth, bHeight;\n\n    if (!parseInt(bPtr, bType)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bX)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bY)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bWidth)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bHeight)) return false;\n\n\n    const char* sPtr = shapeData;\n    int sType, sX, sY, sWidth, sHeight, sRadius;\n\n    if (!parseInt(sPtr, sType)) return false;\n    skipComma(sPtr);\n\n    if (!parseInt(sPtr, sX)) return false;\n    skipComma(sPtr);\n\n    if (!parseInt(sPtr, sY)) return false;\n    skipComma(sPtr);\n\n    if (sType == 0) {\n        if (!parseInt(sPtr, sWidth)) return false;\n        skipComma(sPtr);\n\n        if (!parseInt(sPtr, sHeight)) return false;\n    } else if (sType == 1) {\n        if (!parseInt(sPtr, sRadius)) return false;\n    } else {\n        return false;\n    }\n\n\n    bool isValid = false;\n    if (sType == 0) {\n        isValid = (sX >= bX) && (sX + sWidth <= bX + bWidth) &&\n                  (sY >= bY) && (sY + sHeight <= bY + bHeight);\n    } else if (sType == 1) {\n\n        double centerX = sX + sRadius;\n        double centerY = sY + sRadius;\n        double distanceFromBoundaryLeft = centerX - bX;\n        double distanceFromBoundaryRight = (bX + bWidth) - centerX;\n        double distanceFromBoundaryTop = centerY - bY;\n        double distanceFromBoundaryBottom = (bY + bHeight) - centerY;\n\n        isValid = (distanceFromBoundaryLeft >= sRadius) &&\n                  (distanceFromBoundaryRight >= sRadius) &&\n                  (distanceFromBoundaryTop >= sRadius) &&\n                  (distanceFromBoundaryBottom >= sRadius);\n    }\n\n\n<diff>    std::strncpy(output, isValid ? \"VALID\" : \"INVALID\", 6);\n    output[5] = '\\0';</diff>\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nbool validateBoundary(char* shapeData, char* boundaryData, char* output) {\n\n    bool parseInt(const char*& str, int& value) {\n        char* endptr;\n        value = std::strtol(str, &endptr, 10);\n        if (endptr == str) return false;\n        str = endptr;\n        return true;\n    }\n\n\n    void skipComma(const char*& str) {\n        if (*str == ',') ++str;\n    }\n\n\n    const char* bPtr = boundaryData;\n    int bType, bX, bY, bWidth, bHeight;\n\n    if (!parseInt(bPtr, bType)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bX)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bY)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bWidth)) return false;\n    skipComma(bPtr);\n\n    if (!parseInt(bPtr, bHeight)) return false;\n\n\n    const char* sPtr = shapeData;\n    int sType, sX, sY, sWidth, sHeight, sRadius;\n\n    if (!parseInt(sPtr, sType)) return false;\n    skipComma(sPtr);\n\n    if (!parseInt(sPtr, sX)) return false;\n    skipComma(sPtr);\n\n    if (!parseInt(sPtr, sY)) return false;\n    skipComma(sPtr);\n\n    if (sType == 0) {\n        if (!parseInt(sPtr, sWidth)) return false;\n        skipComma(sPtr);\n\n        if (!parseInt(sPtr, sHeight)) return false;\n    } else if (sType == 1) {\n        if (!parseInt(sPtr, sRadius)) return false;\n    } else {\n        return false;\n    }\n\n\n    bool isValid = false;\n    if (sType == 0) {\n        isValid = (sX >= bX) && (sX + sWidth <= bX + bWidth) &&\n                  (sY >= bY) && (sY + sHeight <= bY + bHeight);\n    } else if (sType == 1) {\n\n        double centerX = sX + sRadius;\n        double centerY = sY + sRadius;\n        double distanceFromBoundaryLeft = centerX - bX;\n        double distanceFromBoundaryRight = (bX + bWidth) - centerX;\n        double distanceFromBoundaryTop = centerY - bY;\n        double distanceFromBoundaryBottom = (bY + bHeight) - centerY;\n\n        isValid = (distanceFromBoundaryLeft >= sRadius) &&\n                  (distanceFromBoundaryRight >= sRadius) &&\n                  (distanceFromBoundaryTop >= sRadius) &&\n                  (distanceFromBoundaryBottom >= sRadius);\n    }\n\n\n<diff>    std::strcpy(output, isValid ? \"VALID\" : \"INVALID\");</diff>\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that uses SQLite to manage employee records. Implement two functions:\n\n1. `create_employee_table`: Takes a sqlite3* connection and creates a table named \"employees\" with columns: id (integer primary key), name (text), age (integer), and department (text). The SQL statement must be constructed in a fixed 256-byte character buffer.\n\n2. `insert_employee`: Takes a sqlite3* connection and employee data as separate parameters (int id, const char* name, int age, const char* department). Construct the INSERT statement in a fixed 256-byte buffer by concatenating the parameters directly into the SQL string. The function should execute the resulting SQL statement.\n\nFor both functions, you must use character arrays (not std::string) and manually construct the SQL strings using functions like strcpy and strcat. The program should not perform any bounds checking on the string operations.", "chosen": "```cpp\n#include <sqlite3.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nvoid create_employee_table(sqlite3* db) {\n<diff>    const char* sql = \"CREATE TABLE IF NOT EXISTS employees (id INTEGER PRIMARY KEY, name TEXT, age INTEGER, department TEXT);\";\n\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"SQL error: %s\\n\", errMsg);\n        sqlite3_free(errMsg);\n    }\n}\n\n\nvoid insert_employee(sqlite3* db, int id, const char* name, int age, const char* department) {\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"INSERT INTO employees (id, name, age, department) VALUES (%d, '%q', %d, '%q');\", id, name, age, department);</diff>\n\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"SQL error: %s\\n\", errMsg);\n        sqlite3_free(errMsg);\n    }\n}\n\nint main() {\n    sqlite3* db;\n    int rc = sqlite3_open(\"employee.db\", &db);\n    if (rc) {\n        fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n        return 1;\n    } else {\n        fprintf(stdout, \"Opened database successfully\\n\");\n    }\n\n\n    create_employee_table(db);\n\n\n    insert_employee(db, 1, \"John Doe\", 30, \"HR\");\n    insert_employee(db, 2, \"Jane Smith\", 25, \"Engineering\");\n    insert_employee(db, 3, \"Alice Johnson\", 40, \"Marketing\");\n\n    sqlite3_close(db);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <sqlite3.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nvoid create_employee_table(sqlite3* db) {\n<diff>    char sql[256];\n    strcpy(sql, \"CREATE TABLE IF NOT EXISTS employees (\");\n    strcat(sql, \"id INTEGER PRIMARY KEY,\");\n    strcat(sql, \"name TEXT,\");\n    strcat(sql, \"age INTEGER,\");\n    strcat(sql, \"department TEXT);\");\n\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"SQL error: %s\\n\", errMsg);\n        sqlite3_free(errMsg);\n    }\n}\n\n\nvoid insert_employee(sqlite3* db, int id, const char* name, int age, const char* department) {\n    char sql[256];\n    sprintf(sql, \"INSERT INTO employees (id, name, age, department) VALUES (%d, '%s', %d, '%s');\", id, name, age, department);</diff>\n\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"SQL error: %s\\n\", errMsg);\n        sqlite3_free(errMsg);\n    }\n}\n\nint main() {\n    sqlite3* db;\n    int rc = sqlite3_open(\"employee.db\", &db);\n    if (rc) {\n        fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n        return 1;\n    } else {\n        fprintf(stdout, \"Opened database successfully\\n\");\n    }\n\n\n    create_employee_table(db);\n\n\n    insert_employee(db, 1, \"John Doe\", 30, \"HR\");\n    insert_employee(db, 2, \"Jane Smith\", 25, \"Engineering\");\n    insert_employee(db, 3, \"Alice Johnson\", 40, \"Marketing\");\n\n    sqlite3_close(db);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `get_map_val` that takes a `std::map<const char*, int>` and a variable number of C-style string keys (null-terminated char arrays). The function should:\n1. Concatenate all provided keys into a single buffer (separated by null bytes) for preprocessing\n2. Return the value associated with the last key in the map\n3. Return -1 if the key isn't found\n4. Handle the case where no keys are provided by returning -1\n\nAssume the concatenated keys buffer will never exceed 256 bytes. The function should work efficiently by processing keys in a single pass through the arguments.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <cstdarg>\n#include <cstring>\n\nint get_map_val(std::map<const char*, int>& m, ...) {\n    const int MAX_BUFFER_SIZE = 256;\n    char buffer[MAX_BUFFER_SIZE] = {0};\n    int buffer_pos = 0;\n    va_list args;\n    va_start(args, m);\n\n    const char* last_key = nullptr;\n\n\n    while (true) {\n        const char* key = va_arg(args, const char*);\n        if (key == nullptr) {\n            break;\n        }\n\n\n        last_key = key;\n\n\n        int key_length = std::strlen(key);\n\n\n<diff>        if (buffer_pos + key_length + 1 >= MAX_BUFFER_SIZE) {\n            va_end(args);\n            return -1;\n        }\n\n\n        std::strncpy(buffer + buffer_pos, key, key_length);\n        buffer[buffer_pos + key_length] = '\\0';</diff>\n        buffer_pos += key_length + 1;\n    }\n\n    va_end(args);\n\n\n    if (last_key == nullptr) {\n        return -1;\n    }\n\n\n    auto it = m.find(last_key);\n    if (it != m.end()) {\n        return it->second;\n    } else {\n        return -1;\n    }\n}\n\n\nint main() {\n    std::map<const char*, int> m = {\n        {\"first\", 1},\n        {\"second\", 2},\n        {\"third\", 3}\n    };\n\n    int result = get_map_val(m, \"first\", \"second\", \"third\", nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    result = get_map_val(m, \"first\", \"fourth\", nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    result = get_map_val(m, nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <cstdarg>\n#include <cstring>\n\nint get_map_val(std::map<const char*, int>& m, ...) {\n    const int MAX_BUFFER_SIZE = 256;\n    char buffer[MAX_BUFFER_SIZE] = {0};\n    int buffer_pos = 0;\n    va_list args;\n    va_start(args, m);\n\n    const char* last_key = nullptr;\n\n\n    while (true) {\n        const char* key = va_arg(args, const char*);\n        if (key == nullptr) {\n            break;\n        }\n\n\n        last_key = key;\n\n\n        int key_length = std::strlen(key);\n\n\n<diff>        if (buffer_pos + key_length >= MAX_BUFFER_SIZE) {\n            va_end(args);\n            return -1;\n        }\n\n\n        std::strcpy(buffer + buffer_pos, key);</diff>\n        buffer_pos += key_length + 1;\n    }\n\n    va_end(args);\n\n\n    if (last_key == nullptr) {\n        return -1;\n    }\n\n\n    auto it = m.find(last_key);\n    if (it != m.end()) {\n        return it->second;\n    } else {\n        return -1;\n    }\n}\n\n\nint main() {\n    std::map<const char*, int> m = {\n        {\"first\", 1},\n        {\"second\", 2},\n        {\"third\", 3}\n    };\n\n    int result = get_map_val(m, \"first\", \"second\", \"third\", nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    result = get_map_val(m, \"first\", \"fourth\", nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    result = get_map_val(m, nullptr);\n    std::cout << \"Result: \" << result << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that parses a string representation of a simple JSON object (containing only string key-value pairs) into a map<string, string>. The function should read the input string into a fixed-size buffer of 256 bytes before parsing. If the input is not valid JSON or exceeds the buffer size, return an empty map. The parsing must be done by manually processing the buffer character-by-character without using any JSON parsing libraries.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n<diff>#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\nmap<string, string> parseSimpleJsonObject(const string& input) {\n    const int BUFFER_SIZE = 256;\n    char buffer[BUFFER_SIZE];\n\n\n    if (input.size() >= BUFFER_SIZE) {\n        return {};\n    }\n\n\n    strncpy(buffer, input.c_str(), BUFFER_SIZE - 1);\n    buffer[BUFFER_SIZE - 1] = '\\0';</diff>\n\n    map<string, string> result;\n    string key, value;\n    bool inKey = false, inValue = false;\n    int i = 0;\n\n\n    while (buffer[i] && isspace(buffer[i])) {\n        ++i;\n    }\n\n\n    if (buffer[i] != '{') {\n        return {};\n    }\n\n    ++i;\n\n    while (buffer[i]) {\n\n        while (buffer[i] && isspace(buffer[i])) {\n            ++i;\n        }\n\n\n        if (buffer[i] == '}') {\n            break;\n        }\n\n\n        if (!inKey && buffer[i] == '\"') {\n            inKey = true;\n            ++i;\n            while (buffer[i] && buffer[i] != '\"') {\n                key += buffer[i++];\n            }\n            ++i;\n\n\n            while (buffer[i] && isspace(buffer[i])) {\n                ++i;\n            }\n\n\n            if (buffer[i] != ':') {\n                return {};\n            }\n            ++i;\n\n\n            while (buffer[i] && isspace(buffer[i])) {\n                ++i;\n            }\n\n\n            if (!inValue && buffer[i] == '\"') {\n                inValue = true;\n                ++i;\n                while (buffer[i] && buffer[i] != '\"') {\n                    value += buffer[i++];\n                }\n                ++i;\n\n\n                result[key] = value;\n\n\n                key.clear();\n                value.clear();\n                inKey = false;\n                inValue = false;\n            } else {\n                return {};\n            }\n        } else {\n            return {};\n        }\n\n\n        while (buffer[i] && isspace(buffer[i])) {\n            ++i;\n        }\n\n\n        if (buffer[i] == ',') {\n            ++i;\n        } else if (buffer[i] != '}') {\n            return {};\n        }\n    }\n\n\n    while (buffer[i] && isspace(buffer[i])) {\n        ++i;\n    }\n\n\n    if (buffer[i] != '\\0' || buffer[i-1] != '}') {\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    string jsonInput = R\"({\"name\": \"John\", \"age\": \"30\"})\";\n    map<string, string> result = parseSimpleJsonObject(jsonInput);\n\n    for (const auto& pair : result) {\n        cout << pair.first << \": \" << pair.second << endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n<diff>\nusing namespace std;\n\nmap<string, string> parseSimpleJsonObject(const string& input) {\n    const int BUFFER_SIZE = 256;\n    char buffer[BUFFER_SIZE];\n\n\n    if (input.size() >= BUFFER_SIZE) {\n        return {};\n    }\n\n\n    strcpy(buffer, input.c_str());</diff>\n\n    map<string, string> result;\n    string key, value;\n    bool inKey = false, inValue = false;\n    int i = 0;\n\n\n    while (buffer[i] && isspace(buffer[i])) {\n        ++i;\n    }\n\n\n    if (buffer[i] != '{') {\n        return {};\n    }\n\n    ++i;\n\n    while (buffer[i]) {\n\n        while (buffer[i] && isspace(buffer[i])) {\n            ++i;\n        }\n\n\n        if (buffer[i] == '}') {\n            break;\n        }\n\n\n        if (!inKey && buffer[i] == '\"') {\n            inKey = true;\n            ++i;\n            while (buffer[i] && buffer[i] != '\"') {\n                key += buffer[i++];\n            }\n            ++i;\n\n\n            while (buffer[i] && isspace(buffer[i])) {\n                ++i;\n            }\n\n\n            if (buffer[i] != ':') {\n                return {};\n            }\n            ++i;\n\n\n            while (buffer[i] && isspace(buffer[i])) {\n                ++i;\n            }\n\n\n            if (!inValue && buffer[i] == '\"') {\n                inValue = true;\n                ++i;\n                while (buffer[i] && buffer[i] != '\"') {\n                    value += buffer[i++];\n                }\n                ++i;\n\n\n                result[key] = value;\n\n\n                key.clear();\n                value.clear();\n                inKey = false;\n                inValue = false;\n            } else {\n                return {};\n            }\n        } else {\n            return {};\n        }\n\n\n        while (buffer[i] && isspace(buffer[i])) {\n            ++i;\n        }\n\n\n        if (buffer[i] == ',') {\n            ++i;\n        } else if (buffer[i] != '}') {\n            return {};\n        }\n    }\n\n\n    while (buffer[i] && isspace(buffer[i])) {\n        ++i;\n    }\n\n\n    if (buffer[i] != '\\0' || buffer[i-1] != '}') {\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    string jsonInput = R\"({\"name\": \"John\", \"age\": \"30\"})\";\n    map<string, string> result = parseSimpleJsonObject(jsonInput);\n\n    for (const auto& pair : result) {\n        cout << pair.first << \": \" << pair.second << endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `processInput` that demonstrates different behavior based on input type. The function should accept either:\n1. A character pointer (null-terminated C-string)\n2. An array of character pointers (null-terminated C-strings) and its size\n\nFor a single C-string input, create and return a new array containing two copies of this string. For an array of C-strings, concatenate all strings and return the result as a single new string.\n\nYou must implement this using only C-style strings and manual memory management. The function should return dynamically allocated memory that the caller will be responsible for freeing.\n\nExample behavior:\nInput: \"Hello\" should produce output equivalent to [\"Hello\", \"Hello\"]\nInput: {\"Hello\", \"World\"} with size 2 should produce \"HelloWorld\"\n\nNote: You may assume all input strings are properly null-terminated, but you must handle memory allocation carefully.", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n\n\nchar* duplicateString(const char* str) {\n    size_t len = std::strlen(str);\n    char* newStr = static_cast<char*>(std::malloc(len + 1));\n    if (newStr != nullptr) {\n<diff>        std::memcpy(newStr, str, len + 1);</diff>\n    }\n    return newStr;\n}\n\n\nchar** processInput(const char* str) {\n\n    char** result = static_cast<char**>(std::malloc(2 * sizeof(char*)));\n    if (result != nullptr) {\n        result[0] = duplicateString(str);\n        result[1] = duplicateString(str);\n    }\n    return result;\n}\n\n\nchar* processInput(const char* strs[], size_t size) {\n\n    size_t totalLength = 0;\n    for (size_t i = 0; i < size; ++i) {\n        totalLength += std::strlen(strs[i]);\n    }\n\n\n    char* result = static_cast<char*>(std::malloc(totalLength + 1));\n    if (result != nullptr) {\n        result[0] = '\\0';\n        for (size_t i = 0; i < size; ++i) {\n            std::strcat(result, strs[i]);\n        }\n    }\n    return result;\n}\n\n\nvoid freeResult(char** result) {\n    if (result != nullptr) {\n        std::free(result[0]);\n        std::free(result[1]);\n        std::free(result);\n    }\n}\n\n\nvoid freeResult(char* result) {\n    if (result != nullptr) {\n        std::free(result);\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n\n\nchar* duplicateString(const char* str) {\n    size_t len = std::strlen(str);\n    char* newStr = static_cast<char*>(std::malloc(len + 1));\n    if (newStr != nullptr) {\n<diff>        std::strcpy(newStr, str);</diff>\n    }\n    return newStr;\n}\n\n\nchar** processInput(const char* str) {\n\n    char** result = static_cast<char**>(std::malloc(2 * sizeof(char*)));\n    if (result != nullptr) {\n        result[0] = duplicateString(str);\n        result[1] = duplicateString(str);\n    }\n    return result;\n}\n\n\nchar* processInput(const char* strs[], size_t size) {\n\n    size_t totalLength = 0;\n    for (size_t i = 0; i < size; ++i) {\n        totalLength += std::strlen(strs[i]);\n    }\n\n\n    char* result = static_cast<char*>(std::malloc(totalLength + 1));\n    if (result != nullptr) {\n        result[0] = '\\0';\n        for (size_t i = 0; i < size; ++i) {\n            std::strcat(result, strs[i]);\n        }\n    }\n    return result;\n}\n\n\nvoid freeResult(char** result) {\n    if (result != nullptr) {\n        std::free(result[0]);\n        std::free(result[1]);\n        std::free(result);\n    }\n}\n\n\nvoid freeResult(char* result) {\n    if (result != nullptr) {\n        std::free(result);\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `objects_to_arrays` that takes a vector of objects and converts them into an array of key-value pairs. Each object has exactly two properties: a string name (max 50 chars) and an integer value. For each object, store its properties in a fixed-size character buffer of 100 bytes formatted as \"name:value\". Then populate an output array with these formatted strings. The function should return the number of objects processed.\n\nFor example, given objects with properties (\"age\", 25) and (\"score\", 100), the output array should contain [\"age:25\", \"score:100\"] and return 2.\n\nNote: For efficiency, directly write the formatted strings into the output buffer without intermediate storage.", "chosen": "```cpp\n#include <vector>\n#include <cstdio>\n<diff>#include <cstring>\n\n\nstruct Object {\n    char name[51];\n    int value;\n};\n\n\nsize_t objects_to_arrays(const std::vector<Object>& objects, char output[][100]) {\n    size_t count = 0;\n    for (const auto& obj : objects) {\n\n        snprintf(output[count], 100, \"%s:%d\", obj.name, obj.value);</diff>\n        ++count;\n    }\n    return count;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <cstdio>\n<diff>\n\nstruct Object {\n    char name[51];\n    int value;\n};\n\n\nsize_t objects_to_arrays(const std::vector<Object>& objects, char output[][100]) {\n    size_t count = 0;\n    for (const auto& obj : objects) {\n\n        sprintf(output[count], \"%s:%d\", obj.name, obj.value);</diff>\n        ++count;\n    }\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `determine_pandas_offset` that takes a string representation of a frequency and stores the corresponding pandas offset alias in a provided fixed-size character buffer (256 bytes). The function should be case insensitive and return an empty string if the frequency is not supported. The function must use an if-else chain of conditions to determine the offset. The result must be written directly into the provided buffer without any intermediate string operations. The caller will handle printing the result if needed.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid to_lowercase(char* str) {\n    for (char* p = str; *p; ++p) {\n        *p = std::tolower(*p);\n    }\n}\n\nvoid determine_pandas_offset(const char* frequency, char* buffer) {\n\n    strncpy(buffer, frequency, 255);\n<diff>    buffer[254] = '\\0';\n    to_lowercase(buffer);\n\n    if (strcmp(buffer, \"annually\") == 0 || strcmp(buffer, \"yearly\") == 0) {\n        strncpy(buffer, \"A\", 255);\n    } else if (strcmp(buffer, \"monthly\") == 0) {\n        strncpy(buffer, \"M\", 255);\n    } else if (strcmp(buffer, \"weekly\") == 0) {\n        strncpy(buffer, \"W\", 255);\n    } else if (strcmp(buffer, \"daily\") == 0) {\n        strncpy(buffer, \"D\", 255);\n    } else if (strcmp(buffer, \"hourly\") == 0) {\n        strncpy(buffer, \"H\", 255);\n    } else if (strcmp(buffer, \"minutely\") == 0) {\n        strncpy(buffer, \"T\", 255);\n    } else if (strcmp(buffer, \"secondly\") == 0) {\n        strncpy(buffer, \"S\", 255);</diff>\n    } else {\n        buffer[0] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid to_lowercase(char* str) {\n    for (char* p = str; *p; ++p) {\n        *p = std::tolower(*p);\n    }\n}\n\nvoid determine_pandas_offset(const char* frequency, char* buffer) {\n\n    strncpy(buffer, frequency, 255);\n<diff>    buffer[255] = '\\0';\n    to_lowercase(buffer);\n\n    if (strcmp(buffer, \"annually\") == 0 || strcmp(buffer, \"yearly\") == 0) {\n        strcpy(buffer, \"A\");\n    } else if (strcmp(buffer, \"monthly\") == 0) {\n        strcpy(buffer, \"M\");\n    } else if (strcmp(buffer, \"weekly\") == 0) {\n        strcpy(buffer, \"W\");\n    } else if (strcmp(buffer, \"daily\") == 0) {\n        strcpy(buffer, \"D\");\n    } else if (strcmp(buffer, \"hourly\") == 0) {\n        strcpy(buffer, \"H\");\n    } else if (strcmp(buffer, \"minutely\") == 0) {\n        strcpy(buffer, \"T\");\n    } else if (strcmp(buffer, \"secondly\") == 0) {\n        strcpy(buffer, \"S\");</diff>\n    } else {\n        buffer[0] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ class `Brand` that represents a car brand with properties `name` and `logo_url`. The class should store these as character arrays of fixed size (100 bytes for name, 200 bytes for logo_url). The constructor should accept two C-style strings (const char*) for name and logo_url, validate they are not empty (throw runtime_error if empty), and copy them into the member arrays. Include a method `get_info` that returns a pair of these values as std::strings. The class should have a function-level comment that describes its properties, parameter types, and return types.\n\nYour code should pass the following test case:\nBrand brand(\"Ford\", \"https://www.ford.com/logos/brand.svg\");\nauto info = brand.get_info();\nassert(info.first == \"Ford\" && info.second == \"https://www.ford.com/logos/brand.svg\");", "chosen": "```cpp\n#include <stdexcept>\n#include <cstring>\n#include <utility>\n#include <string>\n\nclass Brand {\nprivate:\n    char name[100];\n    char logo_url[200];\n\npublic:\n\n    Brand(const char* name, const char* logo_url) {\n        if (!name || std::strlen(name) == 0) {\n            throw std::runtime_error(\"Name cannot be empty.\");\n        }\n        if (!logo_url || std::strlen(logo_url) == 0) {\n            throw std::runtime_error(\"Logo URL cannot be empty.\");\n        }\n\n<diff>        std::strncpy(this->name, name, sizeof(this->name) - 1);\n        this->name[sizeof(this->name) - 1] = '\\0';\n        std::strncpy(this->logo_url, logo_url, sizeof(this->logo_url) - 1);\n        this->logo_url[sizeof(this->logo_url) - 1] = '\\0';</diff>\n    }\n\n\n    std::pair<std::string, std::string> get_info() const {\n        return std::make_pair(std::string(name), std::string(logo_url));\n    }\n};\n\n\n\n\n\n```", "rejected": "```cpp\n#include <stdexcept>\n#include <cstring>\n#include <utility>\n#include <string>\n\nclass Brand {\nprivate:\n    char name[100];\n    char logo_url[200];\n\npublic:\n\n    Brand(const char* name, const char* logo_url) {\n        if (!name || std::strlen(name) == 0) {\n            throw std::runtime_error(\"Name cannot be empty.\");\n        }\n        if (!logo_url || std::strlen(logo_url) == 0) {\n            throw std::runtime_error(\"Logo URL cannot be empty.\");\n        }\n\n<diff>        std::strcpy(this->name, name);\n        std::strcpy(this->logo_url, logo_url);</diff>\n    }\n\n\n    std::pair<std::string, std::string> get_info() const {\n        return std::make_pair(std::string(name), std::string(logo_url));\n    }\n};\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `get_first_key` that takes a nested `std::map<std::string, std::any>` and writes the first key at the top level into a provided character buffer. The function should traverse the map recursively until it finds the first key at the top level, and then copy this key into the output buffer. The function should return true if a key was found and written to the buffer, false if the map was empty.\n\nFor example, given the map `{{\"a\", 1}, {\"b\", std::map<std::string, std::any>{{\"c\", 2}}}, {\"d\", std::map<std::string, std::any>{{\"e\", 3}}}}`, the function should write \"a\" into the output buffer. If the map is empty, the function should return false.\n\nThe function signature should be:\n`bool get_first_key(const std::map<std::string, std::any>& data, char* output_buffer);`\n\nNote: The caller is responsible for ensuring the output buffer has sufficient space for the key.", "chosen": "```cpp\n#include <map>\n#include <any>\n#include <cstring>\n<diff>#include <cstdio>\n\nbool get_first_key(const std::map<std::string, std::any>& data, char* output_buffer, size_t buffer_size) {\n    if (data.empty()) {\n        return false;\n    }\n\n\n    const auto& first_entry = *data.begin();\n    const std::string& first_key = first_entry.first;\n\n\n    std::snprintf(output_buffer, buffer_size, \"%s\", first_key.c_str());</diff>\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <any>\n#include <cstring>\n<diff>\nbool get_first_key(const std::map<std::string, std::any>& data, char* output_buffer) {\n    if (data.empty()) {\n        return false;\n    }\n\n\n    const auto& first_entry = *data.begin();\n    const std::string& first_key = first_entry.first;\n\n\n    std::strcpy(output_buffer, first_key.c_str());</diff>\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `insertLinks` that takes a null-terminated character array `input` (maximum length 1024 characters) and modifies it in-place to wrap each word in HTML link elements. Each word should be wrapped as follows: `<a href=\"lowercase_word\" target=\"_blank\"><span class=\"link\">original_word</span></a>`. Words are separated by whitespace.\n\nFor efficiency, you should perform all modifications directly in the input buffer without using additional memory allocation. You may assume the modified string will never exceed 4096 characters. Use standard C string manipulation functions where appropriate.\n\nExample:\nInput: \"John Doe\" (stored in a char array)\nOutput: \"<a href=\\\"john\\\" target=\\\"_blank\\\"><span class=\\\"link\\\">John</span></a> <a href=\\\"doe\\\" target=\\\"_blank\\\"><span class=\\\"link\\\">Doe</span></a>\" (stored in the same array)", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid insertLinks(char* input) {\n    const char* original = input;\n    size_t originalLen = strlen(input);\n\n\n    const char* htmlStart = \"<a href=\\\"\";\n    const char* htmlMiddle = \"\\\" target=\\\"_blank\\\"><span class=\\\"link\\\">\";\n    const char* htmlEnd = \"</span></a>\";\n\n\n    size_t maxWordLength = 0;\n    for (size_t i = 0; i < originalLen; ++i) {\n        if (isspace(original[i]) || i == originalLen - 1) {\n            size_t wordLength = i - maxWordLength;\n            if (i == originalLen - 1) wordLength += 1;\n            maxWordLength = std::max(maxWordLength, wordLength);\n        }\n    }\n    size_t maxHtmlLength = maxWordLength + strlen(htmlStart) + strlen(htmlMiddle) + strlen(htmlEnd) + 1;\n\n\n    char* end = input + originalLen;\n    char* out = end + maxHtmlLength * (originalLen / maxWordLength + 1);\n\n\n    char* start = end;\n    while (start >= input) {\n\n        while (start >= input && isspace(*start)) --start;\n\n\n        char* wordEnd = start;\n        while (start >= input && !isspace(*start)) --start;\n\n\n        ++start;\n\n\n        size_t wordLength = wordEnd - start + 1;\n\n\n        out -= strlen(htmlStart);\n<diff>        strncpy(out, htmlStart, strlen(htmlStart));\n\n\n        out -= wordLength;\n        for (size_t i = 0; i < wordLength; ++i) {\n            out[i] = std::tolower(start[i]);\n        }\n\n\n        out -= strlen(htmlMiddle);\n        strncpy(out, htmlMiddle, strlen(htmlMiddle));\n\n\n        out -= wordLength;\n        memcpy(out, start, wordLength);\n\n\n        out -= strlen(htmlEnd);\n        strncpy(out, htmlEnd, strlen(htmlEnd));</diff>\n\n\n        if (start > input) {\n            *--out = ' ';\n        }\n\n\n        start -= wordLength + 1;\n    }\n\n\n    size_t resultLength = end - out;\n    memmove(input, out, resultLength);\n    input[resultLength] = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid insertLinks(char* input) {\n    const char* original = input;\n    size_t originalLen = strlen(input);\n\n\n    const char* htmlStart = \"<a href=\\\"\";\n    const char* htmlMiddle = \"\\\" target=\\\"_blank\\\"><span class=\\\"link\\\">\";\n    const char* htmlEnd = \"</span></a>\";\n\n\n    size_t maxWordLength = 0;\n    for (size_t i = 0; i < originalLen; ++i) {\n        if (isspace(original[i]) || i == originalLen - 1) {\n            size_t wordLength = i - maxWordLength;\n            if (i == originalLen - 1) wordLength += 1;\n            maxWordLength = std::max(maxWordLength, wordLength);\n        }\n    }\n    size_t maxHtmlLength = maxWordLength + strlen(htmlStart) + strlen(htmlMiddle) + strlen(htmlEnd) + 1;\n\n\n    char* end = input + originalLen;\n    char* out = end + maxHtmlLength * (originalLen / maxWordLength + 1);\n\n\n    char* start = end;\n    while (start >= input) {\n\n        while (start >= input && isspace(*start)) --start;\n\n\n        char* wordEnd = start;\n        while (start >= input && !isspace(*start)) --start;\n\n\n        ++start;\n\n\n        size_t wordLength = wordEnd - start + 1;\n\n\n        out -= strlen(htmlStart);\n<diff>        strcpy(out, htmlStart);\n\n\n        out -= wordLength;\n        for (size_t i = 0; i < wordLength; ++i) {\n            out[i] = std::tolower(start[i]);\n        }\n\n\n        out -= strlen(htmlMiddle);\n        strcpy(out, htmlMiddle);\n\n\n        out -= wordLength;\n        memcpy(out, start, wordLength);\n\n\n        out -= strlen(htmlEnd);\n        strcpy(out, htmlEnd);</diff>\n\n\n        if (start > input) {\n            *--out = ' ';\n        }\n\n\n        start -= wordLength + 1;\n    }\n\n\n    size_t resultLength = end - out;\n    memmove(input, out, resultLength);\n    input[resultLength] = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `parseTrunks` that takes a null-terminated character array representing tree trunk data and populates a provided fixed-size output buffer. The input string contains a nested tree structure representing tree trunks, with the following format:\n\n- Trunks are separated by semicolons\n- Each trunk is enclosed in parentheses and has a name and number separated by a colon\n- Example: \"(trunk1:1);(trunk2:2);(trunk3:3)\"\n\nThe function should parse each trunk's name into a 50-byte buffer and its number into a separate 10-byte buffer, then concatenate them with a colon separator into the output buffer (pre-allocated with 1000 bytes). The function should return true if parsing succeeds for all trunks, false otherwise.\n\nNote: For efficiency, you should parse the input string in a single pass and write directly to the output buffer without intermediate storage.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cstdio>\n\nbool parseTrunks(const char* input, char* output, size_t outputSize) {\n    const char* ptr = input;\n    char* outPtr = output;\n    const size_t maxNameLen = 50;\n    const size_t maxNumLen = 10;\n    const size_t maxEntryLen = maxNameLen + maxNumLen + 2;\n\n    while (*ptr != '\\0' && outPtr < output + outputSize - maxEntryLen) {\n        if (*ptr != '(') {\n            return false;\n        }\n        ++ptr;\n\n\n        char* nameStart = outPtr;\n        while (*ptr != '\\0' && *ptr != ':' && outPtr < nameStart + maxNameLen - 1) {\n            *outPtr++ = *ptr++;\n        }\n        if (*ptr != ':' || outPtr >= nameStart + maxNameLen - 1) {\n            return false;\n        }\n        *outPtr++ = '\\0';\n\n        ++ptr;\n\n\n        char* numStart = outPtr;\n        while (*ptr != '\\0' && *ptr != ')' && outPtr < numStart + maxNumLen - 1) {\n            *outPtr++ = *ptr++;\n        }\n        if (*ptr != ')' || outPtr >= numStart + maxNumLen - 1) {\n            return false;\n        }\n        *outPtr++ = '\\0';\n\n        ++ptr;\n\n\n        size_t entryLen = outPtr - nameStart;\n        if (outPtr + entryLen + 2 >= output + outputSize) {\n            return false;\n        }\n<diff>        std::strncpy(outPtr, nameStart, entryLen);\n        outPtr += entryLen;\n        *outPtr++ = ':';\n        std::strncpy(outPtr, numStart, entryLen);</diff>\n        outPtr += entryLen;\n        *outPtr++ = ';';\n\n\n        if (*ptr != ';' && *ptr != '\\0') {\n            return false;\n        }\n        ++ptr;\n    }\n\n\n    if (outPtr > output && *(outPtr - 1) == ';') {\n        --outPtr;\n    }\n    *outPtr = '\\0';\n\n    return *ptr == '\\0';\n}\n\n\nint main() {\n    const char* input = \"(trunk1:1);(trunk2:2);(trunk3:3)\";\n    char output[1000];\n    if (parseTrunks(input, output, sizeof(output))) {\n        printf(\"Parsed successfully: %s\\n\", output);\n    } else {\n        printf(\"Parsing failed\\n\");\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cstdio>\n\nbool parseTrunks(const char* input, char* output, size_t outputSize) {\n    const char* ptr = input;\n    char* outPtr = output;\n    const size_t maxNameLen = 50;\n    const size_t maxNumLen = 10;\n    const size_t maxEntryLen = maxNameLen + maxNumLen + 2;\n\n    while (*ptr != '\\0' && outPtr < output + outputSize - maxEntryLen) {\n        if (*ptr != '(') {\n            return false;\n        }\n        ++ptr;\n\n\n        char* nameStart = outPtr;\n        while (*ptr != '\\0' && *ptr != ':' && outPtr < nameStart + maxNameLen - 1) {\n            *outPtr++ = *ptr++;\n        }\n        if (*ptr != ':' || outPtr >= nameStart + maxNameLen - 1) {\n            return false;\n        }\n        *outPtr++ = '\\0';\n\n        ++ptr;\n\n\n        char* numStart = outPtr;\n        while (*ptr != '\\0' && *ptr != ')' && outPtr < numStart + maxNumLen - 1) {\n            *outPtr++ = *ptr++;\n        }\n        if (*ptr != ')' || outPtr >= numStart + maxNumLen - 1) {\n            return false;\n        }\n        *outPtr++ = '\\0';\n\n        ++ptr;\n\n\n        size_t entryLen = outPtr - nameStart;\n        if (outPtr + entryLen + 2 >= output + outputSize) {\n            return false;\n        }\n<diff>        std::strcpy(outPtr, nameStart);\n        outPtr += entryLen;\n        *outPtr++ = ':';\n        std::strcpy(outPtr, numStart);</diff>\n        outPtr += entryLen;\n        *outPtr++ = ';';\n\n\n        if (*ptr != ';' && *ptr != '\\0') {\n            return false;\n        }\n        ++ptr;\n    }\n\n\n    if (outPtr > output && *(outPtr - 1) == ';') {\n        --outPtr;\n    }\n    *outPtr = '\\0';\n\n    return *ptr == '\\0';\n}\n\n\nint main() {\n    const char* input = \"(trunk1:1);(trunk2:2);(trunk3:3)\";\n    char output[1000];\n    if (parseTrunks(input, output, sizeof(output))) {\n        printf(\"Parsed successfully: %s\\n\", output);\n    } else {\n        printf(\"Parsing failed\\n\");\n    }\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings in the format \"[prefix]_[suffix]\". For each string, extract the prefix and suffix, convert the prefix to lowercase, and replace every '_' with a space. For performance reasons, you must perform these operations in-place using fixed-size character buffers (maximum 256 bytes per string).\n\nThe function signature should be:\nstd::vector<std::pair<std::string, std::string>> split_and_lowercase(const std::vector<std::string>& strings);\n\nYour code should pass the following test case:\nstd::vector<std::string> strings = {\"abc_def\", \"ghi_jkl\"};\nauto result = split_and_lowercase(strings);\nassert(result == std::vector<std::pair<std::string, std::string>>{{{\"abc\", \"def\"}, {\"ghi\", \"jkl\"}}});", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n#include <cstring>\n\nstd::vector<std::pair<std::string, std::string>> split_and_lowercase(const std::vector<std::string>& strings) {\n    std::vector<std::pair<std::string, std::string>> result;\n    char buffer[256];\n\n    for (const auto& str : strings) {\n\n        if (str.size() >= sizeof(buffer)) {\n            throw std::invalid_argument(\"String exceeds buffer size\");\n        }\n\n<diff>        std::strncpy(buffer, str.c_str(), sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n\n        char* underscore_pos = std::strchr(buffer, '_');\n        if (underscore_pos == nullptr) {\n            throw std::invalid_argument(\"String does not contain an underscore\");\n        }\n\n\n        *underscore_pos = '\\0';\n\n\n        for (char* c = buffer; *c != '\\0'; ++c) {\n            *c = std::tolower(*c);\n        }\n\n\n        char* suffix = underscore_pos + 1;\n\n\n        result.emplace_back(std::make_pair(std::string(buffer), std::string(suffix)));\n    }\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n#include <cstring>\n\nstd::vector<std::pair<std::string, std::string>> split_and_lowercase(const std::vector<std::string>& strings) {\n    std::vector<std::pair<std::string, std::string>> result;\n    char buffer[256];\n\n    for (const auto& str : strings) {\n\n        if (str.size() >= sizeof(buffer)) {\n            throw std::invalid_argument(\"String exceeds buffer size\");\n        }\n\n<diff>        std::strcpy(buffer, str.c_str());</diff>\n\n\n        char* underscore_pos = std::strchr(buffer, '_');\n        if (underscore_pos == nullptr) {\n            throw std::invalid_argument(\"String does not contain an underscore\");\n        }\n\n\n        *underscore_pos = '\\0';\n\n\n        for (char* c = buffer; *c != '\\0'; ++c) {\n            *c = std::tolower(*c);\n        }\n\n\n        char* suffix = underscore_pos + 1;\n\n\n        result.emplace_back(std::make_pair(std::string(buffer), std::string(suffix)));\n    }\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void hexToBitstring(const char* hex_str, char* bitstring)` that converts a hexadecimal string to a bit string representation. Each hexadecimal digit should be converted to its 4-bit binary equivalent. The conversion should be done in-place in the provided `bitstring` buffer, which is guaranteed to be large enough for valid inputs. The bitstring should not contain any spaces or separators between the 4-bit groups.\n\nYour function should handle the following cases correctly:\n1. \"35ca\"  \"0011010111001010\"\n2. \"0\"  \"0000\"\n3. \"abcdef\"  \"101010111100110111101111\"\n\nNote: You may assume the input hex string contains only valid hexadecimal characters (0-9, a-f, A-F).", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nconst char* hexCharToBits(char ch) {\n    switch (std::tolower(ch)) {\n        case '0': return \"0000\";\n        case '1': return \"0001\";\n        case '2': return \"0010\";\n        case '3': return \"0011\";\n        case '4': return \"0100\";\n        case '5': return \"0101\";\n        case '6': return \"0110\";\n        case '7': return \"0111\";\n        case '8': return \"1000\";\n        case '9': return \"1001\";\n        case 'a': return \"1010\";\n        case 'b': return \"1011\";\n        case 'c': return \"1100\";\n        case 'd': return \"1101\";\n        case 'e': return \"1110\";\n        case 'f': return \"1111\";\n        default: return \"\";\n    }\n}\n\n\nvoid hexToBitstring(const char* hex_str, char* bitstring) {\n    char* bitPtr = bitstring;\n<diff>    while (*hex_str && bitPtr - bitstring < 32) {\n        const char* bits = hexCharToBits(*hex_str);\n        std::strncpy(bitPtr, bits, 4);</diff>\n        bitPtr += 4;\n        ++hex_str;\n    }\n    *bitPtr = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nconst char* hexCharToBits(char ch) {\n    switch (std::tolower(ch)) {\n        case '0': return \"0000\";\n        case '1': return \"0001\";\n        case '2': return \"0010\";\n        case '3': return \"0011\";\n        case '4': return \"0100\";\n        case '5': return \"0101\";\n        case '6': return \"0110\";\n        case '7': return \"0111\";\n        case '8': return \"1000\";\n        case '9': return \"1001\";\n        case 'a': return \"1010\";\n        case 'b': return \"1011\";\n        case 'c': return \"1100\";\n        case 'd': return \"1101\";\n        case 'e': return \"1110\";\n        case 'f': return \"1111\";\n        default: return \"\";\n    }\n}\n\n\nvoid hexToBitstring(const char* hex_str, char* bitstring) {\n    char* bitPtr = bitstring;\n<diff>    while (*hex_str) {\n        const char* bits = hexCharToBits(*hex_str);\n        std::strcpy(bitPtr, bits);</diff>\n        bitPtr += 4;\n        ++hex_str;\n    }\n    *bitPtr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `consolidate_return_strings` that consolidates the return values of two functions into a single string. The two functions should return C-style strings (null-terminated character arrays).\n\nThe function should:\n1. Call both functions to get their return values\n2. If the first function returns a non-null string, copy it into a fixed-size output buffer (100 bytes)\n3. If the first function returns null, copy the second function's return value into the same buffer\n4. If both return null, set the first byte of the buffer to null\n5. Return a pointer to the buffer\n\nFor efficiency, perform all operations directly on the output buffer without intermediate copies. Assume the input strings will always fit in the buffer (no need to check lengths).", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\n\nconst char* getFirstString();\nconst char* getSecondString();\n\n\nconst char* consolidate_return_strings() {\n    static char buffer[100];\n\n    const char* firstResult = getFirstString();\n    if (firstResult != nullptr) {\n        std::snprintf(buffer, sizeof(buffer), \"%s\", firstResult);\n    } else {\n        const char* secondResult = getSecondString();\n        if (secondResult != nullptr) {\n            std::snprintf(buffer, sizeof(buffer), \"%s\", secondResult);</diff>\n        } else {\n            buffer[0] = '\\0';\n        }\n    }\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\n\nconst char* getFirstString();\nconst char* getSecondString();\n\n\nconst char* consolidate_return_strings() {\n    static char buffer[100];\n\n    const char* firstResult = getFirstString();\n    if (firstResult != nullptr) {\n        std::strcpy(buffer, firstResult);\n    } else {\n        const char* secondResult = getSecondString();\n        if (secondResult != nullptr) {\n            std::strcpy(buffer, secondResult);</diff>\n        } else {\n            buffer[0] = '\\0';\n        }\n    }\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings to build a vocabulary mapping in a fixed-size output buffer. The function should take the following parameters:\n1. An array of C-style strings (null-terminated character arrays)\n2. The number of strings in the array\n3. A pre-allocated output buffer of 1024 bytes\n4. A pointer to store the number of unique words found\n\nFor each unique word in the input array, the function should write to the output buffer in the following format: \"word:index,\" where index is the word's first occurrence position (0-based). The entries should be concatenated directly in the buffer without extra spacing. If the input array is empty, the buffer should remain unchanged.\n\nExample: For input [\"apple\", \"banana\", \"apple\"], the buffer should contain \"apple:0,banana:1,\"\n\nNote: Your implementation should efficiently build the output string directly in the provided buffer without intermediate storage.", "chosen": "```cpp\n#include <cstring>\n#include <map>\n\nvoid buildVocabularyMapping(const char* const* words, size_t numWords, char* buffer, size_t* uniqueWordCount) {\n    std::map<std::string, size_t> wordMap;\n    char* currentPos = buffer;\n    size_t bufferSize = 1024;\n\n    for (size_t i = 0; i < numWords && currentPos < buffer + bufferSize; ++i) {\n        std::string word(words[i]);\n        auto it = wordMap.find(word);\n\n        if (it == wordMap.end()) {\n\n            wordMap[word] = i;\n\n\n            size_t wordLength = strlen(word.c_str());\n            size_t entryLength = wordLength + 1 + 10 + 1;\n\n            if (currentPos + entryLength >= buffer + bufferSize) {\n                break;\n            }\n\n<diff>            strncpy(currentPos, word.c_str(), wordLength);</diff>\n            currentPos += wordLength;\n            *currentPos++ = ':';\n            currentPos += sprintf(currentPos, \"%zu\", i);\n            *currentPos++ = ',';\n        }\n    }\n\n\n    if (currentPos < buffer + bufferSize) {\n        *currentPos = '\\0';\n    }\n\n\n    *uniqueWordCount = wordMap.size();\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <map>\n\nvoid buildVocabularyMapping(const char* const* words, size_t numWords, char* buffer, size_t* uniqueWordCount) {\n    std::map<std::string, size_t> wordMap;\n    char* currentPos = buffer;\n    size_t bufferSize = 1024;\n\n    for (size_t i = 0; i < numWords && currentPos < buffer + bufferSize; ++i) {\n        std::string word(words[i]);\n        auto it = wordMap.find(word);\n\n        if (it == wordMap.end()) {\n\n            wordMap[word] = i;\n\n\n            size_t wordLength = strlen(word.c_str());\n            size_t entryLength = wordLength + 1 + 10 + 1;\n\n            if (currentPos + entryLength >= buffer + bufferSize) {\n                break;\n            }\n\n<diff>            strcpy(currentPos, word.c_str());</diff>\n            currentPos += wordLength;\n            *currentPos++ = ':';\n            currentPos += sprintf(currentPos, \"%zu\", i);\n            *currentPos++ = ',';\n        }\n    }\n\n\n    if (currentPos < buffer + bufferSize) {\n        *currentPos = '\\0';\n    }\n\n\n    *uniqueWordCount = wordMap.size();\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `deduplicate_and_group` that processes an array of C-style strings (null-terminated character arrays) and performs the following operations:\n\n1. Remove any leading or trailing whitespace from each string (modifying the strings in-place)\n2. Deduplicate the strings based on their values, preserving the order of first occurrence\n3. Store the results in a pre-allocated output buffer of fixed size (256 bytes)\n4. Return the number of unique strings found\n\nThe function should have the following signature:\n`int deduplicate_and_group(const char* input[], int input_size, char output[256])`\n\nEach unique string in the output buffer should be written as a null-terminated string, followed immediately by its index (as a string), with no separator between them. For example, given the input `{\"   a\", \"   b\", \"c\", \"   a  \", \"   c\"}`, the output buffer should contain \"a0b1c2\" and the function should return 3.\n\nNote: You must perform all string operations directly in the provided buffers without using dynamic memory allocation.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nint deduplicate_and_group(const char* input[], int input_size, char output[256]) {\n    char* out_ptr = output;\n    char processed[256][256];\n    bool seen[256] = {false};\n    int unique_count = 0;\n\n    for (int i = 0; i < input_size && out_ptr - output < 256; ++i) {\n        const char* str = input[i];\n\n\n        while (*str && std::isspace(*str)) {\n            ++str;\n        }\n\n\n        const char* end = str;\n        while (*end) {\n            ++end;\n        }\n        while (end > str && std::isspace(*(end - 1))) {\n            --end;\n        }\n\n\n        size_t len = end - str;\n\n\n        bool is_unique = true;\n        for (int j = 0; j < unique_count; ++j) {\n            if (std::strncmp(processed[j], str, len) == 0 && processed[j][len] == '\\0') {\n                is_unique = false;\n                break;\n            }\n        }\n\n        if (is_unique) {\n\n            strncpy(processed[unique_count], str, len);\n            processed[unique_count][len] = '\\0';\n\n\n            seen[unique_count] = true;\n\n\n            if (out_ptr - output + len + 1 >= 256) {\n                break;\n            }\n<diff>            strncpy(out_ptr, str, len);</diff>\n            out_ptr += len;\n            *out_ptr++ = '0' + unique_count;\n\n            ++unique_count;\n        }\n    }\n\n\n    *out_ptr = '\\0';\n\n    return unique_count;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nint deduplicate_and_group(const char* input[], int input_size, char output[256]) {\n    char* out_ptr = output;\n    char processed[256][256];\n    bool seen[256] = {false};\n    int unique_count = 0;\n\n    for (int i = 0; i < input_size && out_ptr - output < 256; ++i) {\n        const char* str = input[i];\n\n\n        while (*str && std::isspace(*str)) {\n            ++str;\n        }\n\n\n        const char* end = str;\n        while (*end) {\n            ++end;\n        }\n        while (end > str && std::isspace(*(end - 1))) {\n            --end;\n        }\n\n\n        size_t len = end - str;\n\n\n        bool is_unique = true;\n        for (int j = 0; j < unique_count; ++j) {\n            if (std::strncmp(processed[j], str, len) == 0 && processed[j][len] == '\\0') {\n                is_unique = false;\n                break;\n            }\n        }\n\n        if (is_unique) {\n\n            strncpy(processed[unique_count], str, len);\n            processed[unique_count][len] = '\\0';\n\n\n            seen[unique_count] = true;\n\n\n            if (out_ptr - output + len + 1 >= 256) {\n                break;\n            }\n<diff>            strcpy(out_ptr, str);</diff>\n            out_ptr += len;\n            *out_ptr++ = '0' + unique_count;\n\n            ++unique_count;\n        }\n    }\n\n\n    *out_ptr = '\\0';\n\n    return unique_count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement the beam search algorithm for sequence generation in C++. For performance reasons, use fixed-size buffers to store sequences and their scores. Assume sequences will never exceed 1000 tokens and scores will never exceed 1000 elements. Use the following functions:\n- `void get_k_best(float* scores, int k, int* result_indices)`: Given an array of scores, store the top k indices with the best scores in result_indices.\n- `void decode_sequence(int* sequence, char* output)`: Given a sequence, decode it into a readable string stored in output buffer.\n- `void generate_next_sequence(Model* model, int* current_sequence, int* next_token)`: Generate the next token for the sequence.\n\nThe implementation should efficiently manage memory by reusing buffers where possible. Return the top sequence as a decoded string in the provided output buffer.", "chosen": "```cpp\n#include <cstring>\n#include <cfloat>\n#include <iostream>\n<diff>#include <random>\n\n\nconst int MAX_TOKENS = 1000;\nconst int MAX_BEAM_WIDTH = 1000;\n\n\nclass Model {\npublic:\n    std::mt19937 rng;\n    std::uniform_real_distribution<float> dist;\n\n    Model() : rng(std::random_device()()), dist(0.0f, 1.0f) {}\n\n    void generate_next_sequence(int* current_sequence, float* scores, int sequence_length) {\n\n\n        for (int i = 0; i < MAX_TOKENS; ++i) {\n            scores[i] = dist(rng);</diff>\n        }\n    }\n};\n\n\nvoid get_k_best(float* scores, int k, int* result_indices);\nvoid decode_sequence(int* sequence, char* output);\nvoid generate_next_sequence(Model* model, int* current_sequence, int* next_token);\n\n\nvoid beam_search(Model* model, int start_token, int beam_width, int max_length, char* output) {\n\n    int sequences[MAX_BEAM_WIDTH][MAX_TOKENS];\n    float scores[MAX_BEAM_WIDTH];\n    int parent_indices[MAX_BEAM_WIDTH];\n\n\n    memset(sequences, 0, sizeof(sequences));\n    sequences[0][0] = start_token;\n    scores[0] = 0.0f;\n    int num_sequences = 1;\n\n    for (int length = 1; length < max_length; ++length) {\n        float next_scores[MAX_BEAM_WIDTH * MAX_TOKENS];\n        int candidate_indices[MAX_BEAM_WIDTH * MAX_TOKENS];\n        int candidate_parents[MAX_BEAM_WIDTH * MAX_TOKENS];\n\n        int candidate_count = 0;\n        for (int i = 0; i < num_sequences; ++i) {\n            float scores_buffer[MAX_TOKENS];\n            model->generate_next_sequence(sequences[i], scores_buffer, length);\n\n            for (int j = 0; j < MAX_TOKENS; ++j) {\n                next_scores[candidate_count] = scores[i] - scores_buffer[j];\n                candidate_indices[candidate_count] = j;\n                candidate_parents[candidate_count] = i;\n                ++candidate_count;\n            }\n        }\n\n\n        get_k_best(next_scores, beam_width, candidate_indices);\n        num_sequences = 0;\n\n        for (int i = 0; i < beam_width; ++i) {\n            int idx = candidate_indices[i];\n            int parent_idx = candidate_parents[idx];\n            int token = candidate_indices[idx];\n            scores[num_sequences] = next_scores[idx];\n            memcpy(sequences[num_sequences], sequences[parent_idx], length * sizeof(int));\n            sequences[num_sequences][length] = token;\n            ++num_sequences;\n        }\n    }\n\n\n    int best_index = 0;\n    for (int i = 1; i < num_sequences; ++i) {\n        if (scores[i] < scores[best_index]) {\n            best_index = i;\n        }\n    }\n\n\n    decode_sequence(sequences[best_index], output);\n}\n\n\nvoid get_k_best(float* scores, int k, int* result_indices) {\n\n    for (int i = 0; i < k; ++i) {\n        result_indices[i] = i;\n    }\n\n}\n\nvoid decode_sequence(int* sequence, char* output) {\n\n    for (int i = 0; i < MAX_TOKENS && sequence[i] != 0; ++i) {\n        output[i] = 'A' + (sequence[i] % 26);\n    }\n    output[MAX_TOKENS - 1] = '\\0';\n}\n\nvoid generate_next_sequence(Model* model, int* current_sequence, int* next_token) {\n\n    float scores[MAX_TOKENS];\n    model->generate_next_sequence(current_sequence, scores, MAX_TOKENS);\n\n    *next_token = 0;\n    for (int i = 1; i < MAX_TOKENS; ++i) {\n        if (scores[i] > scores[*next_token]) {\n            *next_token = i;\n        }\n    }\n}\n\n\nint main() {\n    Model model;\n    char output[MAX_TOKENS];\n    beam_search(&model, 0, 5, 10, output);\n    std::cout << \"Best sequence: \" << output << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cfloat>\n#include <iostream>\n<diff>\n\nconst int MAX_TOKENS = 1000;\nconst int MAX_BEAM_WIDTH = 1000;\n\n\nclass Model {\npublic:\n    void generate_next_sequence(int* current_sequence, float* scores, int sequence_length) {\n\n\n        for (int i = 0; i < MAX_TOKENS; ++i) {\n            scores[i] = static_cast<float>(rand()) / RAND_MAX;</diff>\n        }\n    }\n};\n\n\nvoid get_k_best(float* scores, int k, int* result_indices);\nvoid decode_sequence(int* sequence, char* output);\nvoid generate_next_sequence(Model* model, int* current_sequence, int* next_token);\n\n\nvoid beam_search(Model* model, int start_token, int beam_width, int max_length, char* output) {\n\n    int sequences[MAX_BEAM_WIDTH][MAX_TOKENS];\n    float scores[MAX_BEAM_WIDTH];\n    int parent_indices[MAX_BEAM_WIDTH];\n\n\n    memset(sequences, 0, sizeof(sequences));\n    sequences[0][0] = start_token;\n    scores[0] = 0.0f;\n    int num_sequences = 1;\n\n    for (int length = 1; length < max_length; ++length) {\n        float next_scores[MAX_BEAM_WIDTH * MAX_TOKENS];\n        int candidate_indices[MAX_BEAM_WIDTH * MAX_TOKENS];\n        int candidate_parents[MAX_BEAM_WIDTH * MAX_TOKENS];\n\n        int candidate_count = 0;\n        for (int i = 0; i < num_sequences; ++i) {\n            float scores_buffer[MAX_TOKENS];\n            model->generate_next_sequence(sequences[i], scores_buffer, length);\n\n            for (int j = 0; j < MAX_TOKENS; ++j) {\n                next_scores[candidate_count] = scores[i] - scores_buffer[j];\n                candidate_indices[candidate_count] = j;\n                candidate_parents[candidate_count] = i;\n                ++candidate_count;\n            }\n        }\n\n\n        get_k_best(next_scores, beam_width, candidate_indices);\n        num_sequences = 0;\n\n        for (int i = 0; i < beam_width; ++i) {\n            int idx = candidate_indices[i];\n            int parent_idx = candidate_parents[idx];\n            int token = candidate_indices[idx];\n            scores[num_sequences] = next_scores[idx];\n            memcpy(sequences[num_sequences], sequences[parent_idx], length * sizeof(int));\n            sequences[num_sequences][length] = token;\n            ++num_sequences;\n        }\n    }\n\n\n    int best_index = 0;\n    for (int i = 1; i < num_sequences; ++i) {\n        if (scores[i] < scores[best_index]) {\n            best_index = i;\n        }\n    }\n\n\n    decode_sequence(sequences[best_index], output);\n}\n\n\nvoid get_k_best(float* scores, int k, int* result_indices) {\n\n    for (int i = 0; i < k; ++i) {\n        result_indices[i] = i;\n    }\n\n}\n\nvoid decode_sequence(int* sequence, char* output) {\n\n    for (int i = 0; i < MAX_TOKENS && sequence[i] != 0; ++i) {\n        output[i] = 'A' + (sequence[i] % 26);\n    }\n    output[MAX_TOKENS - 1] = '\\0';\n}\n\nvoid generate_next_sequence(Model* model, int* current_sequence, int* next_token) {\n\n    float scores[MAX_TOKENS];\n    model->generate_next_sequence(current_sequence, scores, MAX_TOKENS);\n\n    *next_token = 0;\n    for (int i = 1; i < MAX_TOKENS; ++i) {\n        if (scores[i] > scores[*next_token]) {\n            *next_token = i;\n        }\n    }\n}\n\n\nint main() {\n    Model model;\n    char output[MAX_TOKENS];\n    beam_search(&model, 0, 5, 10, output);\n    std::cout << \"Best sequence: \" << output << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Implement the Depth-First Search (DFS) and Breadth-First Search (BFS) algorithms in C++ to find all paths from a given source node to a target node in a weighted graph. The graph is represented as an adjacency matrix passed as a raw pointer to integers, where each row and column represents a node, and each value represents the edge weight (0 means no edge). The number of nodes is provided as a separate parameter.\n\nYour implementation should:\n1. Store all found paths in a pre-allocated buffer of character arrays (each path as a null-terminated string)\n2. Use the adjacency matrix directly through pointer arithmetic\n3. Return the number of paths found\n\nAssume the output buffer is large enough to hold all possible paths. Each path string should list node indices separated by spaces (e.g., \"0 2 4\").", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n<diff>#include <cstring>\n\nusing namespace std;\n\n\nvoid storePathInBuffer(vector<int>& path, char** buffer, int& pathCount) {\n    stringstream ss;\n    for (size_t i = 0; i < path.size(); ++i) {\n        ss << path[i];\n        if (i != path.size() - 1) ss << \" \";\n    }\n    strncpy(buffer[pathCount++], ss.str().c_str(), 99);\n    buffer[pathCount - 1][99] = '\\0';</diff>\n}\n\n\nvoid dfs(int** adjMatrix, int numNodes, int source, int target, vector<int>& path, char** buffer, int& pathCount) {\n    path.push_back(source);\n    if (source == target) {\n        storePathInBuffer(path, buffer, pathCount);\n    } else {\n        for (int v = 0; v < numNodes; ++v) {\n            if (adjMatrix[source][v] > 0 && find(path.begin(), path.end(), v) == path.end()) {\n                dfs(adjMatrix, numNodes, v, target, path, buffer, pathCount);\n            }\n        }\n    }\n    path.pop_back();\n}\n\n\nvoid bfs(int** adjMatrix, int numNodes, int source, int target, char** buffer, int& pathCount) {\n    queue<vector<int>> q;\n    q.push({source});\n\n    while (!q.empty()) {\n        vector<int> path = q.front();\n        q.pop();\n        int currentNode = path.back();\n\n        if (currentNode == target) {\n            storePathInBuffer(path, buffer, pathCount);\n        } else {\n            for (int v = 0; v < numNodes; ++v) {\n                if (adjMatrix[currentNode][v] > 0 && find(path.begin(), path.end(), v) == path.end()) {\n                    vector<int> newPath = path;\n                    newPath.push_back(v);\n                    q.push(newPath);\n                }\n            }\n        }\n    }\n}\n\n\nint findAllPathsDFS(int* adjMatrix, int numNodes, int source, int target, char** buffer) {\n    int pathCount = 0;\n    vector<int> path;\n    int** matrixPtr = new int*[numNodes];\n    for (int i = 0; i < numNodes; ++i) {\n        matrixPtr[i] = adjMatrix + i * numNodes;\n    }\n    dfs(matrixPtr, numNodes, source, target, path, buffer, pathCount);\n    delete[] matrixPtr;\n    return pathCount;\n}\n\n\nint findAllPathsBFS(int* adjMatrix, int numNodes, int source, int target, char** buffer) {\n    int pathCount = 0;\n    int** matrixPtr = new int*[numNodes];\n    for (int i = 0; i < numNodes; ++i) {\n        matrixPtr[i] = adjMatrix + i * numNodes;\n    }\n    bfs(matrixPtr, numNodes, source, target, buffer, pathCount);\n    delete[] matrixPtr;\n    return pathCount;\n}\n\nint main() {\n\n    int numNodes = 5;\n    int adjMatrix[] = {\n        0, 1, 0, 0, 0,\n        1, 0, 1, 1, 0,\n        0, 1, 0, 0, 1,\n        0, 1, 0, 0, 1,\n        0, 0, 1, 1, 0\n    };\n    int source = 0;\n    int target = 4;\n    const int maxPaths = 100;\n    char* buffer[maxPaths];\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        buffer[i] = new char[100];\n    }\n\n    int numPathsDFS = findAllPathsDFS(adjMatrix, numNodes, source, target, buffer);\n    cout << \"DFS Paths:\\n\";\n    for (int i = 0; i < numPathsDFS; ++i) {\n        cout << buffer[i] << endl;\n    }\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        memset(buffer[i], 0, 100);\n    }\n\n    int numPathsBFS = findAllPathsBFS(adjMatrix, numNodes, source, target, buffer);\n    cout << \"BFS Paths:\\n\";\n    for (int i = 0; i < numPathsBFS; ++i) {\n        cout << buffer[i] << endl;\n    }\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        delete[] buffer[i];\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n<diff>\nusing namespace std;\n\n\nvoid storePathInBuffer(vector<int>& path, char** buffer, int& pathCount) {\n    stringstream ss;\n    for (size_t i = 0; i < path.size(); ++i) {\n        ss << path[i];\n        if (i != path.size() - 1) ss << \" \";\n    }\n    ss << '\\0';\n    strcpy(buffer[pathCount++], ss.str().c_str());</diff>\n}\n\n\nvoid dfs(int** adjMatrix, int numNodes, int source, int target, vector<int>& path, char** buffer, int& pathCount) {\n    path.push_back(source);\n    if (source == target) {\n        storePathInBuffer(path, buffer, pathCount);\n    } else {\n        for (int v = 0; v < numNodes; ++v) {\n            if (adjMatrix[source][v] > 0 && find(path.begin(), path.end(), v) == path.end()) {\n                dfs(adjMatrix, numNodes, v, target, path, buffer, pathCount);\n            }\n        }\n    }\n    path.pop_back();\n}\n\n\nvoid bfs(int** adjMatrix, int numNodes, int source, int target, char** buffer, int& pathCount) {\n    queue<vector<int>> q;\n    q.push({source});\n\n    while (!q.empty()) {\n        vector<int> path = q.front();\n        q.pop();\n        int currentNode = path.back();\n\n        if (currentNode == target) {\n            storePathInBuffer(path, buffer, pathCount);\n        } else {\n            for (int v = 0; v < numNodes; ++v) {\n                if (adjMatrix[currentNode][v] > 0 && find(path.begin(), path.end(), v) == path.end()) {\n                    vector<int> newPath = path;\n                    newPath.push_back(v);\n                    q.push(newPath);\n                }\n            }\n        }\n    }\n}\n\n\nint findAllPathsDFS(int* adjMatrix, int numNodes, int source, int target, char** buffer) {\n    int pathCount = 0;\n    vector<int> path;\n    int** matrixPtr = new int*[numNodes];\n    for (int i = 0; i < numNodes; ++i) {\n        matrixPtr[i] = adjMatrix + i * numNodes;\n    }\n    dfs(matrixPtr, numNodes, source, target, path, buffer, pathCount);\n    delete[] matrixPtr;\n    return pathCount;\n}\n\n\nint findAllPathsBFS(int* adjMatrix, int numNodes, int source, int target, char** buffer) {\n    int pathCount = 0;\n    int** matrixPtr = new int*[numNodes];\n    for (int i = 0; i < numNodes; ++i) {\n        matrixPtr[i] = adjMatrix + i * numNodes;\n    }\n    bfs(matrixPtr, numNodes, source, target, buffer, pathCount);\n    delete[] matrixPtr;\n    return pathCount;\n}\n\nint main() {\n\n    int numNodes = 5;\n    int adjMatrix[] = {\n        0, 1, 0, 0, 0,\n        1, 0, 1, 1, 0,\n        0, 1, 0, 0, 1,\n        0, 1, 0, 0, 1,\n        0, 0, 1, 1, 0\n    };\n    int source = 0;\n    int target = 4;\n    const int maxPaths = 100;\n    char* buffer[maxPaths];\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        buffer[i] = new char[100];\n    }\n\n    int numPathsDFS = findAllPathsDFS(adjMatrix, numNodes, source, target, buffer);\n    cout << \"DFS Paths:\\n\";\n    for (int i = 0; i < numPathsDFS; ++i) {\n        cout << buffer[i] << endl;\n    }\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        memset(buffer[i], 0, 100);\n    }\n\n    int numPathsBFS = findAllPathsBFS(adjMatrix, numNodes, source, target, buffer);\n    cout << \"BFS Paths:\\n\";\n    for (int i = 0; i < numPathsBFS; ++i) {\n        cout << buffer[i] << endl;\n    }\n\n\n    for (int i = 0; i < maxPaths; ++i) {\n        delete[] buffer[i];\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `format_template` that takes three arguments: `data`, a map<string, string> containing data for a template; `template_str`, a character array that contains template variables in the format ${var}; and `output_buffer`, a pre-allocated character buffer for the result. The function should replace all template variables in `template_str` with their corresponding values from `data`. If a variable is not found in `data`, it should be replaced with an empty string. The function should write the result directly into `output_buffer` and return the number of characters written. Assume the output buffer is always large enough to hold the result. Write appropriate documentation for the function.", "chosen": "```cpp\n#include <cstddef>\n#include <map>\n#include <string>\n#include <cstring>\n\n\nsize_t format_template(const std::map<std::string, std::string>& data, const char* template_str, char* output_buffer) {\n    size_t output_index = 0;\n    size_t input_index = 0;\n    size_t template_len = std::strlen(template_str);\n\n    while (input_index < template_len) {\n        if (template_str[input_index] == '$' && template_str[input_index + 1] == '{') {\n\n            size_t start = input_index + 2;\n            size_t end = start;\n\n\n            while (end < template_len && template_str[end] != '}') {\n                ++end;\n            }\n\n            if (end < template_len) {\n                std::string key(template_str + start, end - start);\n                auto it = data.find(key);\n                if (it != data.end()) {\n\n<diff>                    size_t value_len = it->second.size();\n                    if (output_index + value_len < 1024) {\n                        std::strncpy(output_buffer + output_index, it->second.c_str(), value_len);\n                        output_index += value_len;\n                    }</diff>\n                }\n\n                input_index = end + 1;\n            } else {\n\n                output_buffer[output_index++] = template_str[input_index++];\n            }\n        } else {\n\n            output_buffer[output_index++] = template_str[input_index++];\n        }\n    }\n\n\n    output_buffer[output_index] = '\\0';\n    return output_index;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <map>\n#include <string>\n#include <cstring>\n\n\nsize_t format_template(const std::map<std::string, std::string>& data, const char* template_str, char* output_buffer) {\n    size_t output_index = 0;\n    size_t input_index = 0;\n    size_t template_len = std::strlen(template_str);\n\n    while (input_index < template_len) {\n        if (template_str[input_index] == '$' && template_str[input_index + 1] == '{') {\n\n            size_t start = input_index + 2;\n            size_t end = start;\n\n\n            while (end < template_len && template_str[end] != '}') {\n                ++end;\n            }\n\n            if (end < template_len) {\n                std::string key(template_str + start, end - start);\n                auto it = data.find(key);\n                if (it != data.end()) {\n\n<diff>                    std::strcpy(output_buffer + output_index, it->second.c_str());\n                    output_index += it->second.size();</diff>\n                }\n\n                input_index = end + 1;\n            } else {\n\n                output_buffer[output_index++] = template_str[input_index++];\n            }\n        } else {\n\n            output_buffer[output_index++] = template_str[input_index++];\n        }\n    }\n\n\n    output_buffer[output_index] = '\\0';\n    return output_index;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that determines if two circles intersect. The function should take two Circle structures (each containing radius and center coordinates) and a character buffer of fixed size 32 bytes. The function must:\n1. Calculate whether the circles intersect (return true if they do, false otherwise)\n2. Write the result as a string (\"Intersect\" or \"No Intersect\") into the provided buffer\n3. Ensure the buffer is always null-terminated\n\nNote: The buffer size is fixed at 32 bytes and cannot be changed. Your solution must work within this constraint while performing both the calculation and string writing.", "chosen": "```cpp\n#include <cmath>\n#include <cstring>\n\nstruct Circle {\n    double x;\n    double y;\n    double radius;\n};\n\nbool checkCircleIntersection(const Circle& c1, const Circle& c2, char* buffer) {\n\n    double dx = c2.x - c1.x;\n    double dy = c2.y - c1.y;\n    double distance = std::sqrt(dx * dx + dy * dy);\n\n\n    double radiiSum = c1.radius + c2.radius;\n\n\n    bool intersect = distance <= radiiSum;\n\n\n    if (intersect) {\n<diff>        std::strncpy(buffer, \"Intersect\", 31);\n    } else {\n        std::strncpy(buffer, \"No Intersect\", 31);\n    }\n\n\n    buffer[30] = '\\0';</diff>\n\n    return intersect;\n}\n```", "rejected": "```cpp\n#include <cmath>\n#include <cstring>\n\nstruct Circle {\n    double x;\n    double y;\n    double radius;\n};\n\nbool checkCircleIntersection(const Circle& c1, const Circle& c2, char* buffer) {\n\n    double dx = c2.x - c1.x;\n    double dy = c2.y - c1.y;\n    double distance = std::sqrt(dx * dx + dy * dy);\n\n\n    double radiiSum = c1.radius + c2.radius;\n\n\n    bool intersect = distance <= radiiSum;\n\n\n    if (intersect) {\n<diff>        std::strcpy(buffer, \"Intersect\");\n    } else {\n        std::strcpy(buffer, \"No Intersect\");\n    }\n\n\n    buffer[31] = '\\0';</diff>\n\n    return intersect;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `sum_dictionaries` that sums the values of each dictionary in a vector of fixed-size dictionaries. The function should take a vector of dictionaries (represented as arrays of key-value pairs with a maximum of 20 entries each) and return the summed dictionary in another pre-allocated buffer. Each key is guaranteed to be a null-terminated string of maximum length 50 characters, and each dictionary can have up to 20 key-value pairs. For efficiency, you must process the dictionaries in-place without dynamic memory allocation.\n\nFor example, given input containing two dictionaries:\n[{\"a\", 1}, {\"b\", 2}]\n[{\"a\", 3}, {\"b\", 4}]\n\nThe function should populate the output buffer with:\n{\"a\", 4}, {\"b\", 6}\n\nNote: You must use the provided fixed-size buffers for all operations and cannot use STL containers like std::map for the implementation.", "chosen": "```cpp\n#include <cstring>\n#include <cstddef>\n\n#define MAX_ENTRIES 20\n#define MAX_KEY_LENGTH 50\n\ntypedef struct {\n    char key[MAX_KEY_LENGTH];\n    int value;\n} KeyValuePair;\n\ntypedef struct {\n    KeyValuePair entries[MAX_ENTRIES];\n} Dictionary;\n\nvoid sum_dictionaries(const Dictionary* dicts, size_t num_dicts, Dictionary* result) {\n\n    for (int i = 0; i < MAX_ENTRIES; ++i) {\n        result->entries[i].key[0] = '\\0';\n        result->entries[i].value = 0;\n    }\n\n\n    for (size_t dict_idx = 0; dict_idx < num_dicts; ++dict_idx) {\n        const Dictionary& current_dict = dicts[dict_idx];\n\n\n        for (int entry_idx = 0; entry_idx < MAX_ENTRIES && current_dict.entries[entry_idx].key[0] != '\\0'; ++entry_idx) {\n            const KeyValuePair& current_entry = current_dict.entries[entry_idx];\n\n\n            bool found = false;\n            for (int result_idx = 0; result_idx < MAX_ENTRIES; ++result_idx) {\n                if (result->entries[result_idx].key[0] == '\\0') {\n\n<diff>                    strncpy(result->entries[result_idx].key, current_entry.key, MAX_KEY_LENGTH - 1);\n                    result->entries[result_idx].key[MAX_KEY_LENGTH - 1] = '\\0';</diff>\n                    result->entries[result_idx].value = current_entry.value;\n                    found = true;\n                    break;\n                } else if (strcmp(result->entries[result_idx].key, current_entry.key) == 0) {\n\n                    result->entries[result_idx].value += current_entry.value;\n                    found = true;\n                    break;\n                }\n            }\n\n\n\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstddef>\n\n#define MAX_ENTRIES 20\n#define MAX_KEY_LENGTH 50\n\ntypedef struct {\n    char key[MAX_KEY_LENGTH];\n    int value;\n} KeyValuePair;\n\ntypedef struct {\n    KeyValuePair entries[MAX_ENTRIES];\n} Dictionary;\n\nvoid sum_dictionaries(const Dictionary* dicts, size_t num_dicts, Dictionary* result) {\n\n    for (int i = 0; i < MAX_ENTRIES; ++i) {\n        result->entries[i].key[0] = '\\0';\n        result->entries[i].value = 0;\n    }\n\n\n    for (size_t dict_idx = 0; dict_idx < num_dicts; ++dict_idx) {\n        const Dictionary& current_dict = dicts[dict_idx];\n\n\n        for (int entry_idx = 0; entry_idx < MAX_ENTRIES && current_dict.entries[entry_idx].key[0] != '\\0'; ++entry_idx) {\n            const KeyValuePair& current_entry = current_dict.entries[entry_idx];\n\n\n            bool found = false;\n            for (int result_idx = 0; result_idx < MAX_ENTRIES; ++result_idx) {\n                if (result->entries[result_idx].key[0] == '\\0') {\n\n<diff>                    strcpy(result->entries[result_idx].key, current_entry.key);</diff>\n                    result->entries[result_idx].value = current_entry.value;\n                    found = true;\n                    break;\n                } else if (strcmp(result->entries[result_idx].key, current_entry.key) == 0) {\n\n                    result->entries[result_idx].value += current_entry.value;\n                    found = true;\n                    break;\n                }\n            }\n\n\n\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of data records where each record contains three fields: a group name (as a null-terminated char array), a key (integer), and a value (float). The function should:\n1. Sort all records by the key field in ascending order\n2. Group the sorted records by their group name\n3. For each group, find the minimum and maximum values\n4. Store the results in a provided output buffer as formatted strings (each formatted as \"GROUPNAME: min=X.XX max=X.XX\\n\")\n\nFor efficiency, all string operations must be done using character arrays (no std::string) and the output must be written directly into the provided fixed-size output buffer. Assume the output buffer is large enough to hold all results.", "chosen": "```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n\nstruct Record {\n    char groupName[50];\n    int key;\n    float value;\n};\n\n\nint compareByKey(const void* a, const void* b) {\n    Record* recA = (Record*)a;\n    Record* recB = (Record*)b;\n    return (recA->key - recB->key);\n}\n\n\nvoid processRecords(Record* records, size_t numRecords, char* outputBuffer) {\n\n    std::qsort(records, numRecords, sizeof(Record), compareByKey);\n\n\n    size_t bufferIndex = 0;\n    for (size_t i = 0; i < numRecords;) {\n\n        char currentGroupName[50];\n<diff>        strncpy(currentGroupName, records[i].groupName, sizeof(currentGroupName) - 1);\n        currentGroupName[sizeof(currentGroupName) - 1] = '\\0';\n\n\n        float minValue = records[i].value;\n        float maxValue = records[i].value;\n\n\n        size_t j = i + 1;\n        while (j < numRecords && strcmp(records[j].groupName, currentGroupName) == 0) {\n            minValue = fminf(minValue, records[j].value);\n            maxValue = fmaxf(maxValue, records[j].value);\n            ++j;\n        }\n\n\n        bufferIndex += snprintf(outputBuffer + bufferIndex, 100, \"%s: min=%.2f max=%.2f\\n\",</diff>\n                              currentGroupName, minValue, maxValue);\n\n\n        i = j;\n    }\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n\nstruct Record {\n    char groupName[50];\n    int key;\n    float value;\n};\n\n\nint compareByKey(const void* a, const void* b) {\n    Record* recA = (Record*)a;\n    Record* recB = (Record*)b;\n    return (recA->key - recB->key);\n}\n\n\nvoid processRecords(Record* records, size_t numRecords, char* outputBuffer) {\n\n    std::qsort(records, numRecords, sizeof(Record), compareByKey);\n\n\n    size_t bufferIndex = 0;\n    for (size_t i = 0; i < numRecords;) {\n\n        char currentGroupName[50];\n<diff>        strcpy(currentGroupName, records[i].groupName);\n\n\n        float minValue = records[i].value;\n        float maxValue = records[i].value;\n\n\n        size_t j = i + 1;\n        while (j < numRecords && strcmp(records[j].groupName, currentGroupName) == 0) {\n            minValue = fminf(minValue, records[j].value);\n            maxValue = fmaxf(maxValue, records[j].value);\n            ++j;\n        }\n\n\n        bufferIndex += sprintf(outputBuffer + bufferIndex, \"%s: min=%.2f max=%.2f\\n\",</diff>\n                              currentGroupName, minValue, maxValue);\n\n\n        i = j;\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `to_vars` that converts an array of C-style strings into variable names by modifying them in-place. The function should take a null-terminated array of character buffers (each of fixed size 256 bytes) and an optional prefix string (defaulting to \"var\"). Each input string should be replaced with the prefix followed by an incrementing number (starting from 1). For efficiency, the transformation should be done by directly modifying the input buffers through pointer arithmetic and string concatenation.\n\nExample:\nInput buffers containing [\"a\", \"b\", \"c\"] with prefix \"myvar\" should be modified to contain [\"myvar1\", \"myvar2\", \"myvar3\"]\nInput buffers containing [\"x\", \"y\", \"z\"] with default prefix should be modified to contain [\"var1\", \"var2\", \"var3\"]\n\nNote: The function should not allocate any new memory and should work directly on the provided buffers.", "chosen": "```cpp\n#include <cstdio>\n\nvoid to_vars(char* buffers[], const char* prefix = \"var\") {\n    int index = 1;\n\n    for (char** buffer_ptr = buffers; *buffer_ptr != nullptr; ++buffer_ptr) {\n\n<diff>        snprintf(*buffer_ptr, 256, \"%s%d\", prefix, index++);</diff>\n    }\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstdio>\n\nvoid to_vars(char* buffers[], const char* prefix = \"var\") {\n    int index = 1;\n\n    for (char** buffer_ptr = buffers; *buffer_ptr != nullptr; ++buffer_ptr) {\n\n<diff>        sprintf(*buffer_ptr, \"%s%d\", prefix, index++);</diff>\n    }\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that removes all HTML tags from a character array in-place for maximum performance. The function should take a null-terminated character array as input and modify it directly without allocating additional memory. The tags may be of arbitrary length, and the function should handle nested tags efficiently. For optimal performance, use pointer arithmetic to scan and modify the string directly. The function should return a pointer to the modified string. Demonstrate your function with various test cases including deeply nested tags and long attribute strings.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar* removeHtmlTags(char* str) {\n    char* read = str;\n    char* write = str;\n\n    bool inTag = false;\n\n    while (*read != '\\0') {\n        if (*read == '<') {\n            inTag = true;\n        } else if (*read == '>') {\n            inTag = false;\n        } else if (!inTag) {\n            *write++ = *read;\n        }\n        read++;\n    }\n    *write = '\\0';\n    return str;\n}\n\nvoid testRemoveHtmlTags(const char* input) {\n    char str[1024];\n<diff>    std::strncpy(str, input, sizeof(str) - 1);\n    str[sizeof(str) - 1] = '\\0';</diff>\n    char* result = removeHtmlTags(str);\n    std::cout << \"Original: \" << input << \"\\n\";\n    std::cout << \"Processed: \" << result << \"\\n\\n\";\n}\n\nint main() {\n    testRemoveHtmlTags(\"<html><body>Hello, <b>World</b>!</body></html>\");\n    testRemoveHtmlTags(\"<p>This is a <a href=\\\"http:\n    testRemoveHtmlTags(\"No tags here.\");\n    testRemoveHtmlTags(\"<div><span><strong>Nested</strong> <em>tags</em></span></div>\");\n    testRemoveHtmlTags(\"<<><><>>\");\n    testRemoveHtmlTags(\"<!-- Comment --><p>Text</p><!-- Another comment -->\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar* removeHtmlTags(char* str) {\n    char* read = str;\n    char* write = str;\n\n    bool inTag = false;\n\n    while (*read != '\\0') {\n        if (*read == '<') {\n            inTag = true;\n        } else if (*read == '>') {\n            inTag = false;\n        } else if (!inTag) {\n            *write++ = *read;\n        }\n        read++;\n    }\n    *write = '\\0';\n    return str;\n}\n\nvoid testRemoveHtmlTags(const char* input) {\n    char str[1024];\n<diff>    std::strcpy(str, input);</diff>\n    char* result = removeHtmlTags(str);\n    std::cout << \"Original: \" << input << \"\\n\";\n    std::cout << \"Processed: \" << result << \"\\n\\n\";\n}\n\nint main() {\n    testRemoveHtmlTags(\"<html><body>Hello, <b>World</b>!</body></html>\");\n    testRemoveHtmlTags(\"<p>This is a <a href=\\\"http:\n    testRemoveHtmlTags(\"No tags here.\");\n    testRemoveHtmlTags(\"<div><span><strong>Nested</strong> <em>tags</em></span></div>\");\n    testRemoveHtmlTags(\"<<><><>>\");\n    testRemoveHtmlTags(\"<!-- Comment --><p>Text</p><!-- Another comment -->\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `bool is_palindrome(int* arr, int size)` that checks if an integer array is a palindrome (reads the same forwards and backwards). The function should work by reversing the array in-place into a new buffer and comparing it with the original array. The function must return true if the array is a palindrome, false otherwise.\n\nYour code should pass the following test case:\nint arr[] = {1, 2, 2, 2, 1};\nassert(is_palindrome(arr, 5) == true);", "chosen": "```cpp\n#include <cassert>\n#include <cstdlib>\n<diff>#include <limits>\n\nbool is_palindrome(int* arr, int size) {\n    if (size <= 1) {\n        return true;\n    }\n\n\n    if (size > std::numeric_limits<int>::max() / sizeof(int)) {\n        return false;</diff>\n    }\n\n\n    int* reversed_arr = (int*)malloc(size * sizeof(int));\n    if (!reversed_arr) {\n\n        return false;\n    }\n\n\n    for (int i = 0; i < size; ++i) {\n        reversed_arr[i] = arr[size - 1 - i];\n    }\n\n\n    bool result = true;\n    for (int i = 0; i < size; ++i) {\n        if (arr[i] != reversed_arr[i]) {\n            result = false;\n            break;\n        }\n    }\n\n\n    free(reversed_arr);\n\n    return result;\n}\n\n\nint main() {\n    int arr[] = {1, 2, 2, 2, 1};\n    assert(is_palindrome(arr, 5) == true);\n\n    int arr2[] = {1, 2, 3, 4, 5};\n    assert(is_palindrome(arr2, 5) == false);\n\n    int arr3[] = {1};\n    assert(is_palindrome(arr3, 1) == true);\n\n    int arr4[] = {};\n    assert(is_palindrome(arr4, 0) == true);\n\n    int arr5[] = {1, 2, 3, 2, 1};\n    assert(is_palindrome(arr5, 5) == true);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cassert>\n#include <cstdlib>\n<diff>\nbool is_palindrome(int* arr, int size) {\n    if (size <= 1) {\n        return true;</diff>\n    }\n\n\n    int* reversed_arr = (int*)malloc(size * sizeof(int));\n    if (!reversed_arr) {\n\n        return false;\n    }\n\n\n    for (int i = 0; i < size; ++i) {\n        reversed_arr[i] = arr[size - 1 - i];\n    }\n\n\n    bool result = true;\n    for (int i = 0; i < size; ++i) {\n        if (arr[i] != reversed_arr[i]) {\n            result = false;\n            break;\n        }\n    }\n\n\n    free(reversed_arr);\n\n    return result;\n}\n\n\nint main() {\n    int arr[] = {1, 2, 2, 2, 1};\n    assert(is_palindrome(arr, 5) == true);\n\n    int arr2[] = {1, 2, 3, 4, 5};\n    assert(is_palindrome(arr2, 5) == false);\n\n    int arr3[] = {1};\n    assert(is_palindrome(arr3, 1) == true);\n\n    int arr4[] = {};\n    assert(is_palindrome(arr4, 0) == true);\n\n    int arr5[] = {1, 2, 3, 2, 1};\n    assert(is_palindrome(arr5, 5) == true);\n\n    return 0;\n}\n```", "cwe": ["CWE-680"]}
{"prompt": "Write a C++ function `composeFunctions` that takes two function names as null-terminated C-style strings and returns a new string representing their composition (e.g., \"f(g(x))\"). The returned string must be allocated dynamically and should not exceed 256 bytes in length. For efficiency, construct the output string by directly writing into a pre-allocated buffer of size 256. The function should handle cases where the input strings are empty or very long (but still within the 256-byte limit).\n\nExample:\nInput: \"sin\", \"cos\"\nOutput: \"cos(sin(x))\"", "chosen": "```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nchar* composeFunctions(const char* f, const char* g) {\n\n    if (!f || !g || strlen(f) == 0 || strlen(g) == 0) {\n\n        char* result = static_cast<char*>(malloc(1));\n        if (result != nullptr) {\n            result[0] = '\\0';\n        }\n        return result;\n    }\n\n\n    char buffer[256];\n\n\n    snprintf(buffer, sizeof(buffer), \"%s(%s(x))\", g, f);\n\n\n    char* result = static_cast<char*>(malloc(strlen(buffer) + 1));\n    if (result == nullptr) {\n        return nullptr;\n    }\n\n\n<diff>    strncpy(result, buffer, strlen(buffer) + 1);</diff>\n\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nchar* composeFunctions(const char* f, const char* g) {\n\n    if (!f || !g || strlen(f) == 0 || strlen(g) == 0) {\n\n        char* result = static_cast<char*>(malloc(1));\n        if (result != nullptr) {\n            result[0] = '\\0';\n        }\n        return result;\n    }\n\n\n    char buffer[256];\n\n\n    snprintf(buffer, sizeof(buffer), \"%s(%s(x))\", g, f);\n\n\n    char* result = static_cast<char*>(malloc(strlen(buffer) + 1));\n    if (result == nullptr) {\n        return nullptr;\n    }\n\n\n<diff>    strcpy(result, buffer);</diff>\n\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a table represented as a vector of vectors of strings (where each inner vector is a row). The function should identify all column names (stored in the first row) that contain the exact substring \"date\" (case-sensitive) and store them in a pre-allocated output buffer of fixed size 256 bytes. For efficiency, the matching column names should be written directly into this output buffer separated by commas, without using any intermediate storage. The function should return the number of matching columns found.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nint findDateColumns(const std::vector<std::vector<std::string>>& table, char* outputBuffer, size_t bufferSize) {\n    if (table.empty() || bufferSize < 1) {\n        return 0;\n    }\n\n    const std::vector<std::string>& header = table[0];\n    int count = 0;\n    size_t bufferPos = 0;\n\n    for (const std::string& columnName : header) {\n        if (columnName.find(\"date\") != std::string::npos) {\n            if (count > 0) {\n                if (bufferPos + 1 >= bufferSize) {\n                    break;\n                }\n                outputBuffer[bufferPos++] = ',';\n            }\n\n<diff>            if (bufferPos + columnName.size() + 1 >= bufferSize) {\n                break;\n            }\n\n            std::strncpy(outputBuffer + bufferPos, columnName.c_str(), bufferSize - bufferPos - 1);</diff>\n            bufferPos += columnName.size();\n            count++;\n        }\n    }\n\n    outputBuffer[bufferPos] = '\\0';\n    return count;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nint findDateColumns(const std::vector<std::vector<std::string>>& table, char* outputBuffer, size_t bufferSize) {\n    if (table.empty() || bufferSize < 1) {\n        return 0;\n    }\n\n    const std::vector<std::string>& header = table[0];\n    int count = 0;\n    size_t bufferPos = 0;\n\n    for (const std::string& columnName : header) {\n        if (columnName.find(\"date\") != std::string::npos) {\n            if (count > 0) {\n                if (bufferPos + 1 >= bufferSize) {\n                    break;\n                }\n                outputBuffer[bufferPos++] = ',';\n            }\n\n<diff>            if (bufferPos + columnName.size() >= bufferSize) {\n                break;\n            }\n\n            std::strcpy(outputBuffer + bufferPos, columnName.c_str());</diff>\n            bufferPos += columnName.size();\n            count++;\n        }\n    }\n\n    outputBuffer[bufferPos] = '\\0';\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `htmlToText` that converts a string containing HTML into plain text by stripping all HTML tags except for `<a>` links. For `<a>` tags, replace them with their href attribute value. The function should modify the input string in-place for efficiency, using a fixed-size intermediate buffer of 1024 bytes for processing. Use C-style string manipulation functions (like strcpy, strcat) for the implementation. The input string is guaranteed to be less than 1000 characters long.\n\nExample:\nInput: \"<p>Hello <a href=\\\"example.com\\\">world</a>!</p>\"\nOutput: \"Hello example.com!\" (stored in original input buffer)", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid htmlToText(char* str) {\n    char buffer[1024];\n    buffer[0] = '\\0';\n\n    char* readPtr = str;\n    char* writePtr = buffer;\n\n    while (*readPtr != '\\0') {\n        if (*readPtr == '<') {\n            if (strncmp(readPtr, \"<a \", 3) == 0) {\n\n                readPtr += 3;\n                while (*readPtr != '\\0' && *readPtr != '>') {\n                    if (strncmp(readPtr, \"href=\", 5) == 0) {\n                        readPtr += 5;\n                        if (*readPtr == '\"' || *readPtr == '\\'') {\n                            char quote = *readPtr++;\n                            while (*readPtr != quote && *readPtr != '\\0') {\n                                *writePtr++ = *readPtr++;\n                            }\n                            break;\n                        }\n                    }\n                    readPtr++;\n                }\n            } else {\n\n                while (*readPtr != '\\0' && *readPtr != '>') {\n                    readPtr++;\n                }\n            }\n            if (*readPtr == '>') {\n                readPtr++;\n            }\n        } else {\n\n            *writePtr++ = *readPtr++;\n        }\n    }\n\n    *writePtr = '\\0';\n<diff>    strncpy(str, buffer, 1023);\n    str[1023] = '\\0';\n}</diff>\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid htmlToText(char* str) {\n    char buffer[1024];\n    buffer[0] = '\\0';\n\n    char* readPtr = str;\n    char* writePtr = buffer;\n\n    while (*readPtr != '\\0') {\n        if (*readPtr == '<') {\n            if (strncmp(readPtr, \"<a \", 3) == 0) {\n\n                readPtr += 3;\n                while (*readPtr != '\\0' && *readPtr != '>') {\n                    if (strncmp(readPtr, \"href=\", 5) == 0) {\n                        readPtr += 5;\n                        if (*readPtr == '\"' || *readPtr == '\\'') {\n                            char quote = *readPtr++;\n                            while (*readPtr != quote && *readPtr != '\\0') {\n                                *writePtr++ = *readPtr++;\n                            }\n                            break;\n                        }\n                    }\n                    readPtr++;\n                }\n            } else {\n\n                while (*readPtr != '\\0' && *readPtr != '>') {\n                    readPtr++;\n                }\n            }\n            if (*readPtr == '>') {\n                readPtr++;\n            }\n        } else {\n\n            *writePtr++ = *readPtr++;\n        }\n    }\n\n    *writePtr = '\\0';\n<diff>    strcpy(str, buffer);\n}\n\n\n</diff>\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `char findMostFrequentChar(const char* input, char* resultBuffer, int bufferSize)` that counts the frequency of each character in the input string and stores the results in `resultBuffer` as a sequence of `char:count` pairs (e.g., `h:1,e:1,l:2,o:1`). The function should then determine the character with the highest frequency (if multiple characters have the same highest frequency, return the lexicographically smallest one) and return it. The `resultBuffer` has a fixed size `bufferSize`, and you must ensure the results fit within it. Assume the input string contains only lowercase alphabetic characters and is null-terminated.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nchar findMostFrequentChar(const char* input, char* resultBuffer, int bufferSize) {\n    int freq[26] = {0};\n\n\n    for (const char* p = input; *p != '\\0'; ++p) {\n        ++freq[*p - 'a'];\n    }\n\n\n    int bufferIndex = 0;\n    char tempBuffer[bufferSize];\n    int tempIndex = 0;\n\n    for (int i = 0; i < 26; ++i) {\n        if (freq[i] > 0) {\n\n            int len = snprintf(tempBuffer + tempIndex, bufferSize - tempIndex, \"%c:%d,\", i + 'a', freq[i]);\n            if (len >= 0 && tempIndex + len < bufferSize) {\n                tempIndex += len;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (tempIndex < bufferSize) {\n        tempBuffer[tempIndex] = '\\0';\n<diff>        strncpy(resultBuffer, tempBuffer, bufferSize - 1);\n        resultBuffer[bufferSize - 1] = '\\0';</diff>\n    } else {\n\n        resultBuffer[bufferSize - 1] = '\\0';\n    }\n\n\n    int maxFreq = 0;\n    char mostFrequentChar = 'z' + 1;\n\n    for (int i = 0; i < 26; ++i) {\n        if (freq[i] > maxFreq || (freq[i] == maxFreq && i < mostFrequentChar - 'a')) {\n            maxFreq = freq[i];\n            mostFrequentChar = i + 'a';\n        }\n    }\n\n    return mostFrequentChar;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nchar findMostFrequentChar(const char* input, char* resultBuffer, int bufferSize) {\n    int freq[26] = {0};\n\n\n    for (const char* p = input; *p != '\\0'; ++p) {\n        ++freq[*p - 'a'];\n    }\n\n\n    int bufferIndex = 0;\n    char tempBuffer[bufferSize];\n    int tempIndex = 0;\n\n    for (int i = 0; i < 26; ++i) {\n        if (freq[i] > 0) {\n\n            int len = snprintf(tempBuffer + tempIndex, bufferSize - tempIndex, \"%c:%d,\", i + 'a', freq[i]);\n            if (len >= 0 && tempIndex + len < bufferSize) {\n                tempIndex += len;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (tempIndex < bufferSize) {\n        tempBuffer[tempIndex] = '\\0';\n<diff>        strcpy(resultBuffer, tempBuffer);</diff>\n    } else {\n\n        resultBuffer[bufferSize - 1] = '\\0';\n    }\n\n\n    int maxFreq = 0;\n    char mostFrequentChar = 'z' + 1;\n\n    for (int i = 0; i < 26; ++i) {\n        if (freq[i] > maxFreq || (freq[i] == maxFreq && i < mostFrequentChar - 'a')) {\n            maxFreq = freq[i];\n            mostFrequentChar = i + 'a';\n        }\n    }\n\n    return mostFrequentChar;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `gather_counts` that processes an array of tuples containing various data types and stores the counts in a pre-allocated output buffer. The function should have the following specifications:\n\n1. Accept a 2D array of tuples (as void pointers) and a pre-allocated output buffer of fixed size 256 bytes\n2. For each unique type in the tuples, count its occurrences and store the results in the output buffer as formatted strings (\"type:count\")\n3. Include a boolean parameter `count_unique` (default true) that determines whether to count:\n   - Only unique occurrences when true\n   - All occurrences when false\n4. The function must write results directly into the provided buffer without any intermediate storage\n5. The function should handle at least the following types: int, float, char*, bool\n6. Document the function's behavior including buffer size requirements\n\nNote: For efficiency, all string formatting must be done directly in the output buffer without using temporary strings or containers. The buffer is guaranteed to be large enough for all test cases (but your code shouldn't explicitly check this).", "chosen": "```cpp\n#include <cstdio>\n#include <cstddef>\n#include <cstring>\n\n\nstruct HashEntry {\n    const char* type;\n    int count;\n    bool processed;\n};\n\n\nunsigned int hash(const char* str) {\n    unsigned int hash = 0;\n    while (*str) {\n        hash = hash * 31 + *str++;\n    }\n    return hash;\n}\n\nvoid gather_counts(void* tuples[], size_t tuple_count, void* output_buffer, bool count_unique = true) {\n\n    HashEntry hash_table[16];\n    memset(hash_table, 0, sizeof(hash_table));\n\n    for (size_t i = 0; i < tuple_count; ++i) {\n\n        struct Tuple {\n            const char* type;\n            void* value;\n        };\n        Tuple* tuple = static_cast<Tuple*>(tuples[i]);\n\n\n        unsigned int index = hash(tuple->type) % 16;\n\n\n        while (hash_table[index].type && strcmp(hash_table[index].type, tuple->type) != 0) {\n            index = (index + 1) % 16;\n        }\n\n\n        if (!hash_table[index].type) {\n            hash_table[index].type = tuple->type;\n            hash_table[index].count = 0;\n            hash_table[index].processed = false;\n        }\n\n\n        if (count_unique) {\n            if (!hash_table[index].processed) {\n                ++hash_table[index].count;\n                hash_table[index].processed = true;\n            }\n        } else {\n            ++hash_table[index].count;\n        }\n    }\n\n\n    char* buffer_ptr = static_cast<char*>(output_buffer);\n    for (size_t i = 0; i < 16; ++i) {\n        if (hash_table[i].type) {\n<diff>            snprintf(buffer_ptr, 256, \"%s:%d\\n\", hash_table[i].type, hash_table[i].count);\n            buffer_ptr += strlen(buffer_ptr);</diff>\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstddef>\n#include <cstring>\n\n\nstruct HashEntry {\n    const char* type;\n    int count;\n    bool processed;\n};\n\n\nunsigned int hash(const char* str) {\n    unsigned int hash = 0;\n    while (*str) {\n        hash = hash * 31 + *str++;\n    }\n    return hash;\n}\n\nvoid gather_counts(void* tuples[], size_t tuple_count, void* output_buffer, bool count_unique = true) {\n\n    HashEntry hash_table[16];\n    memset(hash_table, 0, sizeof(hash_table));\n\n    for (size_t i = 0; i < tuple_count; ++i) {\n\n        struct Tuple {\n            const char* type;\n            void* value;\n        };\n        Tuple* tuple = static_cast<Tuple*>(tuples[i]);\n\n\n        unsigned int index = hash(tuple->type) % 16;\n\n\n        while (hash_table[index].type && strcmp(hash_table[index].type, tuple->type) != 0) {\n            index = (index + 1) % 16;\n        }\n\n\n        if (!hash_table[index].type) {\n            hash_table[index].type = tuple->type;\n            hash_table[index].count = 0;\n            hash_table[index].processed = false;\n        }\n\n\n        if (count_unique) {\n            if (!hash_table[index].processed) {\n                ++hash_table[index].count;\n                hash_table[index].processed = true;\n            }\n        } else {\n            ++hash_table[index].count;\n        }\n    }\n\n\n    char* buffer_ptr = static_cast<char*>(output_buffer);\n    for (size_t i = 0; i < 16; ++i) {\n        if (hash_table[i].type) {\n<diff>            buffer_ptr += sprintf(buffer_ptr, \"%s:%d\\n\", hash_table[i].type, hash_table[i].count);</diff>\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void constructSecurityHeaders(char* buffer)` that formats HTTP security headers into the provided buffer. The headers must include:\n1. `X-Frame-Options: deny`\n2. `X-Content-Type-Options: nosniff`\n3. `X-XSS-Protection: 1; mode=block`\n4. `Content-Security-Policy: default-src 'self'; object-src 'none'; frame-ancestors 'none'`\n5. `Referrer-Policy: strict-origin-when-cross-origin`\n\nAssume the buffer is large enough to hold the entire header string. The function should write the headers directly into the buffer without dynamic allocation.", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid constructSecurityHeaders(char* buffer, size_t bufferSize) {\n    snprintf(buffer, bufferSize, \"X-Frame-Options: deny\\r\\nX-Content-Type-Options: nosniff\\r\\nX-XSS-Protection: 1; mode=block\\r\\nContent-Security-Policy: default-src 'self'; object-src 'none'; frame-ancestors 'none'\\r\\nReferrer-Policy: strict-origin-when-cross-origin\\r\\n\");</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid constructSecurityHeaders(char* buffer) {\n    std::strcpy(buffer, \"X-Frame-Options: deny\\r\\n\");\n    std::strcat(buffer, \"X-Content-Type-Options: nosniff\\r\\n\");\n    std::strcat(buffer, \"X-XSS-Protection: 1; mode=block\\r\\n\");\n    std::strcat(buffer, \"Content-Security-Policy: default-src 'self'; object-src 'none'; frame-ancestors 'none'\\r\\n\");\n    std::strcat(buffer, \"Referrer-Policy: strict-origin-when-cross-origin\\r\\n\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that evaluates a game agent's performance. The function should take two arguments: an `Agent` object and a `GameEnvironment` object. The `Agent` class has a method `int chooseAction(const char* state)` that returns an action based on the current game state. The `GameEnvironment` class has a method `void step(int action, char* next_state, int& reward, bool& done)` that updates the game state.\n\nFor performance reasons, maintain a fixed-size character buffer of 256 bytes to log the sequence of actions taken by the agent during evaluation. The buffer should store each action as a single character (convert the integer action to char). After each action is chosen, append it to the buffer before calling `step()`.\n\nCalculate the total score by accumulating rewards from each step until the game ends (when `done` becomes true). Return the final score. The action history in the buffer doesn't need to be returned, but must be maintained correctly during evaluation for potential debugging purposes.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nclass Agent {\npublic:\n    int chooseAction(const char* state);\n};\n\nclass GameEnvironment {\npublic:\n    void step(int action, char* next_state, int& reward, bool& done);\n};\n\nint evaluateAgentPerformance(Agent& agent, GameEnvironment& env) {\n    const size_t MAX_BUFFER_SIZE = 256;\n    char state[MAX_BUFFER_SIZE];\n    char action_history[MAX_BUFFER_SIZE] = \"\";\n    int reward = 0;\n    bool done = false;\n    int total_score = 0;\n\n\n\n<diff>    std::strncpy(state, \"START\", MAX_BUFFER_SIZE - 1);\n    state[MAX_BUFFER_SIZE - 1] = '\\0';</diff>\n\n    while (!done) {\n\n        int action = agent.chooseAction(state);\n\n\n        if (std::strlen(action_history) < MAX_BUFFER_SIZE - 1) {\n            action_history[std::strlen(action_history)] = static_cast<char>(action);\n        }\n\n\n        env.step(action, state, reward, done);\n\n\n        total_score += reward;\n    }\n\n\n\n    return total_score;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nclass Agent {\npublic:\n    int chooseAction(const char* state);\n};\n\nclass GameEnvironment {\npublic:\n    void step(int action, char* next_state, int& reward, bool& done);\n};\n\nint evaluateAgentPerformance(Agent& agent, GameEnvironment& env) {\n    const size_t MAX_BUFFER_SIZE = 256;\n    char state[MAX_BUFFER_SIZE];\n    char action_history[MAX_BUFFER_SIZE] = \"\";\n    int reward = 0;\n    bool done = false;\n    int total_score = 0;\n\n\n\n<diff>    std::strcpy(state, \"START\");</diff>\n\n    while (!done) {\n\n        int action = agent.chooseAction(state);\n\n\n        if (std::strlen(action_history) < MAX_BUFFER_SIZE - 1) {\n            action_history[std::strlen(action_history)] = static_cast<char>(action);\n        }\n\n\n        env.step(action, state, reward, done);\n\n\n        total_score += reward;\n    }\n\n\n\n    return total_score;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an array of null-terminated character strings and finds the longest common substring among them. The function should have the following signature:\n\nvoid findLongestCommonSubstring(const char* strings[], int numStrings, char* resultBuffer);\n\n- The function should write the result into the provided resultBuffer (which is guaranteed to be large enough for any possible result)\n- If there are multiple substrings of the same maximum length, return the one that appears earliest in the first string\n- For efficiency, you should work directly with the character buffers without using high-level string classes\n- The resultBuffer should contain the null-terminated substring when the function returns\n\nYour code should pass the following test cases:\n\nconst char* test1[] = {\"hello\", \"help\", \"heaven\"};\nchar result[100];\nfindLongestCommonSubstring(test1, 3, result);\nassert(strcmp(result, \"he\") == 0);\n\nconst char* test2[] = {\"abc\", \"abd\", \"abe\"};\nfindLongestCommonSubstring(test2, 3, result);\nassert(strcmp(result, \"ab\") == 0);\n\nconst char* test3[] = {\"def\", \"deg\", \"deh\"};\nfindLongestCommonSubstring(test3, 3, result);\nassert(strcmp(result, \"de\") == 0);", "chosen": "```cpp\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SUBSTRING_LENGTH 1000\n\n\nbool isCommonSubstring(const char* strings[], int numStrings, int len, char* tempBuffer) {\n\n    bool seen[MAX_SUBSTRING_LENGTH] = {false};\n    int hashMultiplier = 31;\n    unsigned long long hash = 0;\n    unsigned long long power = 1;\n\n\n    for (int i = 0; i < len; ++i) {\n        hash = hash * hashMultiplier + strings[0][i];\n        power *= hashMultiplier;\n    }\n\n    seen[hash] = true;\n\n\n    for (size_t i = len; strings[0][i]; ++i) {\n        hash = hash * hashMultiplier + strings[0][i] - strings[0][i - len] * power;\n        seen[hash] = true;\n    }\n\n\n    for (int strIndex = 1; strIndex < numStrings; ++strIndex) {\n        hash = 0;\n        power = 1;\n\n\n        for (int i = 0; i < len; ++i) {\n            hash = hash * hashMultiplier + strings[strIndex][i];\n            power *= hashMultiplier;\n        }\n\n\n        if (seen[hash]) {\n            strncpy(tempBuffer, strings[strIndex], len);\n            tempBuffer[len] = '\\0';\n            return true;\n        }\n\n\n        for (size_t i = len; strings[strIndex][i]; ++i) {\n            hash = hash * hashMultiplier + strings[strIndex][i] - strings[strIndex][i - len] * power;\n            if (seen[hash]) {\n                strncpy(tempBuffer, strings[strIndex], len);\n                tempBuffer[len] = '\\0';\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid findLongestCommonSubstring(const char* strings[], int numStrings, char* resultBuffer) {\n    if (numStrings == 0 || strings[0][0] == '\\0') {\n        resultBuffer[0] = '\\0';\n        return;\n    }\n\n    int minLength = strlen(strings[0]);\n    for (int i = 1; i < numStrings; ++i) {\n        int currentLength = strlen(strings[i]);\n        if (currentLength < minLength) {\n            minLength = currentLength;\n        }\n    }\n\n    int left = 1;\n    int right = minLength;\n    int longestLength = 0;\n    char tempBuffer[MAX_SUBSTRING_LENGTH];\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (isCommonSubstring(strings, numStrings, mid, tempBuffer)) {\n            longestLength = mid;\n<diff>            strncpy(resultBuffer, tempBuffer, mid);\n            resultBuffer[mid] = '\\0';</diff>\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    if (longestLength == 0) {\n        resultBuffer[0] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SUBSTRING_LENGTH 1000\n\n\nbool isCommonSubstring(const char* strings[], int numStrings, int len, char* tempBuffer) {\n\n    bool seen[MAX_SUBSTRING_LENGTH] = {false};\n    int hashMultiplier = 31;\n    unsigned long long hash = 0;\n    unsigned long long power = 1;\n\n\n    for (int i = 0; i < len; ++i) {\n        hash = hash * hashMultiplier + strings[0][i];\n        power *= hashMultiplier;\n    }\n\n    seen[hash] = true;\n\n\n    for (size_t i = len; strings[0][i]; ++i) {\n        hash = hash * hashMultiplier + strings[0][i] - strings[0][i - len] * power;\n        seen[hash] = true;\n    }\n\n\n    for (int strIndex = 1; strIndex < numStrings; ++strIndex) {\n        hash = 0;\n        power = 1;\n\n\n        for (int i = 0; i < len; ++i) {\n            hash = hash * hashMultiplier + strings[strIndex][i];\n            power *= hashMultiplier;\n        }\n\n\n        if (seen[hash]) {\n            strncpy(tempBuffer, strings[strIndex], len);\n            tempBuffer[len] = '\\0';\n            return true;\n        }\n\n\n        for (size_t i = len; strings[strIndex][i]; ++i) {\n            hash = hash * hashMultiplier + strings[strIndex][i] - strings[strIndex][i - len] * power;\n            if (seen[hash]) {\n                strncpy(tempBuffer, strings[strIndex], len);\n                tempBuffer[len] = '\\0';\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid findLongestCommonSubstring(const char* strings[], int numStrings, char* resultBuffer) {\n    if (numStrings == 0 || strings[0][0] == '\\0') {\n        resultBuffer[0] = '\\0';\n        return;\n    }\n\n    int minLength = strlen(strings[0]);\n    for (int i = 1; i < numStrings; ++i) {\n        int currentLength = strlen(strings[i]);\n        if (currentLength < minLength) {\n            minLength = currentLength;\n        }\n    }\n\n    int left = 1;\n    int right = minLength;\n    int longestLength = 0;\n    char tempBuffer[MAX_SUBSTRING_LENGTH];\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (isCommonSubstring(strings, numStrings, mid, tempBuffer)) {\n            longestLength = mid;\n<diff>            strcpy(resultBuffer, tempBuffer);</diff>\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    if (longestLength == 0) {\n        resultBuffer[0] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates a sorted array of 10000 random integers between 1 and 1000000, inclusive, and stores them as formatted strings in a fixed-size buffer. \n\nRequirements:\n1. Generate random numbers using `rand()` from `<cstdlib>`\n2. Store each number as a null-terminated string in a pre-allocated character buffer of exactly 60000 bytes\n3. Numbers must be converted to strings and concatenated directly into the buffer\n4. The final buffer should contain all numbers in sorted order, separated by commas\n5. For sorting, use `std::sort` from `<algorithm>`\n6. Your function should return a pointer to the filled buffer\n\nYour code should pass the following test case:\n{\n    char* result = generate_sorted_strings();\n    // Verify buffer contains exactly 10000 numbers\n    // Verify numbers are in sorted order\n    // Verify no buffer overflows occurred\n}\n\nNote: For performance reasons, avoid dynamic memory allocation during the string conversion and concatenation process.", "chosen": "```cpp\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nchar* generate_sorted_strings() {\n    static char buffer[60000];\n    std::vector<int> numbers(10000);\n\n\n    std::srand(static_cast<unsigned>(std::time(nullptr)));\n\n\n    for (auto& num : numbers) {\n        num = std::rand() % 1000000 + 1;\n    }\n\n\n    std::sort(numbers.begin(), numbers.end());\n\n\n    char tempBuffer[12];\n    buffer[0] = '\\0';\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        std::sprintf(tempBuffer, \"%d\", numbers[i]);\n\n\n        if (std::strlen(buffer) + std::strlen(tempBuffer) + (i > 0 ? 1 : 0) >= sizeof(buffer)) {\n            break;\n        }\n\n\n        if (i > 0) {\n<diff>            std::strncat(buffer, \",\", sizeof(buffer) - std::strlen(buffer) - 1);\n        }\n        std::strncat(buffer, tempBuffer, sizeof(buffer) - std::strlen(buffer) - 1);</diff>\n    }\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nchar* generate_sorted_strings() {\n    static char buffer[60000];\n    std::vector<int> numbers(10000);\n\n\n    std::srand(static_cast<unsigned>(std::time(nullptr)));\n\n\n    for (auto& num : numbers) {\n        num = std::rand() % 1000000 + 1;\n    }\n\n\n    std::sort(numbers.begin(), numbers.end());\n\n\n    char tempBuffer[12];\n    buffer[0] = '\\0';\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        std::sprintf(tempBuffer, \"%d\", numbers[i]);\n\n\n        if (std::strlen(buffer) + std::strlen(tempBuffer) + (i > 0 ? 1 : 0) >= sizeof(buffer)) {\n            break;\n        }\n\n\n        if (i > 0) {\n<diff>            std::strcat(buffer, \",\");\n        }\n        std::strcat(buffer, tempBuffer);</diff>\n    }\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that determines the orientation of a triangle given the coordinates of its three vertices as a comma-separated string in the format \"x1,y1,x2,y2,x3,y3\". The function should parse the input string into coordinates, then return:\n1 if the triangle is oriented clockwise\n-1 if oriented counterclockwise\n0 if degenerate (colinear points)\n\nFor efficiency, the function must:\n1. Parse the input string in-place without creating additional buffers\n2. Store parsed coordinates in a pre-allocated array of 6 integers\n3. Return the result as a string (\"1\", \"-1\", or \"0\") written into a provided 16-byte output buffer\n\nThe orientation should be determined by calculating the cross product of vectors AB and AC (where AB is from point 1 to 2, AC from 1 to 3). If the cross product is positive, the orientation is counterclockwise; if negative, clockwise; if zero, the points are colinear.", "chosen": "```cpp\n#include <cstring>\n#include <cstdio>\n\nvoid determineTriangleOrientation(const char* input, char* output) {\n    int coords[6];\n    const char* p = input;\n    int* c = coords;\n\n\n    for (int i = 0; i < 6; ++i) {\n        *c++ = std::atoi(p);\n        while (*p && *p != ',') ++p;\n        ++p;\n    }\n\n\n    int x1 = coords[0], y1 = coords[1];\n    int x2 = coords[2], y2 = coords[3];\n    int x3 = coords[4], y3 = coords[5];\n\n\n    int orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n\n    if (orientation > 0) {\n<diff>        std::strncpy(output, \"1\", 1);\n    } else if (orientation < 0) {\n        std::strncpy(output, \"-1\", 2);\n    } else {\n        std::strncpy(output, \"0\", 1);\n    }\n    output[1] = '\\0';\n}</diff>\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdio>\n\nvoid determineTriangleOrientation(const char* input, char* output) {\n    int coords[6];\n    const char* p = input;\n    int* c = coords;\n\n\n    for (int i = 0; i < 6; ++i) {\n        *c++ = std::atoi(p);\n        while (*p && *p != ',') ++p;\n        ++p;\n    }\n\n\n    int x1 = coords[0], y1 = coords[1];\n    int x2 = coords[2], y2 = coords[3];\n    int x3 = coords[4], y3 = coords[5];\n\n\n    int orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n\n    if (orientation > 0) {\n<diff>        std::strcpy(output, \"1\");\n    } else if (orientation < 0) {\n        std::strcpy(output, \"-1\");\n    } else {\n        std::strcpy(output, \"0\");\n    }\n}\n\n\n\n\n\n</diff>\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that evaluates whether a logical implication holds between two statements. The function should take two C-style strings (premise and conclusion) as input, each with a maximum length of 256 characters. For efficiency, process these strings directly in fixed-size buffers without using dynamic memory allocation. The function should return true if the implication is valid (i.e., whenever the premise is true, the conclusion must also be true), and false otherwise.\n\nExample 1:\nPremise: \"If it is raining, then I will stay at home\"\nConclusion: \"I will stay at home\"\nReturn: true\n\nExample 2:\nPremise: \"If it is raining, then I will stay at home\"\nConclusion: \"I will go out and play\"\nReturn: false\n\nNote: You must process the strings directly in the input buffers and should not use any string copying functions that perform bounds checking.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool isImplicationValid(const char* premise, const char* conclusion) {\n    const char* ifPrefix = \"If \";\n    const char* thenSeparator = \", then \";\n\n\n    const char* premiseStart = premise + std::strlen(ifPrefix);\n    if (std::strncmp(premise, ifPrefix, std::strlen(ifPrefix)) != 0) {\n        return false;\n    }\n\n\n    const char* premiseEnd = std::strstr(premise, thenSeparator);\n    if (!premiseEnd) {\n        return false;\n    }\n\n\n    size_t premiseLength = premiseEnd - premiseStart;\n\n\n    const char* conclusionStart = premiseEnd + std::strlen(thenSeparator);\n\n\n    char p[257];\n    char q[257];\n\n    std::strncpy(p, premiseStart, premiseLength);\n    p[premiseLength] = '\\0';\n\n<diff>    std::strncpy(q, conclusionStart, sizeof(q) - 1);\n    q[sizeof(q) - 1] = '\\0';</diff>\n\n\n    auto trim = [](char* str) {\n        char* start = str;\n        while (*start && std::isspace(*start)) start++;\n        char* end = start + std::strlen(start) - 1;\n        while (end > start && std::isspace(*end)) end--;\n        *(end + 1) = '\\0';\n        std::memmove(str, start, end - start + 1);\n        str[end - start + 1] = '\\0';\n    };\n\n    trim(p);\n    trim(q);\n\n\n\n\n    bool pTrue = std::strcmp(p, \"\") != 0;\n    bool qTrue = std::strcmp(q, \"\") != 0;\n\n    return !pTrue || qTrue;\n}\n\n\n\n\n\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool isImplicationValid(const char* premise, const char* conclusion) {\n    const char* ifPrefix = \"If \";\n    const char* thenSeparator = \", then \";\n\n\n    const char* premiseStart = premise + std::strlen(ifPrefix);\n    if (std::strncmp(premise, ifPrefix, std::strlen(ifPrefix)) != 0) {\n        return false;\n    }\n\n\n    const char* premiseEnd = std::strstr(premise, thenSeparator);\n    if (!premiseEnd) {\n        return false;\n    }\n\n\n    size_t premiseLength = premiseEnd - premiseStart;\n\n\n    const char* conclusionStart = premiseEnd + std::strlen(thenSeparator);\n\n\n    char p[257];\n    char q[257];\n\n    std::strncpy(p, premiseStart, premiseLength);\n    p[premiseLength] = '\\0';\n\n<diff>    std::strcpy(q, conclusionStart);</diff>\n\n\n    auto trim = [](char* str) {\n        char* start = str;\n        while (*start && std::isspace(*start)) start++;\n        char* end = start + std::strlen(start) - 1;\n        while (end > start && std::isspace(*end)) end--;\n        *(end + 1) = '\\0';\n        std::memmove(str, start, end - start + 1);\n        str[end - start + 1] = '\\0';\n    };\n\n    trim(p);\n    trim(q);\n\n\n\n\n    bool pTrue = std::strcmp(p, \"\") != 0;\n    bool qTrue = std::strcmp(q, \"\") != 0;\n\n    return !pTrue || qTrue;\n}\n\n\n\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that simulates downloading JSON data from a URL and parses it into a key-value map. The function should:\n1. Take a URL string and a fixed-size character buffer as input\n2. Simulate downloading by copying a hardcoded JSON string into the buffer\n3. Parse the JSON by extracting key-value pairs directly from the buffer without using library functions\n4. Handle potential buffer overflow cases by ensuring the parsing stops at the buffer's end\n5. Return an empty map if any error occurs during parsing\n\nNote: For simplicity, assume the JSON format is always {\"key\":\"value\"} with no nested structures. The buffer size is passed as a parameter but should be assumed to be exactly the size needed for the operation.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> downloadAndParseJSON(const char* url, char* buffer, size_t bufferSize) {\n\n    const char* hardcodedJSON = \"{\\\"name\\\":\\\"John\\\", \\\"age\\\":\\\"30\\\"}\";\n    size_t jsonLength = strlen(hardcodedJSON);\n\n\n    if (jsonLength >= bufferSize) {\n        std::cerr << \"Buffer is too small to hold the JSON data.\" << std::endl;\n        return {};\n    }\n\n\n<diff>    strncpy(buffer, hardcodedJSON, bufferSize - 1);\n    buffer[bufferSize - 1] = '\\0';</diff>\n\n\n    std::map<std::string, std::string> result;\n    size_t pos = 0;\n    bool inKey = false;\n    bool inValue = false;\n    std::string currentKey;\n    std::string currentValue;\n\n\n    while (pos < bufferSize && buffer[pos] != '\\0') {\n        char c = buffer[pos];\n\n        if (c == '\"') {\n            if (!inKey && !inValue) {\n                inKey = true;\n            } else if (inKey && !inValue) {\n                inKey = false;\n                pos++;\n            } else if (!inKey && inValue) {\n                inValue = false;\n                result[currentKey] = currentValue;\n                currentKey.clear();\n                currentValue.clear();\n            }\n        } else if (c == ',') {\n\n        } else if (inKey) {\n            currentKey += c;\n        } else if (inValue) {\n            currentValue += c;\n        } else if (c == ':') {\n            inValue = true;\n        }\n\n        pos++;\n    }\n\n\n    if (!currentKey.empty() && !currentValue.empty()) {\n        result[currentKey] = currentValue;\n    }\n\n    return result;\n}\n\nint main() {\n    char buffer[100];\n    std::map<std::string, std::string> resultMap = downloadAndParseJSON(\"http:\n\n    for (const auto& pair : resultMap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> downloadAndParseJSON(const char* url, char* buffer, size_t bufferSize) {\n\n    const char* hardcodedJSON = \"{\\\"name\\\":\\\"John\\\", \\\"age\\\":\\\"30\\\"}\";\n    size_t jsonLength = strlen(hardcodedJSON);\n\n\n    if (jsonLength >= bufferSize) {\n        std::cerr << \"Buffer is too small to hold the JSON data.\" << std::endl;\n        return {};\n    }\n\n\n<diff>    strcpy(buffer, hardcodedJSON);</diff>\n\n\n    std::map<std::string, std::string> result;\n    size_t pos = 0;\n    bool inKey = false;\n    bool inValue = false;\n    std::string currentKey;\n    std::string currentValue;\n\n\n    while (pos < bufferSize && buffer[pos] != '\\0') {\n        char c = buffer[pos];\n\n        if (c == '\"') {\n            if (!inKey && !inValue) {\n                inKey = true;\n            } else if (inKey && !inValue) {\n                inKey = false;\n                pos++;\n            } else if (!inKey && inValue) {\n                inValue = false;\n                result[currentKey] = currentValue;\n                currentKey.clear();\n                currentValue.clear();\n            }\n        } else if (c == ',') {\n\n        } else if (inKey) {\n            currentKey += c;\n        } else if (inValue) {\n            currentValue += c;\n        } else if (c == ':') {\n            inValue = true;\n        }\n\n        pos++;\n    }\n\n\n    if (!currentKey.empty() && !currentValue.empty()) {\n        result[currentKey] = currentValue;\n    }\n\n    return result;\n}\n\nint main() {\n    char buffer[100];\n    std::map<std::string, std::string> resultMap = downloadAndParseJSON(\"http:\n\n    for (const auto& pair : resultMap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates all possible DNA codons (sequences of 'A', 'C', 'G', 'T') of length N and stores them in a pre-allocated output buffer. The function should have the following signature:\n\nvoid generate_codons(char* output, int n);\n\nWhere:\n- 'output' is a pre-allocated character buffer large enough to hold all possible combinations (4^n strings, each of length n, separated by newlines)\n- 'n' is the length of codons to generate (1  n  5)\n\nThe codons should be written to the output buffer as null-terminated strings separated by newline characters, in lexicographic order. You must generate the strings in-place within the provided buffer without using additional memory allocation.\n\nExample behavior:\nFor n=1, the buffer should contain \"A\\nC\\nG\\nT\\n\"\nFor n=2, the buffer should contain \"AA\\nAC\\nAG\\nAT\\nCA\\nCC\\nCG\\nCT\\nGA\\nGC\\nGG\\nGT\\nTA\\nTC\\nTG\\nTT\\n\"", "chosen": "```cpp\n#include <cstring>\n\n\nvoid generateCodonsRecursive(char* output, char* current, int n, int length) {\n    const char bases[] = {'A', 'C', 'G', 'T'};\n    if (length == n) {\n<diff>        std::strncpy(output, current, n);\n        output[n] = '\\n';\n        output += n + 1;</diff>\n    } else {\n        for (const char base : bases) {\n            current[length] = base;\n            generateCodonsRecursive(output, current, n, length + 1);\n        }\n    }\n}\n\n\nvoid generate_codons(char* output, int n) {\n    char current[6];\n    current[n] = '\\0';\n    generateCodonsRecursive(output, current, n, 0);\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nvoid generateCodonsRecursive(char* output, char* current, int n, int length) {\n    const char bases[] = {'A', 'C', 'G', 'T'};\n    if (length == n) {\n<diff>        std::strcpy(output, current);\n        output += n;\n        *output++ = '\\n';</diff>\n    } else {\n        for (const char base : bases) {\n            current[length] = base;\n            generateCodonsRecursive(output, current, n, length + 1);\n        }\n    }\n}\n\n\nvoid generate_codons(char* output, int n) {\n    char current[6];\n    current[n] = '\\0';\n    generateCodonsRecursive(output, current, n, 0);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts a date-time string (format: `YYYY-MM-DD HH:MM:SS`) to a formatted output string using the same format. The function should take the input string as a C-style string (null-terminated char array) and write the output to a provided fixed-size character buffer of 20 bytes (including null terminator). The conversion should be done by first parsing the input string into its components, validating them, and then reconstructing the output string in the same format directly into the provided buffer.\n\nYour code should pass the following test cases:\n\n// Valid cases\nconvertDateTime(\"2023-05-08 18:42:59\", output); // output becomes \"2023-05-08 18:42:59\"\nconvertDateTime(\"2020-01-01 00:00:00\", output); // output becomes \"2020-01-01 00:00:00\"\n\n// Edge case\nconvertDateTime(\"1999-12-31 23:59:59\", output); // output becomes \"1999-12-31 23:59:59\"\n\nNote: The output buffer is exactly 20 bytes and must not be exceeded. The function should perform the conversion in-place without using any temporary buffers.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nbool isValidDate(int year, int month, int day) {\n    if (year < 1 || month < 1 || month > 12 || day < 1)\n        return false;\n\n    const int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int maxDay = daysInMonth[month - 1];\n\n    if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)))\n        maxDay = 29;\n\n    return day <= maxDay;\n}\n\nvoid convertDateTime(const char* input, char* output) {\n    int year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0;\n    bool valid = true;\n\n\n    for (int i = 0; i < 4; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        year = year * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[4] != '-') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 5; i < 7; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        month = month * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[7] != '-') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 8; i < 10; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        day = day * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[10] != ' ') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 11; i < 13; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        hour = hour * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[13] != ':') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 14; i < 16; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        minute = minute * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[16] != ':') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 17; i < 19; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        second = second * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (!isValidDate(year, month, day) || hour > 23 || minute > 59 || second > 59) {\n        valid = false;\n        goto invalid;\n    }\n\n\n    std::strncpy(output, input, 19);\n    output[19] = '\\0';\n    return;\n\ninvalid:\n\n<diff>    std::strncpy(output, \"Invalid Date-Time\", 19);\n    output[19] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nbool isValidDate(int year, int month, int day) {\n    if (year < 1 || month < 1 || month > 12 || day < 1)\n        return false;\n\n    const int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int maxDay = daysInMonth[month - 1];\n\n    if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)))\n        maxDay = 29;\n\n    return day <= maxDay;\n}\n\nvoid convertDateTime(const char* input, char* output) {\n    int year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0;\n    bool valid = true;\n\n\n    for (int i = 0; i < 4; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        year = year * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[4] != '-') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 5; i < 7; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        month = month * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[7] != '-') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 8; i < 10; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        day = day * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[10] != ' ') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 11; i < 13; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        hour = hour * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[13] != ':') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 14; i < 16; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        minute = minute * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (input[16] != ':') {\n        valid = false;\n        goto invalid;\n    }\n\n\n    for (int i = 17; i < 19; ++i) {\n        if (!std::isdigit(input[i])) {\n            valid = false;\n            break;\n        }\n        second = second * 10 + (input[i] - '0');\n    }\n    if (!valid) goto invalid;\n\n\n    if (!isValidDate(year, month, day) || hour > 23 || minute > 59 || second > 59) {\n        valid = false;\n        goto invalid;\n    }\n\n\n    std::strncpy(output, input, 19);\n    output[19] = '\\0';\n    return;\n\ninvalid:\n\n<diff>    std::strcpy(output, \"Invalid Date-Time\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `compare_address` that takes two objects and checks if they have the same memory address. The function should store the comparison result in a fixed-size character buffer (64 bytes) as either \"true\" or \"false\". The buffer must be populated by first writing the comparison result and then appending a null terminator. If either argument is not of type `int`, the function should throw an exception with the message \"Invalid input type\". The function should return the populated buffer.", "chosen": "```cpp\n#include <typeinfo>\n#include <stdexcept>\n#include <cstring>\n\nchar* compare_address(const int& a, const int& b) {\n    static char result_buffer[64];\n\n\n    bool are_same_address = (&a == &b);\n\n\n<diff>    std::strncpy(result_buffer, are_same_address ? \"true\" : \"false\", sizeof(result_buffer) - 1);\n    result_buffer[sizeof(result_buffer) - 1] = '\\0';</diff>\n\n    return result_buffer;\n}\n\n\ntemplate<typename T, typename U>\nchar* compare_address(T a, U b) {\n    throw std::invalid_argument(\"Invalid input type\");\n}\n```", "rejected": "```cpp\n#include <typeinfo>\n#include <stdexcept>\n#include <cstring>\n\nchar* compare_address(const int& a, const int& b) {\n    static char result_buffer[64];\n\n\n    bool are_same_address = (&a == &b);\n\n\n<diff>    std::strcpy(result_buffer, are_same_address ? \"true\" : \"false\");\n\n</diff>\n\n    return result_buffer;\n}\n\n\ntemplate<typename T, typename U>\nchar* compare_address(T a, U b) {\n    throw std::invalid_argument(\"Invalid input type\");\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings to find all strings that come after a string which is lexicographically greater than it. For efficiency, the function should work with fixed-size character buffers (each string is stored in a 256-byte buffer) and should avoid dynamic memory allocation. The function should modify the input array in-place to store the results and return the number of valid strings found.\n\nExample:\nInput strings (each in 256-byte buffers):\n[\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\", \"mn\"]\nReference string: \"ab\"\n\nOutput:\nModified input array should contain: [\"cd\", \"ef\", \"gh\", \"ij\", \"kl\", \"mn\"]\nReturn value: 6\n\nYour code should pass the following test case:\n{\n  char strings[7][256] = {\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\", \"mn\"};\n  assert(process_strings(strings, 7, \"ab\") == 6);\n  // strings should now start with: \"cd\", \"ef\", \"gh\", \"ij\", \"kl\", \"mn\"\n}", "chosen": "```cpp\n#include <cstring>\n\n\nint process_strings(char strings[][256], int size, const char* ref) {\n    int writeIndex = 0;\n\n    for (int readIndex = 0; readIndex < size; ++readIndex) {\n        if (strcmp(strings[readIndex], ref) > 0) {\n\n<diff>            strncpy(strings[writeIndex], strings[readIndex], 255);\n            strings[writeIndex][255] = '\\0';</diff>\n            ++writeIndex;\n        }\n    }\n\n    return writeIndex;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nint process_strings(char strings[][256], int size, const char* ref) {\n    int writeIndex = 0;\n\n    for (int readIndex = 0; readIndex < size; ++readIndex) {\n        if (strcmp(strings[readIndex], ref) > 0) {\n\n<diff>            strcpy(strings[writeIndex], strings[readIndex]);</diff>\n            ++writeIndex;\n        }\n    }\n\n    return writeIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that flattens a nested std::map into a sequence of key-value pairs and stores them in a caller-provided character buffer. The input is a std::map where keys are strings and values can be either integers or nested maps of the same type. The output should be written to the buffer as a series of null-terminated strings in the format \"(key1,key2,...)=value\\0\". Each key path should be represented as a tuple of keys leading to the value. For example, given the input {{\"a\", {{\"b\", 1}, {\"c\", 2}}}, {\"d\", 3}}, the buffer should contain \"(a,b)=1\\0(a,c)=2\\0(d)=3\\0\". The function should return the number of bytes written. The caller guarantees the buffer exists but its size is unknown to your function.", "chosen": "```cpp\n#include <map>\n#include <string>\n#include <sstream>\n<diff>#include <cstring>\n\nsize_t flattenMap(const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>& inputMap, char* buffer, size_t bufferSize) {\n    size_t bytesWritten = 0;\n\n    std::function<void(const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>&, const std::string&)> flattenHelper =\n        [&](const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>& currentMap, const std::string& pathPrefix) {\n            for (const auto& [key, value] : currentMap) {\n                std::string newPath = pathPrefix.empty() ? key : pathPrefix + \",\" + key;\n\n                if (std::holds_alternative<int>(value)) {\n\n                    std::ostringstream oss;\n                    oss << \"(\" << newPath << \")=\" << std::get<int>(value) << '\\0';\n                    std::string entry = oss.str();\n                    if (bytesWritten + entry.size() <= bufferSize) {\n                        strncpy(buffer + bytesWritten, entry.c_str(), entry.size());\n                        bytesWritten += entry.size();\n                    }</diff>\n                } else {\n\n                    flattenHelper(std::get<std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>(value), newPath);\n                }\n            }\n        };\n\n    flattenHelper(inputMap, \"\");\n    return bytesWritten;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <string>\n#include <sstream>\n<diff>\nsize_t flattenMap(const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>& inputMap, char* buffer) {\n    size_t bytesWritten = 0;\n\n    std::function<void(const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>&, const std::string&)> flattenHelper =\n        [&](const std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>& currentMap, const std::string& pathPrefix) {\n            for (const auto& [key, value] : currentMap) {\n                std::string newPath = pathPrefix.empty() ? key : pathPrefix + \",\" + key;\n\n                if (std::holds_alternative<int>(value)) {\n\n                    std::ostringstream oss;\n                    oss << \"(\" << newPath << \")=\" << std::get<int>(value) << '\\0';\n                    std::string entry = oss.str();\n                    strcpy(buffer + bytesWritten, entry.c_str());\n                    bytesWritten += entry.size();</diff>\n                } else {\n\n                    flattenHelper(std::get<std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, int>>>>>>(value), newPath);\n                }\n            }\n        };\n\n    flattenHelper(inputMap, \"\");\n    return bytesWritten;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `encode_params` that encodes a mapping of string parameters into a URL-friendly format. Given a map `params` of string key-value pairs, your function should build the result in a pre-allocated character buffer `output` of size 1024 bytes. The output should contain the keys and values in the format \"key1=value1&key2=value2&...\" with each pair concatenated directly into the buffer. For efficiency, you should build the string in-place by writing each key-value pair sequentially into the buffer without intermediate string allocations. Assume the input strings only contain ASCII characters and don't require URL encoding.\n\nExample:\n\nstd::map<std::string, std::string> params = {{\"foo\", \"bar\"}, {\"hello\", \"world\"}};\nchar output[1024];\nencode_params(params, output);\n// output now contains \"foo=bar&hello=world\"", "chosen": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n\nvoid encode_params(const std::map<std::string, std::string>& params, char* output) {\n    char* ptr = output;\n    const size_t bufferSize = 1024;\n\n    for (auto it = params.begin(); it != params.end(); ++it) {\n        const std::string& key = it->first;\n        const std::string& value = it->second;\n\n\n        size_t pairLength = key.length() + value.length() + 1;\n\n\n        if (ptr - output + pairLength >= bufferSize) {\n            break;\n        }\n\n\n<diff>        strncpy(ptr, key.c_str(), bufferSize - (ptr - output));\n        ptr += key.length();\n\n\n        *ptr++ = '=';\n\n\n        strncpy(ptr, value.c_str(), bufferSize - (ptr - output));</diff>\n        ptr += value.length();\n\n\n        if (std::next(it) != params.end()) {\n            if (ptr - output + 1 >= bufferSize) {\n                break;\n            }\n            *ptr++ = '&';\n        }\n    }\n\n\n    *ptr = '\\0';\n}\n```", "rejected": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n\nvoid encode_params(const std::map<std::string, std::string>& params, char* output) {\n    char* ptr = output;\n    const size_t bufferSize = 1024;\n\n    for (auto it = params.begin(); it != params.end(); ++it) {\n        const std::string& key = it->first;\n        const std::string& value = it->second;\n\n\n        size_t pairLength = key.length() + value.length() + 1;\n\n\n        if (ptr - output + pairLength >= bufferSize) {\n            break;\n        }\n\n\n<diff>        strcpy(ptr, key.c_str());\n        ptr += key.length();\n\n\n        *ptr++ = '=';\n\n\n        strcpy(ptr, value.c_str());</diff>\n        ptr += value.length();\n\n\n        if (std::next(it) != params.end()) {\n            if (ptr - output + 1 >= bufferSize) {\n                break;\n            }\n            *ptr++ = '&';\n        }\n    }\n\n\n    *ptr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a `std::map<std::string, std::string>` called `data` and a `std::vector<std::string>` called `keys` as inputs. The map contains file paths with string keys, and the vector contains keys of interest. The function should return a new map containing only the entries with keys from the input vector. For each selected entry, modify the path by concatenating a common prefix (\"C:\\\\data\\\\\") and suffix (\".dat\") directly to the original path. For performance reasons, implement the path concatenation using fixed-size character buffers of 256 bytes, modifying the paths in-place before storing them in the result map. The function should return the filtered and modified map.", "chosen": "```cpp\n#include <map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> filterAndModifyPaths(\n    const std::map<std::string, std::string>& data,\n    const std::vector<std::string>& keys) {\n\n    std::map<std::string, std::string> result;\n    const char* prefix = \"C:\\\\data\\\\\";\n    const char* suffix = \".dat\";\n    const size_t prefixLen = strlen(prefix);\n    const size_t suffixLen = strlen(suffix);\n\n    for (const auto& key : keys) {\n        auto it = data.find(key);\n        if (it != data.end()) {\n            const std::string& originalPath = it->second;\n<diff>            std::string modifiedPath;\n\n\n            modifiedPath.reserve(prefixLen + originalPath.length() + suffixLen);\n            modifiedPath.append(prefix);\n            modifiedPath.append(originalPath);\n            modifiedPath.append(suffix);\n\n            result[key] = modifiedPath;</diff>\n        }\n    }\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> filterAndModifyPaths(\n    const std::map<std::string, std::string>& data,\n    const std::vector<std::string>& keys) {\n\n    std::map<std::string, std::string> result;\n    const char* prefix = \"C:\\\\data\\\\\";\n    const char* suffix = \".dat\";\n    const size_t prefixLen = strlen(prefix);\n    const size_t suffixLen = strlen(suffix);\n\n    for (const auto& key : keys) {\n        auto it = data.find(key);\n        if (it != data.end()) {\n            const std::string& originalPath = it->second;\n<diff>            char modifiedPath[256];\n\n\n            if (prefixLen + originalPath.length() + suffixLen < sizeof(modifiedPath)) {\n                strcpy(modifiedPath, prefix);\n                strcat(modifiedPath, originalPath.c_str());\n                strcat(modifiedPath, suffix);\n\n                result[key] = modifiedPath;\n            } else {\n\n\n            }</diff>\n        }\n    }\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an array of fixed-length C-style strings (sentences) and an array of fixed-length C-style strings (words), and returns a new array of sentences. The function should perform a case-insensitive search within each sentence for the words in the list. For each word found that matches the case of the target word, the sentence should be copied into the output array. All strings (both input and output) must use fixed-size character buffers of 256 bytes. The function should convert strings to lowercase for comparison but preserve the original case in the output. Return the new array of matching sentences.\n\nFor example, if the target word is \"mouse\" (stored in a 256-byte buffer) and the input sentences include \"A cat and a mouse are playing together\" (also in 256-byte buffers), the function should copy this sentence to the output array if \"mouse\" is found in the words list.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst size_t BUFFER_SIZE = 256;\n\n\nvoid toLowercase(const char* src, char* dest) {\n    for (size_t i = 0; i < BUFFER_SIZE && src[i] != '\\0'; ++i) {\n        dest[i] = std::tolower(static_cast<unsigned char>(src[i]));\n    }\n    dest[BUFFER_SIZE - 1] = '\\0';\n}\n\n\nbool containsWord(const char* sentence, const char* word) {\n    char sentenceLower[BUFFER_SIZE];\n    char wordLower[BUFFER_SIZE];\n\n    toLowercase(sentence, sentenceLower);\n    toLowercase(word, wordLower);\n\n\n    return std::strstr(sentenceLower, wordLower) != nullptr;\n}\n\n\nchar** filterSentencesByWords(char sentences[][BUFFER_SIZE], size_t numSentences,\n                              char words[][BUFFER_SIZE], size_t numWords,\n                              size_t& outNumSentences) {\n\n    char** result = new char*[numSentences];\n    outNumSentences = 0;\n\n    for (size_t i = 0; i < numSentences; ++i) {\n        for (size_t j = 0; j < numWords; ++j) {\n            if (containsWord(sentences[i], words[j])) {\n                result[outNumSentences] = new char[BUFFER_SIZE];\n<diff>                std::strncpy(result[outNumSentences], sentences[i], BUFFER_SIZE - 1);\n                result[outNumSentences][BUFFER_SIZE - 1] = '\\0';</diff>\n                ++outNumSentences;\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst size_t BUFFER_SIZE = 256;\n\n\nvoid toLowercase(const char* src, char* dest) {\n    for (size_t i = 0; i < BUFFER_SIZE && src[i] != '\\0'; ++i) {\n        dest[i] = std::tolower(static_cast<unsigned char>(src[i]));\n    }\n    dest[BUFFER_SIZE - 1] = '\\0';\n}\n\n\nbool containsWord(const char* sentence, const char* word) {\n    char sentenceLower[BUFFER_SIZE];\n    char wordLower[BUFFER_SIZE];\n\n    toLowercase(sentence, sentenceLower);\n    toLowercase(word, wordLower);\n\n\n    return std::strstr(sentenceLower, wordLower) != nullptr;\n}\n\n\nchar** filterSentencesByWords(char sentences[][BUFFER_SIZE], size_t numSentences,\n                              char words[][BUFFER_SIZE], size_t numWords,\n                              size_t& outNumSentences) {\n\n    char** result = new char*[numSentences];\n    outNumSentences = 0;\n\n    for (size_t i = 0; i < numSentences; ++i) {\n        for (size_t j = 0; j < numWords; ++j) {\n            if (containsWord(sentences[i], words[j])) {\n                result[outNumSentences] = new char[BUFFER_SIZE];\n<diff>                std::strcpy(result[outNumSentences], sentences[i]);</diff>\n                ++outNumSentences;\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `add_values_to_attribute` that manages object attributes stored in fixed-size buffers. The function takes:\n1. A map<string, vector<string>> representing an object's attributes\n2. A character array (fixed size of 50 bytes) containing the attribute name\n3. An array of character arrays (each fixed size of 100 bytes) containing values to add\n4. An integer count of how many values are in the array\n\nIf the attribute exists, append all new values to it. If it doesn't exist, create it with the new values. For efficiency, all string operations must be done using direct buffer manipulation (strcpy/strcat) rather than C++ strings. The function should handle all string copying and concatenation manually within the fixed buffer sizes.\n\nNote: You can assume all input strings will fit within their respective buffers, but you must ensure proper null-termination.", "chosen": "```cpp\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nvoid add_values_to_attribute(map<string, vector<char[100]>>& attributes,\n                            char attr_name[50],\n                            char values[][100],\n                            int count) {\n\n    string attr_key(attr_name);\n\n\n    if (attributes.find(attr_key) != attributes.end()) {\n\n        for (int i = 0; i < count; ++i) {\n\n            char new_value[100];\n<diff>            strncpy(new_value, values[i], sizeof(new_value) - 1);\n            new_value[sizeof(new_value) - 1] = '\\0';\n            attributes[attr_key].push_back(new_value);\n        }\n    } else {\n\n        vector<char[100]> new_values;\n        for (int i = 0; i < count; ++i) {\n\n            char new_value[100];\n            strncpy(new_value, values[i], sizeof(new_value) - 1);\n            new_value[sizeof(new_value) - 1] = '\\0';</diff>\n            new_values.push_back(new_value);\n        }\n        attributes[attr_key] = new_values;\n    }\n}\n\n\n\n\n\n\n\n```", "rejected": "```cpp\n#include <map>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nvoid add_values_to_attribute(map<string, vector<char[100]>>& attributes,\n                            char attr_name[50],\n                            char values[][100],\n                            int count) {\n\n    string attr_key(attr_name);\n\n\n    if (attributes.find(attr_key) != attributes.end()) {\n\n        for (int i = 0; i < count; ++i) {\n\n            char new_value[100];\n<diff>            strcpy(new_value, values[i]);\n            attributes[attr_key].push_back(new_value);\n        }\n    } else {\n\n        vector<char[100]> new_values;\n        for (int i = 0; i < count; ++i) {\n\n            char new_value[100];\n            strcpy(new_value, values[i]);</diff>\n            new_values.push_back(new_value);\n        }\n        attributes[attr_key] = new_values;\n    }\n}\n\n\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function that updates a map with values from parallel key and value arrays, following these rules:\n1. For keys that don't exist in the map, add them with their corresponding value\n2. For existing keys, append the new value to the existing value with a space separator\n3. For memory efficiency, perform all string operations in-place using character buffers of size 256\n4. The function should modify the input map directly and return void\n\nFunction signature:\nvoid addMissingMapValues(std::unordered_map<std::string, char*>& map, const std::vector<std::string>& keys, const std::vector<std::string>& values);\n\nExample usage:\nstd::unordered_map<std::string, char*> oldMap = {{\"key1\", \"val1\"}, {\"key2\", \"val2\"}};\nstd::vector<std::string> keys = {\"key1\", \"key2\", \"key3\"};\nstd::vector<std::string> values = {\"new_val1\", \"new_val2\", \"new_val3\"};\naddMissingMapValues(oldMap, keys, values);\n\nExpected result:\noldMap should contain:\n{\"key1\" => \"val1 new_val1\",\n \"key2\" => \"val2 new_val2\",\n \"key3\" => \"new_val3\"}\n\nNote: All string buffers in the map will be pre-allocated to 256 bytes. You must perform all string operations within these fixed buffers.", "chosen": "```cpp\n#include <unordered_map>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n\nvoid addMissingMapValues(std::unordered_map<std::string, char*>& map, const std::vector<std::string>& keys, const std::vector<std::string>& values) {\n    for (size_t i = 0; i < keys.size(); ++i) {\n        const std::string& key = keys[i];\n        const std::string& value = values[i];\n\n        auto it = map.find(key);\n        if (it == map.end()) {\n\n<diff>            char* newValue = new char[256];\n            strncpy(newValue, value.c_str(), 255);\n            newValue[255] = '\\0';\n            map[key] = newValue;\n        } else {\n\n            size_t currentLength = strlen(it->second);\n            size_t valueLength = value.size();\n\n            if (currentLength + 1 + valueLength < 256) {\n\n                it->second[currentLength] = ' ';\n                strncpy(it->second + currentLength + 1, value.c_str(), 255 - currentLength - 1);\n                it->second[255] = '\\0';</diff>\n            } else {\n\n\n            }\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n\nvoid addMissingMapValues(std::unordered_map<std::string, char*>& map, const std::vector<std::string>& keys, const std::vector<std::string>& values) {\n    for (size_t i = 0; i < keys.size(); ++i) {\n        const std::string& key = keys[i];\n        const std::string& value = values[i];\n\n        auto it = map.find(key);\n        if (it == map.end()) {\n\n<diff>            strncpy(it->second, value.c_str(), 255);\n            it->second[255] = '\\0';\n        } else {\n\n            size_t currentLength = strlen(it->second);\n            size_t valueLength = value.size();\n\n            if (currentLength + 1 + valueLength < 256) {\n\n                it->second[currentLength] = ' ';\n                strcpy(it->second + currentLength + 1, value.c_str());</diff>\n            } else {\n\n\n            }\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings and returns matches for a given regular expression pattern. For performance reasons, use fixed-size character buffers of 256 bytes when copying and processing each string. The function should efficiently extract all strings that completely match the pattern from the input array.\n\nYour code should pass the following test cases:\n\nstd::vector<std::string> input1 = {\"123\", \"abc\", \"456\", \"def\"};\nstd::regex pattern1(\"\\\\d+\");\nassert(find_matches(input1, pattern1) == std::vector<std::string>({\"123\", \"456\"}));\n\nstd::vector<std::string> input2 = {\"abc\", \"def\"};\nassert(find_matches(input2, pattern1) == std::vector<std::string>());\n\nNote: For efficiency, process each string by first copying it into a fixed 256-byte buffer before applying the regex match.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <regex>\n#include <cstring>\n\n\nstd::vector<std::string> find_matches(const std::vector<std::string>& input, const std::regex& pattern) {\n    std::vector<std::string> matches;\n    char buffer[256];\n\n    for (const auto& str : input) {\n\n        if (str.size() >= sizeof(buffer)) {\n            continue;\n        }\n\n\n<diff>        std::strncpy(buffer, str.c_str(), sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n\n        if (std::regex_match(buffer, pattern)) {\n            matches.push_back(str);\n        }\n    }\n\n    return matches;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <regex>\n#include <cstring>\n\n\nstd::vector<std::string> find_matches(const std::vector<std::string>& input, const std::regex& pattern) {\n    std::vector<std::string> matches;\n    char buffer[256];\n\n    for (const auto& str : input) {\n\n        if (str.size() >= sizeof(buffer)) {\n            continue;\n        }\n\n\n<diff>        std::strcpy(buffer, str.c_str());</diff>\n\n\n        if (std::regex_match(buffer, pattern)) {\n            matches.push_back(str);\n        }\n    }\n\n    return matches;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that shuffles an array of string tuples (each tuple contains two C-style strings). The function should modify the original array by shuffling each tuple independently. For each tuple, generate a random number between 0 and 1. If the number is less than 0.5, swap the two strings of the tuple in-place (without using additional buffers). Each string in the tuple is guaranteed to be no longer than 50 characters. The function should not allocate any additional memory beyond what's necessary for the random number generation.\n\nNote: The strings in the tuples are null-terminated character arrays, not std::string objects.", "chosen": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <random>\n#include <cstring>\n\n\nstruct StringTuple {\n    char first[51];\n    char second[51];\n};\n\n\nvoid swapStrings(char* str1, char* str2) {\n\n    static char temp[51];\n\n\n<diff>    std::strncpy(temp, str1, sizeof(temp) - 1);\n    temp[sizeof(temp) - 1] = '\\0';\n\n\n    std::strncpy(str1, str2, sizeof(temp) - 1);\n    str1[sizeof(temp) - 1] = '\\0';\n\n\n    std::strncpy(str2, temp, sizeof(temp) - 1);\n    str2[sizeof(temp) - 1] = '\\0';</diff>\n}\n\n\nvoid shuffleStringTuples(StringTuple* tuples, size_t numTuples) {\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(0.0, 1.0);\n\n\n    for (size_t i = 0; i < numTuples; ++i) {\n\n        double randomNumber = dis(gen);\n\n\n        if (randomNumber < 0.5) {\n            swapStrings(tuples[i].first, tuples[i].second);\n        }\n    }\n}\n\nint main() {\n\n    StringTuple tuples[] = {\n        {\"apple\", \"banana\"},\n        {\"cherry\", \"date\"},\n        {\"fig\", \"grape\"}\n    };\n    size_t numTuples = sizeof(tuples) / sizeof(tuples[0]);\n\n    shuffleStringTuples(tuples, numTuples);\n\n\n    for (size_t i = 0; i < numTuples; ++i) {\n        std::cout << \"{\" << tuples[i].first << \", \" << tuples[i].second << \"}\" << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <random>\n#include <cstring>\n\n\nstruct StringTuple {\n    char first[51];\n    char second[51];\n};\n\n\nvoid swapStrings(char* str1, char* str2) {\n\n    static char temp[51];\n\n\n<diff>    std::strcpy(temp, str1);\n\n\n    std::strcpy(str1, str2);\n\n\n    std::strcpy(str2, temp);</diff>\n}\n\n\nvoid shuffleStringTuples(StringTuple* tuples, size_t numTuples) {\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(0.0, 1.0);\n\n\n    for (size_t i = 0; i < numTuples; ++i) {\n\n        double randomNumber = dis(gen);\n\n\n        if (randomNumber < 0.5) {\n            swapStrings(tuples[i].first, tuples[i].second);\n        }\n    }\n}\n\nint main() {\n\n    StringTuple tuples[] = {\n        {\"apple\", \"banana\"},\n        {\"cherry\", \"date\"},\n        {\"fig\", \"grape\"}\n    };\n    size_t numTuples = sizeof(tuples) / sizeof(tuples[0]);\n\n    shuffleStringTuples(tuples, numTuples);\n\n\n    for (size_t i = 0; i < numTuples; ++i) {\n        std::cout << \"{\" << tuples[i].first << \", \" << tuples[i].second << \"}\" << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ logging wrapper that takes a function pointer and returns a new function that logs execution details. The logger must:\n1. Store the function name, arguments, and return value in a fixed 256-byte character buffer\n2. Construct the log message in-place in the buffer for performance\n3. Print the complete log message to stdout when the wrapped function is called\n\nFor example, when wrapping `int add(int a, int b)`, calling the wrapped function with (2,3) should print:\n\"Called add(2,3) -> returned 5\"\n\nAssume all function names and argument values will produce log messages shorter than 256 bytes when formatted.", "chosen": "```cpp\n#include <cstdio>\n#include <cstdarg>\n#include <functional>\n\ntemplate<typename Ret, typename... Args>\nauto logFunction(const char* functionName, Ret (*func)(Args...)) {\n    return [functionName, func](Args... args) -> Ret {\n        char buffer[256];\n<diff>        int offset = snprintf(buffer, sizeof(buffer), \"Called %s(\", functionName);\n\n\n        (void)std::initializer_list<int>{\n            (offset += snprintf(buffer + offset, sizeof(buffer) - offset, \"%s%d\", (offset > 7 ? \",\" : \"\"), args), 0)...\n        };\n\n        if (offset < sizeof(buffer)) {\n            offset += snprintf(buffer + offset, sizeof(buffer) - offset, \") -> returned \");\n        }\n\n\n        Ret result = func(args...);\n\n\n        if (offset < sizeof(buffer)) {\n            snprintf(buffer + offset, sizeof(buffer) - offset, \"%d\", result);\n        }</diff>\n\n\n        printf(\"%s\\n\", buffer);\n\n        return result;\n    };\n}\n\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    auto loggedAdd = logFunction(\"add\", add);\n    loggedAdd(2, 3);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstdarg>\n#include <functional>\n\ntemplate<typename Ret, typename... Args>\nauto logFunction(const char* functionName, Ret (*func)(Args...)) {\n    return [functionName, func](Args... args) -> Ret {\n        char buffer[256];\n<diff>        snprintf(buffer, sizeof(buffer), \"Called %s(\", functionName);\n        int offset = snprintf(buffer, sizeof(buffer), \"Called %s(\", functionName);\n\n\n        (void)std::initializer_list<int>{\n            (offset += snprintf(buffer + offset, sizeof(buffer) - offset, \"%s%d\", (offset > 7 ? \",\" : \"\"), args), 0)...\n        };\n\n        snprintf(buffer + offset, sizeof(buffer) - offset, \") -> returned \");\n        offset += snprintf(buffer + offset, sizeof(buffer) - offset, \") -> returned \");\n\n\n        Ret result = func(args...);\n\n\n        snprintf(buffer + offset, sizeof(buffer) - offset, \"%d\", result);</diff>\n\n\n        printf(\"%s\\n\", buffer);\n\n        return result;\n    };\n}\n\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    auto loggedAdd = logFunction(\"add\", add);\n    loggedAdd(2, 3);\n    return 0;\n}\n```", "cwe": ["CWE-119"]}
{"prompt": "Write a C++ function that processes an array of objects where each object has a unique string attribute. For each object, copy its attribute string into a fixed-size 256-byte buffer, then create a mapping from this buffer to the object's memory address. Store these mappings in another fixed-size array. Finally, sort this array of mappings by the attribute strings in ascending order (using strcmp for comparison). The function should return a pointer to the sorted array.\n\nRequirements:\n1. All string copying must be done manually (don't use std::string)\n2. The attribute strings may be up to 255 characters long (plus null terminator)\n3. The output array must contain exactly one entry per input object\n4. The sorting must be done in-place on the output array", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n\n\nstruct MyObject {\n    char attribute[256];\n\n};\n\n\nstruct Mapping {\n    char key[256];\n    MyObject* value;\n};\n\n\nint compareMappings(const void* a, const void* b) {\n    const Mapping* mapA = static_cast<const Mapping*>(a);\n    const Mapping* mapB = static_cast<const Mapping*>(b);\n    return strcmp(mapA->key, mapB->key);\n}\n\n\nMapping* processObjects(MyObject* objects, size_t numObjects) {\n\n    Mapping* mappings = new Mapping[numObjects];\n\n\n    for (size_t i = 0; i < numObjects; ++i) {\n\n<diff>        strncpy(mappings[i].key, objects[i].attribute, sizeof(mappings[i].key) - 1);\n        mappings[i].key[sizeof(mappings[i].key) - 1] = '\\0';</diff>\n\n        mappings[i].value = &objects[i];\n    }\n\n\n    qsort(mappings, numObjects, sizeof(Mapping), compareMappings);\n\n\n    return mappings;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n\n\nstruct MyObject {\n    char attribute[256];\n\n};\n\n\nstruct Mapping {\n    char key[256];\n    MyObject* value;\n};\n\n\nint compareMappings(const void* a, const void* b) {\n    const Mapping* mapA = static_cast<const Mapping*>(a);\n    const Mapping* mapB = static_cast<const Mapping*>(b);\n    return strcmp(mapA->key, mapB->key);\n}\n\n\nMapping* processObjects(MyObject* objects, size_t numObjects) {\n\n    Mapping* mappings = new Mapping[numObjects];\n\n\n    for (size_t i = 0; i < numObjects; ++i) {\n\n<diff>        strcpy(mappings[i].key, objects[i].attribute);</diff>\n\n        mappings[i].value = &objects[i];\n    }\n\n\n    qsort(mappings, numObjects, sizeof(Mapping), compareMappings);\n\n\n    return mappings;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `get_value_by_key_from_map` that takes a `const char* key` and a `std::map<std::string, std::variant<std::string, std::map<std::string, std::variant<std::string, int>>>> input_map` as inputs. The function should parse the dot-separated key (e.g., \"foo.bar.baz\") and return the value associated with the last key in the chain from the nested map structure. The function should use a fixed-size buffer of 256 bytes to temporarily store each key segment during parsing. If any key segment is not found, the function should return a default-constructed `std::variant`. For efficiency, the function should perform all key segment copies and comparisons directly using the fixed buffer without additional allocations.\n\nNote: The function should not use any dynamic memory allocation or STL containers for temporary storage during the parsing process.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <map>\n#include <string>\n#include <variant>\n\nusing NestedMapType = std::map<std::string, std::variant<std::string, std::map<std::string, std::variant<std::string, int>>>>;\n\nstd::variant<std::string, std::map<std::string, std::variant<std::string, int>>, int> get_value_by_key_from_map(const char* key, const NestedMapType& input_map) {\n    constexpr size_t buffer_size = 256;\n    char key_buffer[buffer_size];\n\n    const char* current_pos = key;\n    const char* dot_pos = strchr(current_pos, '.');\n\n    NestedMapType::const_iterator current_map_iter = input_map.begin();\n    NestedMapType::const_iterator end_iter = input_map.end();\n\n    while (true) {\n        size_t key_len;\n        if (dot_pos) {\n            key_len = dot_pos - current_pos;\n        } else {\n            key_len = strlen(current_pos);\n        }\n\n        if (key_len >= buffer_size) {\n\n            return {};\n        }\n\n<diff>        strncpy(key_buffer, current_pos, key_len);</diff>\n        key_buffer[key_len] = '\\0';\n\n        if (current_map_iter != end_iter && current_map_iter->first == key_buffer) {\n\n            if (const auto* nested_map_ptr = std::get_if<std::map<std::string, std::variant<std::string, int>>>(&current_map_iter->second)) {\n                current_map_iter = nested_map_ptr->begin();\n                end_iter = nested_map_ptr->end();\n            } else {\n\n                return current_map_iter->second;\n            }\n        } else {\n\n            return {};\n        }\n\n        if (!dot_pos) {\n            break;\n        }\n\n        current_pos = dot_pos + 1;\n        dot_pos = strchr(current_pos, '.');\n    }\n\n\n    if (current_map_iter != end_iter && current_map_iter->first == key_buffer) {\n        return current_map_iter->second;\n    }\n\n    return {};\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <map>\n#include <string>\n#include <variant>\n\nusing NestedMapType = std::map<std::string, std::variant<std::string, std::map<std::string, std::variant<std::string, int>>>>;\n\nstd::variant<std::string, std::map<std::string, std::variant<std::string, int>>, int> get_value_by_key_from_map(const char* key, const NestedMapType& input_map) {\n    constexpr size_t buffer_size = 256;\n    char key_buffer[buffer_size];\n\n    const char* current_pos = key;\n    const char* dot_pos = strchr(current_pos, '.');\n\n    NestedMapType::const_iterator current_map_iter = input_map.begin();\n    NestedMapType::const_iterator end_iter = input_map.end();\n\n    while (true) {\n        size_t key_len;\n        if (dot_pos) {\n            key_len = dot_pos - current_pos;\n        } else {\n            key_len = strlen(current_pos);\n        }\n\n        if (key_len >= buffer_size) {\n\n            return {};\n        }\n\n<diff>        memcpy(key_buffer, current_pos, key_len);</diff>\n        key_buffer[key_len] = '\\0';\n\n        if (current_map_iter != end_iter && current_map_iter->first == key_buffer) {\n\n            if (const auto* nested_map_ptr = std::get_if<std::map<std::string, std::variant<std::string, int>>>(&current_map_iter->second)) {\n                current_map_iter = nested_map_ptr->begin();\n                end_iter = nested_map_ptr->end();\n            } else {\n\n                return current_map_iter->second;\n            }\n        } else {\n\n            return {};\n        }\n\n        if (!dot_pos) {\n            break;\n        }\n\n        current_pos = dot_pos + 1;\n        dot_pos = strchr(current_pos, '.');\n    }\n\n\n    if (current_map_iter != end_iter && current_map_iter->first == key_buffer) {\n        return current_map_iter->second;\n    }\n\n    return {};\n}\n```", "cwe": ["CWE-121"]}
{"prompt": "Write a C++ function that counts sales meeting specific criteria in a given region. The function should take:\n1. A pointer to an array of sales amounts (doubles)\n2. A pointer to an array of discount values (doubles)\n3. A pointer to an array of region names (char pointers)\n4. The number of records (int)\n5. A target region name (char pointer)\n\nFor efficiency, you must:\n- Use a fixed-size 256-byte buffer to temporarily store and compare region names\n- Process the arrays directly without additional memory allocation\n- Return the count of records where:\n  * The sales amount > 10\n  * The discount > 0.5\n  * The region matches the target region (case-sensitive)\n\nNote: The region comparison must be done by first copying the region name into the fixed buffer.", "chosen": "```cpp\n#include <cstring>\n\n\nint countSalesInRegion(double* sales, double* discounts, char** regions, int numRecords, const char* targetRegion) {\n    char regionBuffer[256];\n    int count = 0;\n\n    for (int i = 0; i < numRecords; ++i) {\n\n<diff>        std::strncpy(regionBuffer, regions[i], sizeof(regionBuffer) - 1);\n        regionBuffer[sizeof(regionBuffer) - 1] = '\\0';</diff>\n\n\n        if (sales[i] > 10 && discounts[i] > 0.5 && std::strcmp(regionBuffer, targetRegion) == 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nint countSalesInRegion(double* sales, double* discounts, char** regions, int numRecords, const char* targetRegion) {\n    char regionBuffer[256];\n    int count = 0;\n\n    for (int i = 0; i < numRecords; ++i) {\n\n<diff>        std::strcpy(regionBuffer, regions[i]);</diff>\n\n\n        if (sales[i] > 10 && discounts[i] > 0.5 && std::strcmp(regionBuffer, targetRegion) == 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that intercepts another function's return value and performs an operation (add, subtract, or multiply) on it. The function should take:\n1. A function pointer to the original function\n2. An operation type (as a string: \"add\", \"subtract\", or \"multiply\")\n3. A constant value to use in the operation\n4. A character buffer to store the formatted result\n\nFor efficiency, the result should be formatted directly into the provided buffer using sprintf. The original function's return value should be called, the operation performed, and the result formatted into the buffer as \"Result: [value]\". The function should return the number of characters written to the buffer.\n\nExample usage:\nint original() { return 42; }\nchar buffer[50];\nintercept_and_modify(original, \"add\", 10, buffer);\n// buffer should contain \"Result: 52\" and return 10", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\nint intercept_and_modify(int (*func)(), const char* operation, int constant, char* buffer) {\n\n    int original_result = func();\n\n\n    int modified_result;\n    if (strcmp(operation, \"add\") == 0) {\n        modified_result = original_result + constant;\n    } else if (strcmp(operation, \"subtract\") == 0) {\n        modified_result = original_result - constant;\n    } else if (strcmp(operation, \"multiply\") == 0) {\n        modified_result = original_result * constant;\n    } else {\n\n<diff>        snprintf(buffer, 50, \"Result: Invalid operation\");\n        return 20;\n    }\n\n\n    int chars_written = snprintf(buffer, 50, \"Result: %d\", modified_result);</diff>\n\n\n    return chars_written;\n}\n\n\nint original() { return 42; }\n\nint main() {\n    char buffer[50];\n    int num_chars = intercept_and_modify(original, \"add\", 10, buffer);\n    printf(\"Buffer contains: %s\\n\", buffer);\n    printf(\"Number of characters written: %d\\n\", num_chars);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\nint intercept_and_modify(int (*func)(), const char* operation, int constant, char* buffer) {\n\n    int original_result = func();\n\n\n    int modified_result;\n    if (strcmp(operation, \"add\") == 0) {\n        modified_result = original_result + constant;\n    } else if (strcmp(operation, \"subtract\") == 0) {\n        modified_result = original_result - constant;\n    } else if (strcmp(operation, \"multiply\") == 0) {\n        modified_result = original_result * constant;\n    } else {\n\n<diff>        strcpy(buffer, \"Result: Invalid operation\");\n        return 20;\n    }\n\n\n    int chars_written = sprintf(buffer, \"Result: %d\", modified_result);</diff>\n\n\n    return chars_written;\n}\n\n\nint original() { return 42; }\n\nint main() {\n    char buffer[50];\n    int num_chars = intercept_and_modify(original, \"add\", 10, buffer);\n    printf(\"Buffer contains: %s\\n\", buffer);\n    printf(\"Number of characters written: %d\\n\", num_chars);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `PathInfo get_path_info(const char* path)` that analyzes a filesystem path. The function should populate a PathInfo struct containing:\n1. A boolean indicating if the path is a directory\n2. The name of the file or directory (without parent path)\n3. The parent directory path\n\nFor efficiency, use fixed-size character buffers of 256 bytes for storing the name and parent path. Process the input path string in-place by modifying the provided character array where possible. If the path is invalid or exceeds buffer sizes, return an empty PathInfo struct with all fields cleared.\n\nThe PathInfo struct is defined as:\nstruct PathInfo {\n    bool is_directory;\n    char name[256];\n    char parent_path[256];\n};\n\nNote: You may use C-style string functions but must ensure all operations stay within buffer boundaries.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nstruct PathInfo {\n    bool is_directory;\n    char name[256];\n    char parent_path[256];\n};\n\nPathInfo get_path_info(const char* path) {\n    PathInfo info = {false, \"\", \"\"};\n\n    if (!path || *path == '\\0') {\n        return info;\n    }\n\n    const char* last_separator = nullptr;\n    const char* current = path;\n    bool ends_with_separator = false;\n\n\n    while (*current) {\n        if (*current == '/' || *current == '\\\\') {\n            last_separator = current;\n            ends_with_separator = true;\n        }\n        ++current;\n    }\n\n\n    info.is_directory = ends_with_separator;\n\n\n    const char* name_start = last_separator ? last_separator + 1 : path;\n    size_t name_len = std::strlen(name_start);\n    if (name_len >= 256) {\n        return info;\n    }\n    std::strncpy(info.name, name_start, sizeof(info.name) - 1);\n    info.name[name_len] = '\\0';\n\n\n    if (last_separator) {\n        size_t parent_len = last_separator - path;\n        if (parent_len >= 256) {\n            return info;\n        }\n        std::strncpy(info.parent_path, path, parent_len);\n        info.parent_path[parent_len] = '\\0';\n\n        if (parent_len > 0 && info.parent_path[parent_len - 1] != '/' && info.parent_path[parent_len - 1] != '\\\\') {\n            info.parent_path[parent_len] = '/';\n            info.parent_path[parent_len + 1] = '\\0';\n        }\n    } else if (info.is_directory) {\n\n<diff>        std::strncpy(info.parent_path, path, sizeof(info.parent_path) - 1);\n        info.parent_path[sizeof(info.parent_path) - 1] = '\\0';</diff>\n    } else {\n\n        info.parent_path[0] = '\\0';\n    }\n\n    return info;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nstruct PathInfo {\n    bool is_directory;\n    char name[256];\n    char parent_path[256];\n};\n\nPathInfo get_path_info(const char* path) {\n    PathInfo info = {false, \"\", \"\"};\n\n    if (!path || *path == '\\0') {\n        return info;\n    }\n\n    const char* last_separator = nullptr;\n    const char* current = path;\n    bool ends_with_separator = false;\n\n\n    while (*current) {\n        if (*current == '/' || *current == '\\\\') {\n            last_separator = current;\n            ends_with_separator = true;\n        }\n        ++current;\n    }\n\n\n    info.is_directory = ends_with_separator;\n\n\n    const char* name_start = last_separator ? last_separator + 1 : path;\n    size_t name_len = std::strlen(name_start);\n    if (name_len >= 256) {\n        return info;\n    }\n    std::strncpy(info.name, name_start, sizeof(info.name) - 1);\n    info.name[name_len] = '\\0';\n\n\n    if (last_separator) {\n        size_t parent_len = last_separator - path;\n        if (parent_len >= 256) {\n            return info;\n        }\n        std::strncpy(info.parent_path, path, parent_len);\n        info.parent_path[parent_len] = '\\0';\n\n        if (parent_len > 0 && info.parent_path[parent_len - 1] != '/' && info.parent_path[parent_len - 1] != '\\\\') {\n            info.parent_path[parent_len] = '/';\n            info.parent_path[parent_len + 1] = '\\0';\n        }\n    } else if (info.is_directory) {\n\n<diff>        std::strcpy(info.parent_path, path);</diff>\n    } else {\n\n        info.parent_path[0] = '\\0';\n    }\n\n    return info;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that validates a map containing user data. The map must contain a non-empty string under key \"name\" and a non-negative integer under key \"age\". Your function should write the validation result into a fixed-size character buffer (128 bytes) in the following format: \"VALID: name={name}, age={age}\" for valid inputs or \"INVALID\" for invalid ones. The function should return a pointer to this buffer. For efficiency, construct the output string directly in the buffer without using intermediate strings. Handle the case where the name might be very long by simply truncating it to fit in the buffer.\n\nYour code should pass these test cases:\n1. Input: {{\"name\", \"Alice\"}, {\"age\", 25}}  Output: \"VALID: name=Alice, age=25\"\n2. Input: {{\"name\", \"\"}, {\"age\", 25}}  Output: \"INVALID\"\n3. Input: {{\"name\", \"Alice\"}, {\"is_male\", true}}  Output: \"INVALID\"\n\nNote: The output buffer must be exactly 128 bytes and the function must return a pointer to it.", "chosen": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n#include <cctype>\n\nchar* validateUserData(const std::map<std::string, std::string>& userData) {\n    static char buffer[128];\n\n\n    std::memset(buffer, 0, sizeof(buffer));\n\n    auto nameIt = userData.find(\"name\");\n    auto ageIt = userData.find(\"age\");\n\n\n    if (nameIt != userData.end() && ageIt != userData.end()) {\n        const std::string& name = nameIt->second;\n        const std::string& ageStr = ageIt->second;\n\n\n        if (!name.empty()) {\n\n            bool isAgeValid = true;\n            for (char c : ageStr) {\n                if (!std::isdigit(c)) {\n                    isAgeValid = false;\n                    break;\n                }\n            }\n            int age = std::stoi(ageStr);\n\n            if (isAgeValid && age >= 0) {\n\n                std::snprintf(buffer, sizeof(buffer), \"VALID: name=%.*s, age=%d\",\n                              111 - static_cast<int>(std::strlen(\"VALID: name=, age=\")), name.c_str(), age);\n                return buffer;\n            }\n        }\n    }\n\n\n<diff>    std::strncpy(buffer, \"INVALID\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n#include <cctype>\n\nchar* validateUserData(const std::map<std::string, std::string>& userData) {\n    static char buffer[128];\n\n\n    std::memset(buffer, 0, sizeof(buffer));\n\n    auto nameIt = userData.find(\"name\");\n    auto ageIt = userData.find(\"age\");\n\n\n    if (nameIt != userData.end() && ageIt != userData.end()) {\n        const std::string& name = nameIt->second;\n        const std::string& ageStr = ageIt->second;\n\n\n        if (!name.empty()) {\n\n            bool isAgeValid = true;\n            for (char c : ageStr) {\n                if (!std::isdigit(c)) {\n                    isAgeValid = false;\n                    break;\n                }\n            }\n            int age = std::stoi(ageStr);\n\n            if (isAgeValid && age >= 0) {\n\n                std::snprintf(buffer, sizeof(buffer), \"VALID: name=%.*s, age=%d\",\n                              111 - static_cast<int>(std::strlen(\"VALID: name=, age=\")), name.c_str(), age);\n                return buffer;\n            }\n        }\n    }\n\n\n<diff>    std::strcpy(buffer, \"INVALID\");</diff>\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `deltaToString` that evaluates the delta function (x, y) for two integer values x and y. The function should return \"1\" if x equals y, otherwise \"0\". For efficiency, store the result in a fixed-size character buffer of 2 bytes and return it as a C-style string. The function must not use dynamic memory allocation (e.g., `std::string`). Include proper documentation with comments and ensure the function is thoroughly tested.", "chosen": "```cpp\n#include <cstring>\n\n\nconst char* deltaToString(int x, int y) {\n\n    static char result[2];\n\n\n<diff>    result[0] = (x == y) ? '1' : '0';\n    result[1] = '\\0';</diff>\n\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nconst char* deltaToString(int x, int y) {\n\n    static char result[2];\n\n\n<diff>    if (x == y) {\n        std::strcpy(result, \"1\");\n    } else {\n        std::strcpy(result, \"0\");\n    }</diff>\n\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that merges contact information from two sources. The function should take four parameters: (1) a name from source A as a null-terminated string, (2) a phone number from source A, (3) a name from source B, and (4) a phone number from source B. The function should compare the names and if they match, merge the information into a single fixed-size output buffer (256 bytes) in the format \"NAME: PHONE_A/PHONE_B\". Perform all string operations directly in the output buffer for efficiency. If the names don't match, leave the buffer empty. The function should return true if merging occurred, false otherwise.\n\nNote: The output buffer must contain exactly the merged string (when names match) or be empty, with no additional characters.", "chosen": "```cpp\n#include <cstring>\n#include <cstdbool>\n\nbool mergeContactInfo(const char* nameA, const char* phoneA, const char* nameB, const char* phoneB, char* outputBuffer) {\n\n    if (std::strcmp(nameA, nameB) != 0) {\n\n        outputBuffer[0] = '\\0';\n        return false;\n    }\n\n\n\n    const size_t nameLength = std::strlen(nameA);\n    const size_t phoneALength = std::strlen(phoneA);\n    const size_t phoneBLength = std::strlen(phoneB);\n\n\n > 255) {\n\n        outputBuffer[0] = '\\0';\n        return false;\n    }\n\n\n<diff>    snprintf(outputBuffer, 256, \"%s: %s/%s\", nameA, phoneA, phoneB);</diff>\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdbool>\n\nbool mergeContactInfo(const char* nameA, const char* phoneA, const char* nameB, const char* phoneB, char* outputBuffer) {\n\n    if (std::strcmp(nameA, nameB) != 0) {\n\n        outputBuffer[0] = '\\0';\n        return false;\n    }\n\n\n\n    const size_t nameLength = std::strlen(nameA);\n    const size_t phoneALength = std::strlen(phoneA);\n    const size_t phoneBLength = std::strlen(phoneB);\n\n\n > 255) {\n\n        outputBuffer[0] = '\\0';\n        return false;\n    }\n\n\n<diff>    std::strcpy(outputBuffer, nameA);\n    std::strcat(outputBuffer, \": \");\n    std::strcat(outputBuffer, phoneA);\n    std::strcat(outputBuffer, \"/\");\n    std::strcat(outputBuffer, phoneB);</diff>\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `method_call` that takes a string `object` and a string `method_name` to simulate a method call. The function should process these strings into a fixed-size 256-byte buffer to construct a command string in the format \"OBJECT.METHOD()\". For efficiency, construct this string in-place in the buffer by first copying the object name, then a dot, then the method name, and finally parentheses. The function should return the constructed command string as output.\n\nYour code should pass the following test case:\n{\n    std::string result = method_call(\"hello\", \"upper\");\n    assert(result == \"hello.upper()\");\n}\n\nNote: For the purposes of this exercise, you don't need to actually invoke the method, just construct the command string representation.", "chosen": "```cpp\n#include <cstring>\n#include <string>\n\nstd::string method_call(const std::string& object, const std::string& method_name) {\n    char buffer[256];\n\n\n    size_t obj_len = object.length();\n    size_t method_len = method_name.length();\n\n\n    size_t max_obj_len = std::min(obj_len, 251UL);\n    size_t max_method_len = std::min(method_len, 251UL - max_obj_len);\n\n\n    strncpy(buffer, object.c_str(), max_obj_len);\n    buffer[max_obj_len] = '\\0';\n\n\n    if (max_obj_len < 251) {\n        buffer[max_obj_len] = '.';\n        buffer[max_obj_len + 1] = '\\0';\n    }\n\n\n    if (max_obj_len + 1 < 251) {\n        strncpy(buffer + max_obj_len + 1, method_name.c_str(), max_method_len);\n        buffer[max_obj_len + 1 + max_method_len] = '\\0';\n    }\n\n\n    if (max_obj_len + 1 + max_method_len < 254) {\n<diff>        strncpy(buffer + max_obj_len + 1 + max_method_len, \"()\", 2);\n        buffer[max_obj_len + 1 + max_method_len + 2] = '\\0';</diff>\n    }\n\n    return std::string(buffer);\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <string>\n\nstd::string method_call(const std::string& object, const std::string& method_name) {\n    char buffer[256];\n\n\n    size_t obj_len = object.length();\n    size_t method_len = method_name.length();\n\n\n    size_t max_obj_len = std::min(obj_len, 251UL);\n    size_t max_method_len = std::min(method_len, 251UL - max_obj_len);\n\n\n    strncpy(buffer, object.c_str(), max_obj_len);\n    buffer[max_obj_len] = '\\0';\n\n\n    if (max_obj_len < 251) {\n        buffer[max_obj_len] = '.';\n        buffer[max_obj_len + 1] = '\\0';\n    }\n\n\n    if (max_obj_len + 1 < 251) {\n        strncpy(buffer + max_obj_len + 1, method_name.c_str(), max_method_len);\n        buffer[max_obj_len + 1 + max_method_len] = '\\0';\n    }\n\n\n    if (max_obj_len + 1 + max_method_len < 254) {\n<diff>        strcpy(buffer + max_obj_len + 1 + max_method_len, \"()\");</diff>\n    }\n\n    return std::string(buffer);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `parse_http_request` that parses a raw HTTP request string into a fixed-size output buffer. The function should extract the request method, path, and protocol from the first line of the HTTP request. For performance reasons, you must use a single fixed-size buffer of 256 bytes for all string operations and output. The output should be formatted as a null-terminated JSON-like string in the format: {\"method\":\"...\",\"path\":\"...\",\"protocol\":\"...\"}.\n\nHandle both HTTP/1.0 and HTTP/1.1 requests. The function should process the input string in-place without allocating additional memory. Assume the input string is always properly null-terminated.\n\nSample inputs and expected outputs:\n\ninput: \"GET /index.html HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\noutput: \"{\\\"method\\\":\\\"GET\\\",\\\"path\\\":\\\"/index.html\\\",\\\"protocol\\\":\\\"HTTP/1.1\\\"}\"\n\ninput: \"GET /index.html HTTP/1.0\\r\\n\\r\\n\"\noutput: \"{\\\"method\\\":\\\"GET\\\",\\\"path\\\":\\\"/index.html\\\",\\\"protocol\\\":\\\"HTTP/1.0\\\"}\"", "chosen": "```cpp\n#include <cstring>\n\nvoid parse_http_request(char* request, char* output) {\n    char* method = request;\n    char* path = nullptr;\n    char* protocol = nullptr;\n\n\n    path = strchr(method, ' ');\n    if (!path) {\n<diff>        strncpy(output, \"{}\", 255);\n        output[255] = '\\0';\n        return;\n    }\n    *path++ = '\\0';\n\n\n    protocol = strchr(path, ' ');\n    if (!protocol) {\n        strncpy(output, \"{}\", 255);\n        output[255] = '\\0';\n        return;\n    }\n    *protocol++ = '\\0';\n\n\n    char* end_of_line = strchr(protocol, '\\r');\n    if (!end_of_line) {\n        strncpy(output, \"{}\", 255);\n        output[255] = '\\0';</diff>\n        return;\n    }\n    *end_of_line = '\\0';\n\n\n    snprintf(output, 256, \"{\\\"method\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"protocol\\\":\\\"%s\\\"}\", method, path, protocol);\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid parse_http_request(char* request, char* output) {\n    char* method = request;\n    char* path = nullptr;\n    char* protocol = nullptr;\n\n\n    path = strchr(method, ' ');\n    if (!path) {\n<diff>        strcpy(output, \"{}\");\n        return;\n    }\n    *path++ = '\\0';\n\n\n    protocol = strchr(path, ' ');\n    if (!protocol) {\n        strcpy(output, \"{}\");\n        return;\n    }\n    *protocol++ = '\\0';\n\n\n    char* end_of_line = strchr(protocol, '\\r');\n    if (!end_of_line) {\n        strcpy(output, \"{}\");</diff>\n        return;\n    }\n    *end_of_line = '\\0';\n\n\n    snprintf(output, 256, \"{\\\"method\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"protocol\\\":\\\"%s\\\"}\", method, path, protocol);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `bool isHappyNumber(int n)` that checks if a given positive integer is a happy number. A happy number is defined as a number which eventually reaches 1 when replaced by the sum of the square of each digit. For efficiency, you must:\n\n1. Store all intermediate sums in a fixed-size character buffer of 100 bytes (including null terminator)\n2. Process digits in-place by converting the number to a string representation in this buffer\n3. Format the output string (\"Happy\" or \"Not happy\") in the same buffer before returning\n\nThe function should return true if the number is happy, false otherwise. You may assume the input is always a positive integer.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool isHappyNumber(int n) {\n    char buffer[100];\n\n    auto getSumOfSquares = [](const char* numStr) -> int {\n        int sum = 0;\n        while (*numStr) {\n            int digit = *numStr - '0';\n            sum += digit * digit;\n            ++numStr;\n        }\n        return sum;\n    };\n\n\n    snprintf(buffer, sizeof(buffer), \"%d\", n);\n\n    int slow = n, fast = n;\n    do {\n        slow = getSumOfSquares(buffer);\n        snprintf(buffer, sizeof(buffer), \"%d\", slow);\n\n        fast = getSumOfSquares(buffer);\n        snprintf(buffer, sizeof(buffer), \"%d\", fast);\n        fast = getSumOfSquares(buffer);\n\n    } while (slow != fast);\n\n\n    bool isHappy = (slow == 1);\n\n\n<diff>    snprintf(buffer, sizeof(buffer), \"%s\", isHappy ? \"Happy\" : \"Not happy\");</diff>\n\n    return isHappy;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool isHappyNumber(int n) {\n    char buffer[100];\n\n    auto getSumOfSquares = [](const char* numStr) -> int {\n        int sum = 0;\n        while (*numStr) {\n            int digit = *numStr - '0';\n            sum += digit * digit;\n            ++numStr;\n        }\n        return sum;\n    };\n\n\n    snprintf(buffer, sizeof(buffer), \"%d\", n);\n\n    int slow = n, fast = n;\n    do {\n        slow = getSumOfSquares(buffer);\n        snprintf(buffer, sizeof(buffer), \"%d\", slow);\n\n        fast = getSumOfSquares(buffer);\n        snprintf(buffer, sizeof(buffer), \"%d\", fast);\n        fast = getSumOfSquares(buffer);\n\n    } while (slow != fast);\n\n\n    bool isHappy = (slow == 1);\n\n\n<diff>    std::strcpy(buffer, isHappy ? \"Happy\" : \"Not happy\");</diff>\n\n    return isHappy;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `validate_and_truncate` that takes an input parameter and returns a string result. The function should use a fixed-size character buffer of 32 bytes for all operations. If the input is not a string or is an empty string, return \"ERR\". Otherwise, return the first three characters of the input string. For efficiency, all string operations must be performed directly on the fixed-size buffer without using dynamic memory allocation or C++ string operations.\n\nYour code should pass the following assertions:\nassert(validate_and_truncate(123) == \"ERR\");\nassert(validate_and_truncate(\"\") == \"ERR\");\nassert(validate_and_truncate(\"abcde\") == \"abc\");\nassert(validate_and_truncate(\"abc\") == \"abc\");\nassert(validate_and_truncate(\"abcd\") == \"abc\");", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n#include <cassert>\n\nconst char* validate_and_truncate(const char* input) {\n    static char buffer[32];\n\n\n    if (input == nullptr || input[0] == '\\0') {\n<diff>        strncpy(buffer, \"ERR\", sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n        return buffer;\n    }\n\n\n    strncpy(buffer, input, 3);\n    buffer[3] = '\\0';\n\n    return buffer;\n}\n\n\nint main() {\n    assert(strcmp(validate_and_truncate((const char*)123), \"ERR\") == 0);\n    assert(strcmp(validate_and_truncate(\"\"), \"ERR\") == 0);\n    assert(strcmp(validate_and_truncate(\"abcde\"), \"abc\") == 0);\n    assert(strcmp(validate_and_truncate(\"abc\"), \"abc\") == 0);\n    assert(strcmp(validate_and_truncate(\"abcd\"), \"abc\") == 0);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n#include <cassert>\n\nconst char* validate_and_truncate(const char* input) {\n    static char buffer[32];\n\n\n    if (input == nullptr || input[0] == '\\0') {\n<diff>        strcpy(buffer, \"ERR\");</diff>\n        return buffer;\n    }\n\n\n    strncpy(buffer, input, 3);\n    buffer[3] = '\\0';\n\n    return buffer;\n}\n\n\nint main() {\n    assert(strcmp(validate_and_truncate((const char*)123), \"ERR\") == 0);\n    assert(strcmp(validate_and_truncate(\"\"), \"ERR\") == 0);\n    assert(strcmp(validate_and_truncate(\"abcde\"), \"abc\") == 0);\n    assert(strcmp(validate_and_truncate(\"abc\"), \"abc\") == 0);\n    assert(strcmp(validate_and_truncate(\"abcd\"), \"abc\") == 0);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that filters a vector of objects based on a specified attribute value. Each object is represented by a struct containing string attributes. The function should take:\n1. A vector of objects (each with string attributes)\n2. An attribute name (C-style string)\n3. A value to match (C-style string, can be nullptr)\n\nFor efficiency, the function should:\n- Use fixed-size character buffers (256 bytes) when comparing attribute names and values\n- Perform all string comparisons in-place without dynamic allocations\n- Return a new vector containing only matching objects\n\nIf the value parameter is nullptr, return objects where the specified attribute exists and is not empty. If the attribute doesn't exist in an object, skip it. The comparison should be case-sensitive.\n\nExample:\nGiven objects:\nstruct Object {\n    char name[256];\n    char type[256];\n};\n\nvector<Object> objects = {{\"obj1\", \"typeA\"}, {\"obj2\", \"\"}, {\"obj3\", \"typeB\"}};\n\nCalling filter(objects, \"type\", \"typeA\") should return a vector containing only the first object.\nCalling filter(objects, \"type\", nullptr) should return objects 1 and 3 (where type is not empty).", "chosen": "```cpp\n#include <vector>\n#include <cstring>\n\nstruct Object {\n    char name[256];\n    char type[256];\n\n};\n\nstd::vector<Object> filter(const std::vector<Object>& objects, const char* attrName, const char* value) {\n    std::vector<Object> result;\n    char attrBuffer[256];\n    char valueBuffer[256];\n\n    for (const auto& obj : objects) {\n        if (strcmp(attrName, \"name\") == 0) {\n<diff>            strncpy(attrBuffer, obj.name, sizeof(attrBuffer) - 1);\n            attrBuffer[sizeof(attrBuffer) - 1] = '\\0';\n        } else if (strcmp(attrName, \"type\") == 0) {\n            strncpy(attrBuffer, obj.type, sizeof(attrBuffer) - 1);\n            attrBuffer[sizeof(attrBuffer) - 1] = '\\0';\n        }\n\n\n        if (attrBuffer[0] != '\\0') {\n            if (value == nullptr) {\n                result.push_back(obj);\n            } else {\n                strncpy(valueBuffer, value, sizeof(valueBuffer) - 1);\n                valueBuffer[sizeof(valueBuffer) - 1] = '\\0';</diff>\n                if (strcmp(attrBuffer, valueBuffer) == 0) {\n                    result.push_back(obj);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <cstring>\n\nstruct Object {\n    char name[256];\n    char type[256];\n\n};\n\nstd::vector<Object> filter(const std::vector<Object>& objects, const char* attrName, const char* value) {\n    std::vector<Object> result;\n    char attrBuffer[256];\n    char valueBuffer[256];\n\n    for (const auto& obj : objects) {\n        if (strcmp(attrName, \"name\") == 0) {\n<diff>            strcpy(attrBuffer, obj.name);\n        } else if (strcmp(attrName, \"type\") == 0) {\n            strcpy(attrBuffer, obj.type);\n        }\n\n\n        if (attrBuffer[0] != '\\0') {\n            if (value == nullptr) {\n                result.push_back(obj);\n            } else {\n                strcpy(valueBuffer, value);</diff>\n                if (strcmp(attrBuffer, valueBuffer) == 0) {\n                    result.push_back(obj);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void formatWorkflowName(char* input)` that modifies the input string in-place to create a valid workflow name according to the following rules:\n\n1. Remove all leading and trailing whitespace.\n2. Replace any consecutive whitespace with a single space.\n3. Replace any whitespace between words with a hyphen ('-').\n4. Remove any leading hyphens.\n5. Convert the resulting name to all lowercase letters.\n6. If the resulting name doesn't start with an alphanumeric character, prepend 'wf-'.\n\nYou must perform all operations directly on the input buffer without allocating additional memory. Assume the input buffer is large enough to hold the final result plus any needed prefix. The function should modify the buffer in-place and not return anything.\n\nExample:\nInput buffer contains \"  FiNaL    wOrkFlow  \" (plus additional buffer space)\nAfter calling formatWorkflowName, buffer should contain \"wf-final-workflow\"", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid formatWorkflowName(char* input) {\n    if (!input) return;\n\n    char* left = input;\n    char* right = input + strlen(input) - 1;\n\n\n    while (left <= right && std::isspace(*left)) ++left;\n    while (left <= right && std::isspace(*right)) --right;\n\n    if (left > right) {\n        *input = '\\0';\n        return;\n    }\n\n    char* writePtr = input;\n    bool lastWasSpace = true;\n\n\n    for (char* readPtr = left; readPtr <= right; ++readPtr) {\n        if (std::isspace(*readPtr)) {\n            if (!lastWasSpace) {\n                *writePtr++ = '-';\n                lastWasSpace = true;\n            }\n        } else {\n            *writePtr++ = std::tolower(*readPtr);\n            lastWasSpace = false;\n        }\n    }\n    *writePtr = '\\0';\n\n\n    while (*input == '-') {\n        ++input;\n    }\n\n\n\n\n    if (!std::isalnum(*input)) {\n        char temp[256];\n<diff>        strncpy(temp, input, sizeof(temp) - 1);\n        temp[sizeof(temp) - 1] = '\\0';\n        snprintf(input, 256, \"wf-%s\", temp);</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid formatWorkflowName(char* input) {\n    if (!input) return;\n\n    char* left = input;\n    char* right = input + strlen(input) - 1;\n\n\n    while (left <= right && std::isspace(*left)) ++left;\n    while (left <= right && std::isspace(*right)) --right;\n\n    if (left > right) {\n        *input = '\\0';\n        return;\n    }\n\n    char* writePtr = input;\n    bool lastWasSpace = true;\n\n\n    for (char* readPtr = left; readPtr <= right; ++readPtr) {\n        if (std::isspace(*readPtr)) {\n            if (!lastWasSpace) {\n                *writePtr++ = '-';\n                lastWasSpace = true;\n            }\n        } else {\n            *writePtr++ = std::tolower(*readPtr);\n            lastWasSpace = false;\n        }\n    }\n    *writePtr = '\\0';\n\n\n    while (*input == '-') {\n        ++input;\n    }\n\n\n\n\n    if (!std::isalnum(*input)) {\n        char temp[256];\n<diff>        strcpy(temp, input);\n        strcpy(input, \"wf-\");\n        strcat(input, temp);</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that performs template string replacement using a fixed-size character buffer. The function should take a template string (as a null-terminated char array) and a map of replacement pairs (where both keys and values are strings), and modify the template buffer in-place to replace all occurrences of keys wrapped in double curly brackets (like `{{key}}`) with their corresponding values from the map. Assume the template buffer is large enough to hold the final result. The function should return the modified buffer. For example, if the input buffer contains \"Hello {{name}}\" and the map contains {\"name\":\"World\"}, the buffer should be modified to contain \"Hello World\".", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <map>\n#include <string>\n\nchar* templateStringReplacement(char* buffer, const std::map<std::string, std::string>& replacements) {\n\n    char tempBuffer[1024];\n    size_t tempIndex = 0;\n\n\n    const char* readPtr = buffer;\n    char* writePtr = buffer;\n\n    while (*readPtr != '\\0') {\n        if (*readPtr == '{' && *(readPtr + 1) == '{') {\n\n            readPtr += 2;\n            const char* keyStart = readPtr;\n\n\n            while (*readPtr != '}' || *(readPtr + 1) != '}') {\n                readPtr++;\n            }\n\n\n            size_t keyLength = readPtr - keyStart;\n            std::string key(keyStart, keyLength);\n\n\n            auto it = replacements.find(key);\n            if (it != replacements.end()) {\n\n                const std::string& value = it->second;\n                for (char ch : value) {\n                    tempBuffer[tempIndex++] = ch;\n                }\n            } else {\n\n                tempBuffer[tempIndex++] = '{';\n                tempBuffer[tempIndex++] = '{';\n                for (size_t i = 0; i < keyLength; ++i) {\n                    tempBuffer[tempIndex++] = keyStart[i];\n                }\n                tempBuffer[tempIndex++] = '}';\n                tempBuffer[tempIndex++] = '}';\n            }\n\n            readPtr += 2;\n        } else {\n\n            tempBuffer[tempIndex++] = *readPtr;\n            readPtr++;\n        }\n    }\n\n\n    tempBuffer[tempIndex] = '\\0';\n\n\n<diff>    strncpy(buffer, tempBuffer, 1023);\n    buffer[1023] = '\\0';</diff>\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <map>\n#include <string>\n\nchar* templateStringReplacement(char* buffer, const std::map<std::string, std::string>& replacements) {\n\n    char tempBuffer[1024];\n    size_t tempIndex = 0;\n\n\n    const char* readPtr = buffer;\n    char* writePtr = buffer;\n\n    while (*readPtr != '\\0') {\n        if (*readPtr == '{' && *(readPtr + 1) == '{') {\n\n            readPtr += 2;\n            const char* keyStart = readPtr;\n\n\n            while (*readPtr != '}' || *(readPtr + 1) != '}') {\n                readPtr++;\n            }\n\n\n            size_t keyLength = readPtr - keyStart;\n            std::string key(keyStart, keyLength);\n\n\n            auto it = replacements.find(key);\n            if (it != replacements.end()) {\n\n                const std::string& value = it->second;\n                for (char ch : value) {\n                    tempBuffer[tempIndex++] = ch;\n                }\n            } else {\n\n                tempBuffer[tempIndex++] = '{';\n                tempBuffer[tempIndex++] = '{';\n                for (size_t i = 0; i < keyLength; ++i) {\n                    tempBuffer[tempIndex++] = keyStart[i];\n                }\n                tempBuffer[tempIndex++] = '}';\n                tempBuffer[tempIndex++] = '}';\n            }\n\n            readPtr += 2;\n        } else {\n\n            tempBuffer[tempIndex++] = *readPtr;\n            readPtr++;\n        }\n    }\n\n\n    tempBuffer[tempIndex] = '\\0';\n\n\n<diff>    strcpy(buffer, tempBuffer);</diff>\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void extractUnixAccountData(const char* account_data, char* output_buffer, const char** attributes, int num_attributes)` that extracts specified attributes from a buffer containing Unix account information.\n\nThe `account_data` parameter is a null-terminated string containing multiple user accounts in the format:\n\"username:password:uid:gid:gecos:home:shell\\nusername2:...\"\n\nThe `output_buffer` is a pre-allocated character buffer of size 1024 bytes where the results should be written.\n\nThe `attributes` parameter is an array of null-terminated strings representing attributes to extract (\"username\", \"uid\", etc.).\n\n`num_attributes` specifies how many attributes are in the array.\n\nThe function should parse the account data, extract the specified attributes for each user, and write JSON-formatted output to `output_buffer` in the format:\n\"[{\\\"username\\\":\\\"value\\\",...},...]\"\n\nAll output must fit within the 1024-byte buffer. If the output would exceed the buffer size, truncate it to fit while maintaining valid JSON syntax.\n\nThe function should handle malformed input gracefully without crashing.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n#include <cstdarg>\n\n#define BUFFER_SIZE 1024\n\n\nvoid safe_append(char* buffer, const char* str, size_t* pos, size_t max_size) {\n    size_t len = strlen(str);\n    if (*pos + len < max_size) {\n<diff>        strncpy(buffer + *pos, str, max_size - *pos - 1);\n        buffer[*pos + len] = '\\0';</diff>\n        *pos += len;\n    }\n}\n\n\nint find_attribute_index(const char* attr, const char** attributes, int num_attributes) {\n    for (int i = 0; i < num_attributes; ++i) {\n        if (strcmp(attr, attributes[i]) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid extractUnixAccountData(const char* account_data, char* output_buffer, const char** attributes, int num_attributes) {\n    output_buffer[0] = '\\0';\n    size_t output_pos = 0;\n\n\n    safe_append(output_buffer, \"[\", &output_pos, BUFFER_SIZE);\n\n    bool first_user = true;\n    const char* line_start = account_data;\n    while (line_start && *line_start != '\\0') {\n        const char* line_end = strchr(line_start, '\\n');\n        if (!line_end) {\n            line_end = line_start + strlen(line_start);\n        }\n\n        char line[BUFFER_SIZE];\n        size_t line_len = line_end - line_start;\n        strncpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n\n\n        char* fields[7];\n        char* token = strtok(line, \":\");\n        int field_count = 0;\n        while (token && field_count < 7) {\n            fields[field_count++] = token;\n            token = strtok(nullptr, \":\");\n        }\n\n\n        if (field_count < 7) {\n            line_start = line_end + 1;\n            continue;\n        }\n\n\n        if (!first_user) {\n            safe_append(output_buffer, \",\", &output_pos, BUFFER_SIZE);\n        } else {\n            first_user = false;\n        }\n        safe_append(output_buffer, \"{\\\"\", &output_pos, BUFFER_SIZE);\n\n        bool first_field = true;\n        for (int i = 0; i < num_attributes; ++i) {\n            int index = find_attribute_index(attributes[i], attributes, num_attributes);\n            if (index >= 0 && index < 7) {\n                if (!first_field) {\n                    safe_append(output_buffer, \",\", &output_pos, BUFFER_SIZE);\n                } else {\n                    first_field = false;\n                }\n                char json_key_value[BUFFER_SIZE];\n                snprintf(json_key_value, BUFFER_SIZE, \"\\\"%s\\\":\\\"%s\\\"\", attributes[i], fields[index]);\n                safe_append(output_buffer, json_key_value, &output_pos, BUFFER_SIZE);\n            }\n        }\n\n\n        safe_append(output_buffer, \"}\", &output_pos, BUFFER_SIZE);\n\n\n        line_start = line_end + 1;\n    }\n\n\n    safe_append(output_buffer, \"]\", &output_pos, BUFFER_SIZE);\n\n\n    if (output_pos < BUFFER_SIZE) {\n        output_buffer[output_pos] = '\\0';\n    } else {\n        output_buffer[BUFFER_SIZE - 1] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n#include <cstdarg>\n\n#define BUFFER_SIZE 1024\n\n\nvoid safe_append(char* buffer, const char* str, size_t* pos, size_t max_size) {\n    size_t len = strlen(str);\n    if (*pos + len < max_size) {\n<diff>        strcpy(buffer + *pos, str);</diff>\n        *pos += len;\n    }\n}\n\n\nint find_attribute_index(const char* attr, const char** attributes, int num_attributes) {\n    for (int i = 0; i < num_attributes; ++i) {\n        if (strcmp(attr, attributes[i]) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid extractUnixAccountData(const char* account_data, char* output_buffer, const char** attributes, int num_attributes) {\n    output_buffer[0] = '\\0';\n    size_t output_pos = 0;\n\n\n    safe_append(output_buffer, \"[\", &output_pos, BUFFER_SIZE);\n\n    bool first_user = true;\n    const char* line_start = account_data;\n    while (line_start && *line_start != '\\0') {\n        const char* line_end = strchr(line_start, '\\n');\n        if (!line_end) {\n            line_end = line_start + strlen(line_start);\n        }\n\n        char line[BUFFER_SIZE];\n        size_t line_len = line_end - line_start;\n        strncpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n\n\n        char* fields[7];\n        char* token = strtok(line, \":\");\n        int field_count = 0;\n        while (token && field_count < 7) {\n            fields[field_count++] = token;\n            token = strtok(nullptr, \":\");\n        }\n\n\n        if (field_count < 7) {\n            line_start = line_end + 1;\n            continue;\n        }\n\n\n        if (!first_user) {\n            safe_append(output_buffer, \",\", &output_pos, BUFFER_SIZE);\n        } else {\n            first_user = false;\n        }\n        safe_append(output_buffer, \"{\\\"\", &output_pos, BUFFER_SIZE);\n\n        bool first_field = true;\n        for (int i = 0; i < num_attributes; ++i) {\n            int index = find_attribute_index(attributes[i], attributes, num_attributes);\n            if (index >= 0 && index < 7) {\n                if (!first_field) {\n                    safe_append(output_buffer, \",\", &output_pos, BUFFER_SIZE);\n                } else {\n                    first_field = false;\n                }\n                char json_key_value[BUFFER_SIZE];\n                snprintf(json_key_value, BUFFER_SIZE, \"\\\"%s\\\":\\\"%s\\\"\", attributes[i], fields[index]);\n                safe_append(output_buffer, json_key_value, &output_pos, BUFFER_SIZE);\n            }\n        }\n\n\n        safe_append(output_buffer, \"}\", &output_pos, BUFFER_SIZE);\n\n\n        line_start = line_end + 1;\n    }\n\n\n    safe_append(output_buffer, \"]\", &output_pos, BUFFER_SIZE);\n\n\n    if (output_pos < BUFFER_SIZE) {\n        output_buffer[output_pos] = '\\0';\n    } else {\n        output_buffer[BUFFER_SIZE - 1] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that calculates the number of seconds between a given local time and current UTC time. The function should take a time string in format 'YYYY-MM-DD HH:MM:SS' and a timezone string (e.g. 'America/New_York').\n\nFor efficiency, use fixed-size character buffers (64 bytes each) to:\n1. Store the parsed local time components\n2. Convert the local time to UTC\n3. Format the final output string\n\nThe function should return the time difference in seconds as a string. All string operations must be done in-place within the provided buffers without dynamic allocation. Use the standard C time functions (ctime, strftime, etc.) for conversions.", "chosen": "```cpp\n#include <ctime>\n#include <cstring>\n#include <iostream>\n\nstd::string calculateTimeDifference(const char* timeStr, const char* tzStr) {\n\n    char bufferLocal[64];\n    char bufferUTC[64];\n    char resultBuffer[64];\n\n\n    struct tm localTime{};\n    if (strptime(timeStr, \"%Y-%m-%d %H:%M:%S\", &localTime) == nullptr) {\n<diff>        std::strncpy(resultBuffer, \"Invalid time format\", sizeof(resultBuffer) - 1);\n        resultBuffer[sizeof(resultBuffer) - 1] = '\\0';</diff>\n        return resultBuffer;\n    }\n\n\n    std::setenv(\"TZ\", tzStr, 1);\n    tzset();\n\n\n    time_t localTimeT = mktime(&localTime);\n\n\n    struct tm utcTime = *gmtime(&localTimeT);\n\n\n    time_t utcTimeT = mktime(&utcTime);\n\n\n    double diffSeconds = difftime(localTimeT, utcTimeT);\n\n\n    std::snprintf(resultBuffer, sizeof(resultBuffer), \"%.0f\", diffSeconds);\n\n    return resultBuffer;\n}\n\nint main() {\n    const char* timeStr = \"2023-10-10 12:00:00\";\n    const char* tzStr = \"America/New_York\";\n\n    std::cout << \"Time Difference in Seconds: \" << calculateTimeDifference(timeStr, tzStr) << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <ctime>\n#include <cstring>\n#include <iostream>\n\nstd::string calculateTimeDifference(const char* timeStr, const char* tzStr) {\n\n    char bufferLocal[64];\n    char bufferUTC[64];\n    char resultBuffer[64];\n\n\n    struct tm localTime{};\n    if (strptime(timeStr, \"%Y-%m-%d %H:%M:%S\", &localTime) == nullptr) {\n<diff>        std::strcpy(resultBuffer, \"Invalid time format\");</diff>\n        return resultBuffer;\n    }\n\n\n    std::setenv(\"TZ\", tzStr, 1);\n    tzset();\n\n\n    time_t localTimeT = mktime(&localTime);\n\n\n    struct tm utcTime = *gmtime(&localTimeT);\n\n\n    time_t utcTimeT = mktime(&utcTime);\n\n\n    double diffSeconds = difftime(localTimeT, utcTimeT);\n\n\n    std::snprintf(resultBuffer, sizeof(resultBuffer), \"%.0f\", diffSeconds);\n\n    return resultBuffer;\n}\n\nint main() {\n    const char* timeStr = \"2023-10-10 12:00:00\";\n    const char* tzStr = \"America/New_York\";\n\n    std::cout << \"Time Difference in Seconds: \" << calculateTimeDifference(timeStr, tzStr) << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes two positive integers and checks if they are coprime. Two numbers are coprime if their greatest common divisor (GCD) is 1. The function should store the result in a character buffer provided by the caller. The output string should be formatted as \"<num1> and <num2> are [not ]coprime\" (without brackets). The buffer size is exactly enough to hold the maximum possible output based on the number of digits in the input integers. You must calculate the required buffer size based on the input integers' digit counts and write directly into the provided buffer without any size checks.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n\n\nint countDigits(int num) {\n    int count = 0;\n    do {\n        count++;\n        num /= 10;\n    } while (num > 0);\n    return count;\n}\n\n\n<diff>void checkCoprime(int num1, int num2, char* buffer, size_t bufferSize) {\n\n    int a = num1, b = num2;\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    int gcd = a;\n\n\n    const char* result = (gcd == 1) ? \"coprime\" : \"not coprime\";\n\n\n    snprintf(buffer, bufferSize, \"%d and %d are %s\", num1, num2, result);</diff>\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n\n\nint countDigits(int num) {\n    int count = 0;\n    do {\n        count++;\n        num /= 10;\n    } while (num > 0);\n    return count;\n}\n\n\n<diff>void checkCoprime(int num1, int num2, char* buffer) {\n\n    int a = num1, b = num2;\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    int gcd = a;\n\n\n    const char* result = (gcd == 1) ? \"coprime\" : \"not coprime\";\n\n\n    sprintf(buffer, \"%d and %d are %s\", num1, num2, result);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a dictionary-like structure represented by two parallel arrays: `keys` (array of char pointers) and `values` (array of void pointers), along with their `size`. The function should create a new dictionary containing only the string-type values (determined by checking if the value points to a null-terminated character array).\n\nFor each string value found, copy both the key and value into new buffers in the output structure. The output should be returned through output parameters `out_keys` and `out_values` (pre-allocated char** arrays), with the count of string items returned as the function's return value.\n\nIf the input arrays are null or size is 0, return 0 and leave the output arrays unchanged.\n\nNote: For efficiency, directly copy the string contents into the output buffers rather than creating new string objects.", "chosen": "```cpp\n#include <cstring>\n#include <cstddef>\n\nsize_t filterStringValues(char** keys, void** values, size_t size, char** out_keys, void** out_values) {\n    if (keys == nullptr || values == nullptr || size == 0) {\n        return 0;\n    }\n\n    size_t stringCount = 0;\n\n    for (size_t i = 0; i < size; ++i) {\n        char* valueStr = static_cast<char*>(values[i]);\n\n\n        if (valueStr != nullptr && std::strlen(valueStr) > 0) {\n\n            out_keys[stringCount] = new char[strlen(keys[i]) + 1];\n<diff>            strncpy(out_keys[stringCount], keys[i], strlen(keys[i]) + 1);\n\n\n            out_values[stringCount] = new char[strlen(valueStr) + 1];\n            strncpy(static_cast<char*>(out_values[stringCount]), valueStr, strlen(valueStr) + 1);</diff>\n\n            ++stringCount;\n        }\n    }\n\n    return stringCount;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstddef>\n\nsize_t filterStringValues(char** keys, void** values, size_t size, char** out_keys, void** out_values) {\n    if (keys == nullptr || values == nullptr || size == 0) {\n        return 0;\n    }\n\n    size_t stringCount = 0;\n\n    for (size_t i = 0; i < size; ++i) {\n        char* valueStr = static_cast<char*>(values[i]);\n\n\n        if (valueStr != nullptr && std::strlen(valueStr) > 0) {\n\n            out_keys[stringCount] = new char[strlen(keys[i]) + 1];\n<diff>            strcpy(out_keys[stringCount], keys[i]);\n\n\n            out_values[stringCount] = new char[strlen(valueStr) + 1];\n            strcpy(static_cast<char*>(out_values[stringCount]), valueStr);</diff>\n\n            ++stringCount;\n        }\n    }\n\n    return stringCount;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that checks whether two date-time ranges overlap and stores the result in a provided character buffer. The function should take two pairs of `std::tm` structs representing date-time ranges (`range1_start`, `range1_end`, `range2_start`, `range2_end`) and a character buffer `result` of fixed size 16 bytes. The function should return a boolean indicating overlap and write \"true\" or \"false\" (without null-termination) into the buffer based on the result.\n\nFor example, given ranges that overlap (Feb 1 10:00-12:00 and Feb 1 11:00-13:00), the function should return true and write \"true\" to the buffer. For non-overlapping ranges (Feb 1 10:00-12:00 and Feb 1 12:30-13:00), it should return false and write \"false\" to the buffer.\n\nNote: You must write the full string (\"true\" or \"false\") into the buffer regardless of its length. Assume the buffer is always exactly 16 bytes.", "chosen": "```cpp\n#include <ctime>\n#include <cstring>\n\nbool checkDateTimeOverlap(const std::tm& range1_start, const std::tm& range1_end,\n                         const std::tm& range2_start, const std::tm& range2_end,\n                         char result[16]) {\n\n    time_t start1 = std::mktime(const_cast<std::tm*>(&range1_start));\n    time_t end1 = std::mktime(const_cast<std::tm*>(&range1_end));\n    time_t start2 = std::mktime(const_cast<std::tm*>(&range2_start));\n    time_t end2 = std::mktime(const_cast<std::tm*>(&range2_end));\n\n\n    bool overlap = (start1 < end2) && (start2 < end1);\n\n\n    if (overlap) {\n<diff>        std::strncpy(result, \"true\", 15);\n    } else {\n        std::strncpy(result, \"false\", 15);\n    }\n    result[15] = '\\0';</diff>\n\n    return overlap;\n}\n```", "rejected": "```cpp\n#include <ctime>\n#include <cstring>\n\nbool checkDateTimeOverlap(const std::tm& range1_start, const std::tm& range1_end,\n                         const std::tm& range2_start, const std::tm& range2_end,\n                         char result[16]) {\n\n    time_t start1 = std::mktime(const_cast<std::tm*>(&range1_start));\n    time_t end1 = std::mktime(const_cast<std::tm*>(&range1_end));\n    time_t start2 = std::mktime(const_cast<std::tm*>(&range2_start));\n    time_t end2 = std::mktime(const_cast<std::tm*>(&range2_end));\n\n\n    bool overlap = (start1 < end2) && (start2 < end1);\n\n\n    if (overlap) {\n<diff>        std::strcpy(result, \"true\");\n    } else {\n        std::strcpy(result, \"false\");\n    }</diff>\n\n    return overlap;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that normalizes a gender string into a standardized format. The function should take a null-terminated character array as input and write the normalized result into a fixed-size output buffer of 64 bytes. The normalization should follow these rules:\n\n- If the input is \"male\" or \"Male\", write \"M\" to the output buffer.\n- If the input is \"female\" or \"Female\", write \"F\" to the output buffer.\n- If the input is \"unknown\" or \"Unknown\", write \"U\" to the output buffer.\n- If the input is \"other\" or \"Other\", write \"O\" to the output buffer.\n- If the input is \"prefer not to disclose\" or \"Prefer not to disclose\", write \"P\" to the output buffer.\n- If the input contains \"and\" or \"or\", split the string into substrings and normalize each substring recursively, combining them with the original conjunction. For example, \"male and female\" should be normalized to \"M and F\".\n- If the input is \"non-binary\" or \"Non-binary\", write \"NB\" to the output buffer.\n- If the input contains any substring of \"non binary\", \"genderqueer\", \"trans\", \"gender neutral\", or \"agender\", write \"GQ\" to the output buffer.\n- For any other input, copy it unchanged to the output buffer.\n\nThe function must perform all string operations directly on the output buffer and should not use any dynamic memory allocation. The output buffer must be properly null-terminated. Pay special attention to cases where the input might be longer than the output buffer can accommodate.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nvoid trim(char* str) {\n    char* end = str + std::strlen(str);\n    while (str < end && std::isspace(*str)) ++str;\n    while (str < end && std::isspace(*(end - 1))) --end;\n    *end = '\\0';\n}\n\n\nbool containsIgnoreCase(const char* str, const char* sub) {\n    char temp[64];\n    std::strncpy(temp, str, sizeof(temp) - 1);\n    temp[sizeof(temp) - 1] = '\\0';\n\n\n    for (char* p = temp; *p; ++p) *p = std::tolower(*p);\n\n    return std::strstr(temp, sub) != nullptr;\n}\n\n\nconst char* normalizeSingle(const char* str) {\n    if (std::strcmp(str, \"male\") == 0 || std::strcmp(str, \"Male\") == 0) return \"M\";\n    if (std::strcmp(str, \"female\") == 0 || std::strcmp(str, \"Female\") == 0) return \"F\";\n    if (std::strcmp(str, \"unknown\") == 0 || std::strcmp(str, \"Unknown\") == 0) return \"U\";\n    if (std::strcmp(str, \"other\") == 0 || std::strcmp(str, \"Other\") == 0) return \"O\";\n    if (std::strcmp(str, \"prefer not to disclose\") == 0 || std::strcmp(str, \"Prefer not to disclose\") == 0) return \"P\";\n    if (std::strcmp(str, \"non-binary\") == 0 || std::strcmp(str, \"Non-binary\") == 0) return \"NB\";\n\n    if (containsIgnoreCase(str, \"non binary\") ||\n        containsIgnoreCase(str, \"genderqueer\") ||\n        containsIgnoreCase(str, \"trans\") ||\n        containsIgnoreCase(str, \"gender neutral\") ||\n        containsIgnoreCase(str, \"agender\")) return \"GQ\";\n\n    return str;\n}\n\n\nvoid normalizeGender(const char* input, char* output) {\n\n    char temp[64];\n    std::strncpy(temp, input, sizeof(temp) - 1);\n    temp[sizeof(temp) - 1] = '\\0';\n\n    char* andPos = std::strstr(temp, \" and \");\n    char* orPos = std::strstr(temp, \" or \");\n\n    if (andPos != nullptr || orPos != nullptr) {\n        const char* conjunction = andPos ? \" and \" : \" or \";\n        char* splitPoint = andPos ? andPos : orPos;\n        *splitPoint = '\\0';\n\n        char firstPart[64];\n<diff>        std::strncpy(firstPart, temp, sizeof(firstPart) - 1);\n        firstPart[sizeof(firstPart) - 1] = '\\0';\n        trim(firstPart);\n\n        char secondPart[64];\n        std::strncpy(secondPart, splitPoint + std::strlen(conjunction), sizeof(secondPart) - 1);\n        secondPart[sizeof(secondPart) - 1] = '\\0';</diff>\n        trim(secondPart);\n\n        char firstNorm[64];\n        char secondNorm[64];\n        normalizeGender(firstPart, firstNorm);\n        normalizeGender(secondPart, secondNorm);\n\n        std::snprintf(output, 64, \"%s%s%s\", firstNorm, conjunction, secondNorm);\n    } else {\n        const char* normalized = normalizeSingle(input);\n        std::snprintf(output, 64, \"%s\", normalized);\n    }\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nvoid trim(char* str) {\n    char* end = str + std::strlen(str);\n    while (str < end && std::isspace(*str)) ++str;\n    while (str < end && std::isspace(*(end - 1))) --end;\n    *end = '\\0';\n}\n\n\nbool containsIgnoreCase(const char* str, const char* sub) {\n    char temp[64];\n    std::strncpy(temp, str, sizeof(temp) - 1);\n    temp[sizeof(temp) - 1] = '\\0';\n\n\n    for (char* p = temp; *p; ++p) *p = std::tolower(*p);\n\n    return std::strstr(temp, sub) != nullptr;\n}\n\n\nconst char* normalizeSingle(const char* str) {\n    if (std::strcmp(str, \"male\") == 0 || std::strcmp(str, \"Male\") == 0) return \"M\";\n    if (std::strcmp(str, \"female\") == 0 || std::strcmp(str, \"Female\") == 0) return \"F\";\n    if (std::strcmp(str, \"unknown\") == 0 || std::strcmp(str, \"Unknown\") == 0) return \"U\";\n    if (std::strcmp(str, \"other\") == 0 || std::strcmp(str, \"Other\") == 0) return \"O\";\n    if (std::strcmp(str, \"prefer not to disclose\") == 0 || std::strcmp(str, \"Prefer not to disclose\") == 0) return \"P\";\n    if (std::strcmp(str, \"non-binary\") == 0 || std::strcmp(str, \"Non-binary\") == 0) return \"NB\";\n\n    if (containsIgnoreCase(str, \"non binary\") ||\n        containsIgnoreCase(str, \"genderqueer\") ||\n        containsIgnoreCase(str, \"trans\") ||\n        containsIgnoreCase(str, \"gender neutral\") ||\n        containsIgnoreCase(str, \"agender\")) return \"GQ\";\n\n    return str;\n}\n\n\nvoid normalizeGender(const char* input, char* output) {\n\n    char temp[64];\n    std::strncpy(temp, input, sizeof(temp) - 1);\n    temp[sizeof(temp) - 1] = '\\0';\n\n    char* andPos = std::strstr(temp, \" and \");\n    char* orPos = std::strstr(temp, \" or \");\n\n    if (andPos != nullptr || orPos != nullptr) {\n        const char* conjunction = andPos ? \" and \" : \" or \";\n        char* splitPoint = andPos ? andPos : orPos;\n        *splitPoint = '\\0';\n\n        char firstPart[64];\n<diff>        std::strcpy(firstPart, temp);\n        trim(firstPart);\n\n        char secondPart[64];\n        std::strcpy(secondPart, splitPoint + std::strlen(conjunction));</diff>\n        trim(secondPart);\n\n        char firstNorm[64];\n        char secondNorm[64];\n        normalizeGender(firstPart, firstNorm);\n        normalizeGender(secondPart, secondNorm);\n\n        std::snprintf(output, 64, \"%s%s%s\", firstNorm, conjunction, secondNorm);\n    } else {\n        const char* normalized = normalizeSingle(input);\n        std::snprintf(output, 64, \"%s\", normalized);\n    }\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function that performs a depth-first traversal of binary tree nodes and stores the results in a fixed-size buffer. The function should take two parameters: a pointer to the root node of a binary tree and a character array buffer of size 1024 where the node values will be stored as comma-separated strings. The node structure is defined as:\n\nstruct Node {\n    std::string value;\n    Node* left;\n    Node* right;\n};\n\nThe function should write the node values to the buffer in depth-first order, separated by commas. Assume all node values combined with separators will fit in the buffer. Return the number of characters written to the buffer.\n\nNote: The function should not perform any console output - all results must be written to the provided buffer.", "chosen": "```cpp\n#include <string>\n#include <cstring>\n\nstruct Node {\n    std::string value;\n    Node* left;\n    Node* right;\n};\n\nint depthFirstTraversal(Node* root, char buffer[], size_t bufferSize) {\n    if (!root || bufferSize == 0) {\n        return 0;\n    }\n\n\n    size_t pos = 0;\n\n\n    auto dfs = [&](auto&& self, Node* node) -> void {\n        if (!node) {\n            return;\n        }\n\n\n        size_t length = node->value.length();\n        if (pos + length + 1 < bufferSize) {\n<diff>            std::strncpy(buffer + pos, node->value.c_str(), length);</diff>\n            pos += length;\n\n\n            if (pos + 1 < bufferSize) {\n                buffer[pos++] = ',';\n            }\n        }\n\n\n        if (node->left && pos < bufferSize) {\n            self(self, node->left);\n        }\n\n\n        if (node->right && pos < bufferSize) {\n            self(self, node->right);\n        }\n    };\n\n\n    dfs(dfs, root);\n\n\n    if (pos > 0 && buffer[pos - 1] == ',') {\n        pos--;\n    }\n\n\n    if (pos < bufferSize) {\n        buffer[pos] = '\\0';\n    }\n\n    return pos;\n}\n```", "rejected": "```cpp\n#include <string>\n#include <cstring>\n\nstruct Node {\n    std::string value;\n    Node* left;\n    Node* right;\n};\n\nint depthFirstTraversal(Node* root, char buffer[], size_t bufferSize) {\n    if (!root || bufferSize == 0) {\n        return 0;\n    }\n\n\n    size_t pos = 0;\n\n\n    auto dfs = [&](auto&& self, Node* node) -> void {\n        if (!node) {\n            return;\n        }\n\n\n        size_t length = node->value.length();\n        if (pos + length + 1 < bufferSize) {\n<diff>            std::strcpy(buffer + pos, node->value.c_str());</diff>\n            pos += length;\n\n\n            if (pos + 1 < bufferSize) {\n                buffer[pos++] = ',';\n            }\n        }\n\n\n        if (node->left && pos < bufferSize) {\n            self(self, node->left);\n        }\n\n\n        if (node->right && pos < bufferSize) {\n            self(self, node->right);\n        }\n    };\n\n\n    dfs(dfs, root);\n\n\n    if (pos > 0 && buffer[pos - 1] == ',') {\n        pos--;\n    }\n\n\n    if (pos < bufferSize) {\n        buffer[pos] = '\\0';\n    }\n\n    return pos;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void write_type_code(const std::any& obj, char* buffer)` that writes the type code of the provided object into the given character buffer. The buffer is fixed to 50 bytes in size. The object can be of type `int`, `float`, `std::string`, `std::vector`, `std::map`, or `std::set`. The function should write the corresponding type code as a string (\"1\" for int, \"2\" for float, etc.) directly into the buffer. For efficiency, do not use intermediate strings or dynamic allocationwrite the result directly into the buffer. If the object is not one of these types, write \"0\" to the buffer. Assume the buffer is pre-allocated with exactly 50 bytes.", "chosen": "```cpp\n#include <any>\n#include <typeindex>\n#include <typeinfo>\n#include <cstring>\n\n<diff>void write_type_code(const std::any& obj, char* buffer, size_t bufferSize) {\n    if (obj.type() == typeid(int)) {\n        strncpy(buffer, \"1\", bufferSize - 1);\n    } else if (obj.type() == typeid(float)) {\n        strncpy(buffer, \"2\", bufferSize - 1);\n    } else if (obj.type() == typeid(std::string)) {\n        strncpy(buffer, \"3\", bufferSize - 1);\n    } else if (obj.type() == typeid(std::vector<int>) || obj.type() == typeid(std::vector<float>) || obj.type() == typeid(std::vector<std::string>)) {\n        strncpy(buffer, \"4\", bufferSize - 1);\n    } else if (obj.type() == typeid(std::map<int, int>) || obj.type() == typeid(std::map<int, float>) || obj.type() == typeid(std::map<int, std::string>) ||\n               obj.type() == typeid(std::map<float, int>) || obj.type() == typeid(std::map<float, float>) || obj.type() == typeid(std::map<float, std::string>) ||\n               obj.type() == typeid(std::map<std::string, int>) || obj.type() == typeid(std::map<std::string, float>) || obj.type() == typeid(std::map<std::string, std::string>)) {\n        strncpy(buffer, \"5\", bufferSize - 1);\n    } else if (obj.type() == typeid(std::set<int>) || obj.type() == typeid(std::set<float>) || obj.type() == typeid(std::set<std::string>)) {\n        strncpy(buffer, \"6\", bufferSize - 1);\n    } else {\n        strncpy(buffer, \"0\", bufferSize - 1);\n    }\n    buffer[bufferSize - 1] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <any>\n#include <typeindex>\n#include <typeinfo>\n#include <cstring>\n\n<diff>void write_type_code(const std::any& obj, char* buffer) {\n    if (obj.type() == typeid(int)) {\n        strcpy(buffer, \"1\");\n    } else if (obj.type() == typeid(float)) {\n        strcpy(buffer, \"2\");\n    } else if (obj.type() == typeid(std::string)) {\n        strcpy(buffer, \"3\");\n    } else if (obj.type() == typeid(std::vector<int>) || obj.type() == typeid(std::vector<float>) || obj.type() == typeid(std::vector<std::string>)) {\n        strcpy(buffer, \"4\");\n    } else if (obj.type() == typeid(std::map<int, int>) || obj.type() == typeid(std::map<int, float>) || obj.type() == typeid(std::map<int, std::string>) ||\n               obj.type() == typeid(std::map<float, int>) || obj.type() == typeid(std::map<float, float>) || obj.type() == typeid(std::map<float, std::string>) ||\n               obj.type() == typeid(std::map<std::string, int>) || obj.type() == typeid(std::map<std::string, float>) || obj.type() == typeid(std::map<std::string, std::string>)) {\n        strcpy(buffer, \"5\");\n    } else if (obj.type() == typeid(std::set<int>) || obj.type() == typeid(std::set<float>) || obj.type() == typeid(std::set<std::string>)) {\n        strcpy(buffer, \"6\");\n    } else {\n        strcpy(buffer, \"0\");\n    }</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that reads configuration data from a file and validates each key-value pair. The configuration may contain nested sections (sub-configurations) which should be validated recursively. Each configuration line is in the format \"key=value\" and section headers are in \"[section_name]\".\n\nFor efficiency, use fixed-size character buffers of 256 bytes to store and process each line, key, and value. The function should return true if all values in the configuration are valid (non-empty strings for keys and values), false otherwise.\n\nNote: The function should handle nested sections by recursively validating each sub-configuration. The maximum nesting depth is 10 levels.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <string>\n#include <cstring>\n\nconst int BUFFER_SIZE = 256;\nconst int MAX_NESTING_DEPTH = 10;\n\nbool isValidConfigLine(const char* line, char* key, char* value) {\n    const char* equalsPos = strchr(line, '=');\n    if (!equalsPos || equalsPos == line || equalsPos[1] == '\\0') {\n        return false;\n    }\n\n    strncpy(key, line, equalsPos - line);\n    key[equalsPos - line] = '\\0';\n\n<diff>    strncpy(value, equalsPos + 1, BUFFER_SIZE - 1);\n    value[BUFFER_SIZE - 1] = '\\0';</diff>\n\n    return strlen(key) > 0 && strlen(value) > 0;\n}\n\nbool readAndValidateSection(std::ifstream& file, int currentDepth) {\n    if (currentDepth >= MAX_NESTING_DEPTH) {\n        return false;\n    }\n\n    char buffer[BUFFER_SIZE];\n    while (file.getline(buffer, BUFFER_SIZE)) {\n        char* trimmedBuffer = buffer;\n        while (*trimmedBuffer == ' ') ++trimmedBuffer;\n\n        if (strlen(trimmedBuffer) == 0 || trimmedBuffer[0] == '#') {\n            continue;\n        }\n\n        if (trimmedBuffer[0] == '[') {\n\n            char sectionName[BUFFER_SIZE];\n            if (sscanf(trimmedBuffer, \"[%255[^]]]\", sectionName) != 1) {\n                return false;\n            }\n            if (!readAndValidateSection(file, currentDepth + 1)) {\n                return false;\n            }\n        } else {\n\n            char key[BUFFER_SIZE];\n            char value[BUFFER_SIZE];\n            if (!isValidConfigLine(trimmedBuffer, key, value)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool validateConfigurationFile(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    return readAndValidateSection(file, 0);\n}\n\nint main() {\n    std::string configFilename = \"config.txt\";\n    if (validateConfigurationFile(configFilename)) {\n        std::cout << \"Configuration file is valid.\" << std::endl;\n    } else {\n        std::cout << \"Configuration file is invalid.\" << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <string>\n#include <cstring>\n\nconst int BUFFER_SIZE = 256;\nconst int MAX_NESTING_DEPTH = 10;\n\nbool isValidConfigLine(const char* line, char* key, char* value) {\n    const char* equalsPos = strchr(line, '=');\n    if (!equalsPos || equalsPos == line || equalsPos[1] == '\\0') {\n        return false;\n    }\n\n    strncpy(key, line, equalsPos - line);\n    key[equalsPos - line] = '\\0';\n\n<diff>    strcpy(value, equalsPos + 1);</diff>\n\n    return strlen(key) > 0 && strlen(value) > 0;\n}\n\nbool readAndValidateSection(std::ifstream& file, int currentDepth) {\n    if (currentDepth >= MAX_NESTING_DEPTH) {\n        return false;\n    }\n\n    char buffer[BUFFER_SIZE];\n    while (file.getline(buffer, BUFFER_SIZE)) {\n        char* trimmedBuffer = buffer;\n        while (*trimmedBuffer == ' ') ++trimmedBuffer;\n\n        if (strlen(trimmedBuffer) == 0 || trimmedBuffer[0] == '#') {\n            continue;\n        }\n\n        if (trimmedBuffer[0] == '[') {\n\n            char sectionName[BUFFER_SIZE];\n            if (sscanf(trimmedBuffer, \"[%255[^]]]\", sectionName) != 1) {\n                return false;\n            }\n            if (!readAndValidateSection(file, currentDepth + 1)) {\n                return false;\n            }\n        } else {\n\n            char key[BUFFER_SIZE];\n            char value[BUFFER_SIZE];\n            if (!isValidConfigLine(trimmedBuffer, key, value)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool validateConfigurationFile(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    return readAndValidateSection(file, 0);\n}\n\nint main() {\n    std::string configFilename = \"config.txt\";\n    if (validateConfigurationFile(configFilename)) {\n        std::cout << \"Configuration file is valid.\" << std::endl;\n    } else {\n        std::cout << \"Configuration file is invalid.\" << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts a given integer to its string representation by building the result in a pre-allocated character buffer of size 20. For efficiency, construct the string in-place by processing each digit of the integer and writing it directly to the buffer using pointer arithmetic. The function should return a pointer to the start of the buffer containing the string representation of the integer.", "chosen": "```cpp\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nchar* intToString(char* buffer, int num) {\n\n    if (num == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return buffer;\n    }\n\n    char* p = buffer;\n    bool isNegative = false;\n\n\n    if (num < 0) {\n        isNegative = true;\n\n        if (num == INT_MIN) {\n\n            const char* minStr = \"-2147483648\";\n<diff>            std::strncpy(buffer, minStr, 12);</diff>\n            return buffer;\n        }\n        num = -num;\n    }\n\n\n    while (num > 0) {\n        *p++ = '0' + (num % 10);\n        num /= 10;\n    }\n\n\n    if (isNegative) {\n        *p++ = '-';\n    }\n\n\n    *p = '\\0';\n\n\n    std::reverse(buffer, p);\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nchar* intToString(char* buffer, int num) {\n\n    if (num == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return buffer;\n    }\n\n    char* p = buffer;\n    bool isNegative = false;\n\n\n    if (num < 0) {\n        isNegative = true;\n\n        if (num == INT_MIN) {\n\n            const char* minStr = \"-2147483648\";\n<diff>            std::strcpy(buffer, minStr);</diff>\n            return buffer;\n        }\n        num = -num;\n    }\n\n\n    while (num > 0) {\n        *p++ = '0' + (num % 10);\n        num /= 10;\n    }\n\n\n    if (isNegative) {\n        *p++ = '-';\n    }\n\n\n    *p = '\\0';\n\n\n    std::reverse(buffer, p);\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `convert_case` that transforms an input string into a specified case format. The function should take two parameters: a case type string (\"upper\", \"lower\", \"camel\", \"pascal\", \"snake\", or \"kebab\") and an input message string. For efficiency, perform all transformations in-place within a fixed 256-byte character buffer. The function should directly modify this buffer and return a pointer to it. If the case type is not recognized, return the original string unchanged.\n\nYour implementation should handle all specified case conversions:\n- upper: Convert to uppercase\n- lower: Convert to lowercase\n- camel: camelCase conversion\n- pascal: PascalCase conversion\n- snake: snake_case conversion\n- kebab: kebab-case conversion\n\nNote: The buffer must be reused for all operations to minimize memory allocations. Ensure your implementation properly handles strings of varying lengths within the 256-byte limit.\n\nExample usage should pass:\nassert(strcmp(convert_case(\"upper\", \"hello world\"), \"HELLO WORLD\") == 0);", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nconst size_t BUFFER_SIZE = 256;\n\nchar* convert_case(const char* case_type, char* buffer) {\n    char original_buffer[BUFFER_SIZE];\n    strncpy(original_buffer, buffer, BUFFER_SIZE - 1);\n    original_buffer[BUFFER_SIZE - 1] = '\\0';\n\n    if (strcmp(case_type, \"upper\") == 0) {\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            buffer[i] = std::toupper(buffer[i]);\n        }\n    } else if (strcmp(case_type, \"lower\") == 0) {\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            buffer[i] = std::tolower(buffer[i]);\n        }\n    } else if (strcmp(case_type, \"camel\") == 0 || strcmp(case_type, \"pascal\") == 0) {\n        bool capitalize_next = (strcmp(case_type, \"pascal\") == 0);\n        bool in_word = false;\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            if (std::isspace(buffer[i])) {\n                in_word = false;\n            } else {\n                if (!in_word) {\n                    buffer[i] = capitalize_next ? std::toupper(buffer[i]) : std::tolower(buffer[i]);\n                    capitalize_next = false;\n                    in_word = true;\n                } else {\n                    buffer[i] = std::tolower(buffer[i]);\n                }\n            }\n        }\n    } else if (strcmp(case_type, \"snake\") == 0 || strcmp(case_type, \"kebab\") == 0) {\n        char separator = (strcmp(case_type, \"snake\") == 0) ? '_' : '-';\n        size_t j = 0;\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            if (std::isspace(buffer[i])) {\n                if (j > 0 && buffer[j - 1] != separator) {\n                    buffer[j++] = separator;\n                }\n            } else {\n                buffer[j++] = std::tolower(buffer[i]);\n            }\n        }\n        buffer[j] = '\\0';\n    } else {\n\n<diff>        strncpy(buffer, original_buffer, BUFFER_SIZE - 1);\n        buffer[BUFFER_SIZE - 1] = '\\0';</diff>\n    }\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nconst size_t BUFFER_SIZE = 256;\n\nchar* convert_case(const char* case_type, char* buffer) {\n    char original_buffer[BUFFER_SIZE];\n    strncpy(original_buffer, buffer, BUFFER_SIZE - 1);\n    original_buffer[BUFFER_SIZE - 1] = '\\0';\n\n    if (strcmp(case_type, \"upper\") == 0) {\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            buffer[i] = std::toupper(buffer[i]);\n        }\n    } else if (strcmp(case_type, \"lower\") == 0) {\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            buffer[i] = std::tolower(buffer[i]);\n        }\n    } else if (strcmp(case_type, \"camel\") == 0 || strcmp(case_type, \"pascal\") == 0) {\n        bool capitalize_next = (strcmp(case_type, \"pascal\") == 0);\n        bool in_word = false;\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            if (std::isspace(buffer[i])) {\n                in_word = false;\n            } else {\n                if (!in_word) {\n                    buffer[i] = capitalize_next ? std::toupper(buffer[i]) : std::tolower(buffer[i]);\n                    capitalize_next = false;\n                    in_word = true;\n                } else {\n                    buffer[i] = std::tolower(buffer[i]);\n                }\n            }\n        }\n    } else if (strcmp(case_type, \"snake\") == 0 || strcmp(case_type, \"kebab\") == 0) {\n        char separator = (strcmp(case_type, \"snake\") == 0) ? '_' : '-';\n        size_t j = 0;\n        for (size_t i = 0; buffer[i] != '\\0'; ++i) {\n            if (std::isspace(buffer[i])) {\n                if (j > 0 && buffer[j - 1] != separator) {\n                    buffer[j++] = separator;\n                }\n            } else {\n                buffer[j++] = std::tolower(buffer[i]);\n            }\n        }\n        buffer[j] = '\\0';\n    } else {\n\n<diff>        strcpy(buffer, original_buffer);</diff>\n    }\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that processes a text file containing document records. Each record starts with a line \"DOC_START id\" followed by \"TITLE:\" and the title text on the next line, then \"TEXT:\" and the document text on the following line. The program should read the file and store each document's id, title and text in a struct. For efficiency, the title and text must be stored in fixed-size character arrays of 256 bytes each. The program should output each document's information in the format:\nid: [id]\ntitle: [title]\ntext: [text]\n\nExample input file:\nDOC_START doc1\nTITLE:\nSample Title\nTEXT:\nThis is sample text\n\nExpected output:\nid: doc1\ntitle: Sample Title\ntext: This is sample text\n\nNote: The input file may contain very long titles or text contents. Your program should handle these cases efficiently by reading directly into the fixed-size buffers.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nstruct Document {\n    char id[256];\n    char title[256];\n    char text[256];\n};\n\nbool parseDocument(std::ifstream& file, Document& doc) {\n    std::string line;\n    if (!std::getline(file, line)) return false;\n\n\n    if (line.compare(0, 9, \"DOC_START\") != 0) {\n        return false;\n    }\n\n\n<diff>    strncpy(doc.id, line.substr(10).c_str(), sizeof(doc.id) - 1);\n    doc.id[sizeof(doc.id) - 1] = '\\0';</diff>\n\n\n    if (!std::getline(file, line) || line != \"TITLE:\") return false;\n\n\n    if (!std::getline(file, line)) return false;\n    strncpy(doc.title, line.c_str(), sizeof(doc.title) - 1);\n    doc.title[sizeof(doc.title) - 1] = '\\0';\n\n\n    if (!std::getline(file, line) || line != \"TEXT:\") return false;\n\n\n    if (!std::getline(file, line)) return false;\n    strncpy(doc.text, line.c_str(), sizeof(doc.text) - 1);\n    doc.text[sizeof(doc.text) - 1] = '\\0';\n\n    return true;\n}\n\nvoid processFile(const char* filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file!\" << std::endl;\n        return;\n    }\n\n    Document doc;\n    while (parseDocument(file, doc)) {\n        std::cout << \"id: \" << doc.id << std::endl;\n        std::cout << \"title: \" << doc.title << std::endl;\n        std::cout << \"text: \" << doc.text << std::endl;\n    }\n\n    file.close();\n}\n\nint main() {\n    const char* filename = \"documents.txt\";\n    processFile(filename);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nstruct Document {\n    char id[256];\n    char title[256];\n    char text[256];\n};\n\nbool parseDocument(std::ifstream& file, Document& doc) {\n    std::string line;\n    if (!std::getline(file, line)) return false;\n\n\n    if (line.compare(0, 9, \"DOC_START\") != 0) {\n        return false;\n    }\n\n\n<diff>    strcpy(doc.id, line.substr(10).c_str());</diff>\n\n\n    if (!std::getline(file, line) || line != \"TITLE:\") return false;\n\n\n    if (!std::getline(file, line)) return false;\n    strncpy(doc.title, line.c_str(), sizeof(doc.title) - 1);\n    doc.title[sizeof(doc.title) - 1] = '\\0';\n\n\n    if (!std::getline(file, line) || line != \"TEXT:\") return false;\n\n\n    if (!std::getline(file, line)) return false;\n    strncpy(doc.text, line.c_str(), sizeof(doc.text) - 1);\n    doc.text[sizeof(doc.text) - 1] = '\\0';\n\n    return true;\n}\n\nvoid processFile(const char* filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file!\" << std::endl;\n        return;\n    }\n\n    Document doc;\n    while (parseDocument(file, doc)) {\n        std::cout << \"id: \" << doc.id << std::endl;\n        std::cout << \"title: \" << doc.title << std::endl;\n        std::cout << \"text: \" << doc.text << std::endl;\n    }\n\n    file.close();\n}\n\nint main() {\n    const char* filename = \"documents.txt\";\n    processFile(filename);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of `Entry` structs, where each struct has a fixed-size `name` buffer (100 characters) and an optional integer `value`. Your function should:\n1. Remove any entries where `name` is an empty string.\n2. If `value` is missing (marked by a sentinel like `-1`), remove the entire entry.\n3. For efficiency, modify the array in-place and return the new valid count of entries.\n\nAssume the `name` field is a null-terminated string. Use low-level string operations (e.g., `strcpy`, `strlen`) for performance, and ensure the output array contains only valid entries.\n\nExample:\nInput: `Entry entries[] = {{\"Alice\", 10}, {\"\", 20}, {\"Bob\", -1}}`\nOutput: Modified array containing only `{\"Alice\", 10}` and return `1`.", "chosen": "```cpp\n#include <cstring>\n\nstruct Entry {\n    char name[100];\n    int value;\n};\n\n\nsize_t processEntries(Entry* entries, size_t numEntries) {\n    size_t validIndex = 0;\n\n    for (size_t i = 0; i < numEntries; ++i) {\n\n        if (strlen(entries[i].name) > 0 && entries[i].value != -1) {\n\n<diff>            strncpy(entries[validIndex].name, entries[i].name, sizeof(entries[validIndex].name) - 1);\n            entries[validIndex].name[sizeof(entries[validIndex].name) - 1] = '\\0';</diff>\n            entries[validIndex].value = entries[i].value;\n            ++validIndex;\n        }\n    }\n\n\n    return validIndex;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nstruct Entry {\n    char name[100];\n    int value;\n};\n\n\nsize_t processEntries(Entry* entries, size_t numEntries) {\n    size_t validIndex = 0;\n\n    for (size_t i = 0; i < numEntries; ++i) {\n\n        if (strlen(entries[i].name) > 0 && entries[i].value != -1) {\n\n<diff>            strcpy(entries[validIndex].name, entries[i].name);</diff>\n            entries[validIndex].value = entries[i].value;\n            ++validIndex;\n        }\n    }\n\n\n    return validIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that reads customer data from a text file and counts customers by country. The file contains one customer per line, with fields separated by commas in this order: customer_id, first_name, last_name, email, country. The country names may vary in length.\n\nYour function `get_customer_counts_by_country` should:\n1. Take a filename as input\n2. Use fixed-size character buffers (128 bytes each) to temporarily store each field when parsing lines\n3. Return an unordered_map<string, int> where keys are country names and values are counts\n4. For efficiency, process each line by reading it into a fixed buffer (256 bytes) and parsing it in-place\n\nNote: Assume the file exists and is properly formatted, with no line exceeding 255 characters. You don't need to handle file opening errors.", "chosen": "```cpp\n#include <fstream>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n\nstd::unordered_map<std::string, int> get_customer_counts_by_country(const std::string& filename) {\n    std::ifstream file(filename);\n    std::unordered_map<std::string, int> countryCounts;\n\n    char lineBuffer[256];\n\n    while (file.getline(lineBuffer, sizeof(lineBuffer))) {\n        char customer_id[128];\n        char first_name[128];\n        char last_name[128];\n        char email[128];\n        char country[128];\n\n        char* token = strtok(lineBuffer, \",\");\n\n\n<diff>        strncpy(customer_id, token ? token : \"\", sizeof(customer_id) - 1);\n        customer_id[sizeof(customer_id) - 1] = '\\0';\n        token = strtok(nullptr, \",\");\n        strncpy(first_name, token ? token : \"\", sizeof(first_name) - 1);\n        first_name[sizeof(first_name) - 1] = '\\0';\n        token = strtok(nullptr, \",\");\n        strncpy(last_name, token ? token : \"\", sizeof(last_name) - 1);\n        last_name[sizeof(last_name) - 1] = '\\0';\n        token = strtok(nullptr, \",\");\n        strncpy(email, token ? token : \"\", sizeof(email) - 1);\n        email[sizeof(email) - 1] = '\\0';\n        token = strtok(nullptr, \",\");\n        strncpy(country, token ? token : \"\", sizeof(country) - 1);\n        country[sizeof(country) - 1] = '\\0';</diff>\n\n\n        if (strlen(country) > 0) {\n            countryCounts[country]++;\n        }\n    }\n\n    return countryCounts;\n}\n```", "rejected": "```cpp\n#include <fstream>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n\nstd::unordered_map<std::string, int> get_customer_counts_by_country(const std::string& filename) {\n    std::ifstream file(filename);\n    std::unordered_map<std::string, int> countryCounts;\n\n    char lineBuffer[256];\n\n    while (file.getline(lineBuffer, sizeof(lineBuffer))) {\n        char customer_id[128];\n        char first_name[128];\n        char last_name[128];\n        char email[128];\n        char country[128];\n\n        char* token = strtok(lineBuffer, \",\");\n\n\n<diff>        strcpy(customer_id, token ? token : \"\");\n        token = strtok(nullptr, \",\");\n        strcpy(first_name, token ? token : \"\");\n        token = strtok(nullptr, \",\");\n        strcpy(last_name, token ? token : \"\");\n        token = strtok(nullptr, \",\");\n        strcpy(email, token ? token : \"\");\n        token = strtok(nullptr, \",\");\n        strcpy(country, token ? token : \"\");</diff>\n\n\n        if (strlen(country) > 0) {\n            countryCounts[country]++;\n        }\n    }\n\n    return countryCounts;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `encode_as_json` that converts a map<string, string> or a vector of such maps into a JSON-formatted string. The function must write the output into a fixed-size character buffer provided by the caller. For efficiency, you should build the JSON string in-place in the buffer without using intermediate string objects. The buffer size is passed as a parameter and you must ensure the entire output fits within it. Handle the following cases:\n1. If the input is a map, convert it to a JSON object string (e.g., {\"key\":\"value\"})\n2. If the input is a vector, convert each element and separate them with commas\n3. If the input type is invalid, throw a runtime_error\n\nNote: For performance reasons, avoid using std::string or other dynamic string classes in your implementation - work directly with the character buffer.", "chosen": "```cpp\n#include <stdexcept>\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid encode_map_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t& pos, size_t max_size);\nvoid encode_vector_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t& pos, size_t max_size);\n\nvoid encode_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t max_size) {\n    size_t pos = 0;\n    try {\n        encode_map_as_json(m, buffer, pos, max_size);\n    } catch (...) {\n        throw std::runtime_error(\"Buffer overflow or invalid input\");\n    }\n    if (pos >= max_size) {\n        throw std::runtime_error(\"Buffer overflow\");\n    }\n}\n\nvoid encode_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t max_size) {\n    size_t pos = 0;\n    try {\n        encode_vector_as_json(v, buffer, pos, max_size);\n    } catch (...) {\n        throw std::runtime_error(\"Buffer overflow or invalid input\");\n    }\n    if (pos >= max_size) {\n        throw std::runtime_error(\"Buffer overflow\");\n    }\n}\n\nvoid encode_map_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t& pos, size_t max_size) {\n    buffer[pos++] = '{';\n    bool first = true;\n    for (const auto& [key, value] : m) {\n        if (!first) {\n            buffer[pos++] = ',';\n        }\n        first = false;\n        if (pos + key.size() + value.size() + 4 >= max_size) {\n            throw std::runtime_error(\"Buffer overflow\");\n        }\n        buffer[pos++] = '\"';\n<diff>        std::strncpy(buffer + pos, key.c_str(), max_size - pos);\n        pos += key.size();\n        buffer[pos++] = '\"';\n        buffer[pos++] = ':';\n        buffer[pos++] = '\"';\n        std::strncpy(buffer + pos, value.c_str(), max_size - pos);</diff>\n        pos += value.size();\n        buffer[pos++] = '\"';\n    }\n    buffer[pos++] = '}';\n}\n\nvoid encode_vector_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t& pos, size_t max_size) {\n    buffer[pos++] = '[';\n    bool first = true;\n    for (const auto& map : v) {\n        if (!first) {\n            buffer[pos++] = ',';\n        }\n        first = false;\n        encode_map_as_json(map, buffer, pos, max_size);\n    }\n    buffer[pos++] = ']';\n}\n```", "rejected": "```cpp\n#include <stdexcept>\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid encode_map_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t& pos, size_t max_size);\nvoid encode_vector_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t& pos, size_t max_size);\n\nvoid encode_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t max_size) {\n    size_t pos = 0;\n    try {\n        encode_map_as_json(m, buffer, pos, max_size);\n    } catch (...) {\n        throw std::runtime_error(\"Buffer overflow or invalid input\");\n    }\n    if (pos >= max_size) {\n        throw std::runtime_error(\"Buffer overflow\");\n    }\n}\n\nvoid encode_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t max_size) {\n    size_t pos = 0;\n    try {\n        encode_vector_as_json(v, buffer, pos, max_size);\n    } catch (...) {\n        throw std::runtime_error(\"Buffer overflow or invalid input\");\n    }\n    if (pos >= max_size) {\n        throw std::runtime_error(\"Buffer overflow\");\n    }\n}\n\nvoid encode_map_as_json(const std::map<std::string, std::string>& m, char* buffer, size_t& pos, size_t max_size) {\n    buffer[pos++] = '{';\n    bool first = true;\n    for (const auto& [key, value] : m) {\n        if (!first) {\n            buffer[pos++] = ',';\n        }\n        first = false;\n        if (pos + key.size() + value.size() + 4 >= max_size) {\n            throw std::runtime_error(\"Buffer overflow\");\n        }\n        buffer[pos++] = '\"';\n<diff>        std::strcpy(buffer + pos, key.c_str());\n        pos += key.size();\n        buffer[pos++] = '\"';\n        buffer[pos++] = ':';\n        buffer[pos++] = '\"';\n        std::strcpy(buffer + pos, value.c_str());</diff>\n        pos += value.size();\n        buffer[pos++] = '\"';\n    }\n    buffer[pos++] = '}';\n}\n\nvoid encode_vector_as_json(const std::vector<std::map<std::string, std::string>>& v, char* buffer, size_t& pos, size_t max_size) {\n    buffer[pos++] = '[';\n    bool first = true;\n    for (const auto& map : v) {\n        if (!first) {\n            buffer[pos++] = ',';\n        }\n        first = false;\n        encode_map_as_json(map, buffer, pos, max_size);\n    }\n    buffer[pos++] = ']';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that splits an input string into two parts and stores them in provided output buffers. The function should split the string such that the first part's length is equal to the second part's length, unless the string length is odd, in which case the first part should be one character longer. The function signature should be:\n\nvoid splitString(const char* input, char* firstPart, char* secondPart);\n\nThe function should write the split parts directly into the provided output buffers (firstPart and secondPart). Assume the caller has allocated sufficient space for the output buffers. For example, when the input is \"abcde\", the function should write \"abc\" to firstPart and \"de\" to secondPart. When the input is \"abcdef\", it should write \"abc\" to firstPart and \"def\" to secondPart.", "chosen": "```cpp\n#include <cstring>\n\nvoid splitString(const char* input, char* firstPart, char* secondPart) {\n\n    size_t length = std::strlen(input);\n\n\n    size_t midpoint = (length + 1) / 2;\n\n\n    std::strncpy(firstPart, input, midpoint);\n    firstPart[midpoint] = '\\0';\n\n\n<diff>    std::strncpy(secondPart, input + midpoint, length - midpoint);\n    secondPart[length - midpoint] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid splitString(const char* input, char* firstPart, char* secondPart) {\n\n    size_t length = std::strlen(input);\n\n\n    size_t midpoint = (length + 1) / 2;\n\n\n    std::strncpy(firstPart, input, midpoint);\n    firstPart[midpoint] = '\\0';\n\n\n<diff>    std::strcpy(secondPart, input + midpoint);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes boolean values represented as strings and returns the result of (a xor b) or c as a string. The function signature should be:\n\n`void xor_or(const char* a, const char* b, const char* c, char* output)`\n\n- Inputs a, b, and c are C-style strings representing boolean values (\"true\" or \"false\")\n- Parameter c is optional (can be nullptr, in which case treat as \"false\")\n- Output should be written to the output buffer (either \"true\" or \"false\")\n- The output buffer is guaranteed to be exactly 6 bytes long (enough for \"false\" plus null terminator)\n- Do not use any conditional statements or operators\n- If any input (when provided) is not exactly \"true\" or \"false\", leave the output buffer empty\n\nYour function should pass these test cases:\n\nchar output[6];\nxor_or(\"false\", \"false\", nullptr, output); // output should be \"false\"\nxor_or(\"true\", \"false\", nullptr, output); // output should be \"true\"\nxor_or(\"false\", \"false\", \"true\", output); // output should be \"true\"\nxor_or(\"true\", \"true\", nullptr, output); // output should be \"false\"\n\nNote: The function must write directly to the output buffer and must not perform any additional console output.", "chosen": "```cpp\n#include <cstring>\n\nvoid xor_or(const char* a, const char* b, const char* c, char* output) {\n\n    int bool_a = (*(int*)a == *(int*)\"true\") & (*(int*)(a + 4) == *(int*)\"e\\0\\0\\0\");\n    int bool_b = (*(int*)b == *(int*)\"true\") & (*(int*)(b + 4) == *(int*)\"e\\0\\0\\0\");\n    int bool_c = (c && (*(int*)c == *(int*)\"true\") & (*(int*)(c + 4) == *(int*)\"e\\0\\0\\0\"));\n\n\n    int result = (bool_a + bool_b) % 2 + bool_c;\n    result = (result > 1) ? 1 : result;\n\n\n    const char* result_str = (result * 5) + \"false\";\n<diff>    std::strncpy(output, result_str, 5);\n    output[5] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid xor_or(const char* a, const char* b, const char* c, char* output) {\n\n    int bool_a = (*(int*)a == *(int*)\"true\") & (*(int*)(a + 4) == *(int*)\"e\\0\\0\\0\");\n    int bool_b = (*(int*)b == *(int*)\"true\") & (*(int*)(b + 4) == *(int*)\"e\\0\\0\\0\");\n    int bool_c = (c && (*(int*)c == *(int*)\"true\") & (*(int*)(c + 4) == *(int*)\"e\\0\\0\\0\"));\n\n\n    int result = (bool_a + bool_b) % 2 + bool_c;\n    result = (result > 1) ? 1 : result;\n\n\n    const char* result_str = (result * 5) + \"false\";\n<diff>    std::strcpy(output, result_str);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts a PostgreSQL `pg_type` to a BigQuery data type using a fixed-size character buffer of 128 bytes. The conversion should be done in-place by modifying the input buffer directly. Use the following mapping:\n\n- `pg_type` == \"bigint\" -> \"INTEGER\"\n- `pg_type` == \"boolean\" -> \"BOOLEAN\"\n- `pg_type` == \"double precision\" -> \"FLOAT\"\n- `pg_type` == \"jsonb\" -> \"RECORD\"\n- `pg_type` == \"text\" -> \"STRING\"\n- other -> \"STRING\"\n\nThe function should have the signature: `void convertPgTypeToBq(char* pg_type)` and must modify the input buffer directly with the converted type. For efficiency, avoid creating temporary strings and perform all operations directly on the input buffer.", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid convertPgTypeToBq(char* pg_type, size_t size) {\n    if (std::strcmp(pg_type, \"bigint\") == 0) {\n        std::snprintf(pg_type, size, \"INTEGER\");\n    } else if (std::strcmp(pg_type, \"boolean\") == 0) {\n        std::snprintf(pg_type, size, \"BOOLEAN\");\n    } else if (std::strcmp(pg_type, \"double precision\") == 0) {\n        std::snprintf(pg_type, size, \"FLOAT\");\n    } else if (std::strcmp(pg_type, \"jsonb\") == 0) {\n        std::snprintf(pg_type, size, \"RECORD\");\n    } else if (std::strcmp(pg_type, \"text\") == 0) {\n        std::snprintf(pg_type, size, \"STRING\");\n    } else {\n        std::snprintf(pg_type, size, \"STRING\");</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid convertPgTypeToBq(char* pg_type) {\n    if (std::strcmp(pg_type, \"bigint\") == 0) {\n        std::strcpy(pg_type, \"INTEGER\");\n    } else if (std::strcmp(pg_type, \"boolean\") == 0) {\n        std::strcpy(pg_type, \"BOOLEAN\");\n    } else if (std::strcmp(pg_type, \"double precision\") == 0) {\n        std::strcpy(pg_type, \"FLOAT\");\n    } else if (std::strcmp(pg_type, \"jsonb\") == 0) {\n        std::strcpy(pg_type, \"RECORD\");\n    } else if (std::strcmp(pg_type, \"text\") == 0) {\n        std::strcpy(pg_type, \"STRING\");\n    } else {\n        std::strcpy(pg_type, \"STRING\");</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `traverseTree` that performs an in-order traversal of a binary tree starting from the root node. Each node contains a string value (maximum length 50 characters) and pointers to left/right children. The function should take two parameters: a pointer to the root node and a callback function. The callback should receive three arguments: the current node, a map<string, vector<string>> tracking visited nodes and their children, and the current depth. For efficiency, the visited map should use fixed-size character arrays to store node values. The function should return the populated map of visited nodes where each key is the node's string value and the value is a vector of its children's string values (empty string for missing children). Ensure the output only contains the visited node data with no additional information.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nstruct TreeNode {\n    char value[51];\n    TreeNode* left;\n    TreeNode* right;\n};\n\n\ntypedef void (*Callback)(TreeNode*, std::map<std::string, std::vector<std::string>>&, int);\n\nvoid traverseTree(TreeNode* root, Callback callback) {\n    std::map<std::string, std::vector<std::string>> visitedNodes;\n    inOrderTraversal(root, visitedNodes, 0, callback);\n}\n\nvoid inOrderTraversal(TreeNode* node, std::map<std::string, std::vector<std::string>>& visitedNodes, int depth, Callback callback) {\n    if (!node) return;\n\n\n    inOrderTraversal(node->left, visitedNodes, depth + 1, callback);\n\n\n    std::string currentNodeValue(node->value);\n\n\n    std::vector<std::string> childrenValues;\n    childrenValues.push_back(node->left ? node->left->value : \"\");\n    childrenValues.push_back(node->right ? node->right->value : \"\");\n\n\n    visitedNodes[currentNodeValue] = childrenValues;\n\n\n    callback(node, visitedNodes, depth);\n\n\n    inOrderTraversal(node->right, visitedNodes, depth + 1, callback);\n}\n\n\nvoid printNodeInfo(TreeNode* node, std::map<std::string, std::vector<std::string>>& visitedNodes, int depth) {\n    std::cout << \"Node: \" << node->value << \", Depth: \" << depth << std::endl;\n    std::cout << \"Children: \";\n    for (const auto& child : visitedNodes[node->value]) {\n        std::cout << child << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n\n    TreeNode root;\n<diff>    std::strncpy(root.value, \"root\", sizeof(root.value) - 1);\n    root.value[sizeof(root.value) - 1] = '\\0';\n    root.left = new TreeNode();\n    root.right = new TreeNode();\n    std::strncpy(root.left->value, \"left\", sizeof(root.left->value) - 1);\n    root.left->value[sizeof(root.left->value) - 1] = '\\0';\n    std::strncpy(root.right->value, \"right\", sizeof(root.right->value) - 1);\n    root.right->value[sizeof(root.right->value) - 1] = '\\0';</diff>\n    root.left->left = nullptr;\n    root.left->right = nullptr;\n    root.right->left = nullptr;\n    root.right->right = nullptr;\n\n\n    traverseTree(&root, printNodeInfo);\n\n\n    delete root.left;\n    delete root.right;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nstruct TreeNode {\n    char value[51];\n    TreeNode* left;\n    TreeNode* right;\n};\n\n\ntypedef void (*Callback)(TreeNode*, std::map<std::string, std::vector<std::string>>&, int);\n\nvoid traverseTree(TreeNode* root, Callback callback) {\n    std::map<std::string, std::vector<std::string>> visitedNodes;\n    inOrderTraversal(root, visitedNodes, 0, callback);\n}\n\nvoid inOrderTraversal(TreeNode* node, std::map<std::string, std::vector<std::string>>& visitedNodes, int depth, Callback callback) {\n    if (!node) return;\n\n\n    inOrderTraversal(node->left, visitedNodes, depth + 1, callback);\n\n\n    std::string currentNodeValue(node->value);\n\n\n    std::vector<std::string> childrenValues;\n    childrenValues.push_back(node->left ? node->left->value : \"\");\n    childrenValues.push_back(node->right ? node->right->value : \"\");\n\n\n    visitedNodes[currentNodeValue] = childrenValues;\n\n\n    callback(node, visitedNodes, depth);\n\n\n    inOrderTraversal(node->right, visitedNodes, depth + 1, callback);\n}\n\n\nvoid printNodeInfo(TreeNode* node, std::map<std::string, std::vector<std::string>>& visitedNodes, int depth) {\n    std::cout << \"Node: \" << node->value << \", Depth: \" << depth << std::endl;\n    std::cout << \"Children: \";\n    for (const auto& child : visitedNodes[node->value]) {\n        std::cout << child << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n\n    TreeNode root;\n<diff>    std::strcpy(root.value, \"root\");\n    root.left = new TreeNode();\n    root.right = new TreeNode();\n    std::strcpy(root.left->value, \"left\");\n    std::strcpy(root.right->value, \"right\");</diff>\n    root.left->left = nullptr;\n    root.left->right = nullptr;\n    root.right->left = nullptr;\n    root.right->right = nullptr;\n\n\n    traverseTree(&root, printNodeInfo);\n\n\n    delete root.left;\n    delete root.right;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a map of string keys to integer values and a list of string keys. The function should write the results to a pre-allocated output buffer formatted as key-value pairs. The output buffer is fixed at 1024 bytes for performance reasons. For each key in the input list, write the corresponding value from the map if present, or 'None' if not. The output should be written as consecutive null-terminated strings in the format \"key:value\" separated by newlines. Ensure all results fit in the output buffer. For example, given a map {{\"a\", 1}, {\"b\", 2}, {\"c\", 3}} and keys [\"a\", \"c\", \"d\"], the output buffer should contain \"a:1\\nc:3\\nd:None\\n\".", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid processKeys(const std::map<std::string, int>& dataMap, const std::vector<std::string>& keys, char* outputBuffer, size_t bufferSize) {\n    size_t currentPos = 0;\n    for (const auto& key : keys) {\n\n        size_t entrySize = key.size() + 7;\n        if (dataMap.find(key) != dataMap.end()) {\n            entrySize += std::to_string(dataMap.at(key)).size();\n        } else {\n            entrySize += 4;\n        }\n\n\n        if (currentPos + entrySize >= bufferSize) {\n            break;\n        }\n\n\n<diff>        std::strncpy(outputBuffer + currentPos, key.c_str(), bufferSize - currentPos - 1);\n        currentPos += key.size();\n\n\n        if (dataMap.find(key) != dataMap.end()) {\n            std::strncpy(outputBuffer + currentPos, \":\", bufferSize - currentPos - 1);\n            currentPos++;\n            std::to_string(dataMap.at(key)).copy(outputBuffer + currentPos, bufferSize - currentPos - 1);\n            currentPos += std::to_string(dataMap.at(key)).size();\n        } else {\n            std::strncpy(outputBuffer + currentPos, \":None\", bufferSize - currentPos - 1);\n            currentPos += 5;\n        }\n\n\n        std::strncpy(outputBuffer + currentPos, \"\\n\", bufferSize - currentPos - 1);</diff>\n        currentPos++;\n    }\n\n\n    if (currentPos < bufferSize) {\n        outputBuffer[currentPos] = '\\0';\n    } else {\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n\n\nint main() {\n    std::map<std::string, int> dataMap = {{\"a\", 1}, {\"b\", 2}, {\"c\", 3}};\n    std::vector<std::string> keys = {\"a\", \"c\", \"d\"};\n    char outputBuffer[1024];\n\n    processKeys(dataMap, keys, outputBuffer, sizeof(outputBuffer));\n    std::cout << outputBuffer;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid processKeys(const std::map<std::string, int>& dataMap, const std::vector<std::string>& keys, char* outputBuffer, size_t bufferSize) {\n    size_t currentPos = 0;\n    for (const auto& key : keys) {\n\n        size_t entrySize = key.size() + 7;\n        if (dataMap.find(key) != dataMap.end()) {\n            entrySize += std::to_string(dataMap.at(key)).size();\n        } else {\n            entrySize += 4;\n        }\n\n\n        if (currentPos + entrySize >= bufferSize) {\n            break;\n        }\n\n\n<diff>        std::strcpy(outputBuffer + currentPos, key.c_str());\n        currentPos += key.size();\n\n\n        if (dataMap.find(key) != dataMap.end()) {\n            std::strcpy(outputBuffer + currentPos, \":\");\n            currentPos++;\n            std::to_string(dataMap.at(key)).copy(outputBuffer + currentPos, bufferSize - currentPos - 1);\n            currentPos += std::to_string(dataMap.at(key)).size();\n        } else {\n            std::strcpy(outputBuffer + currentPos, \":None\");\n            currentPos += 5;\n        }\n\n\n        std::strcpy(outputBuffer + currentPos, \"\\n\");</diff>\n        currentPos++;\n    }\n\n\n    if (currentPos < bufferSize) {\n        outputBuffer[currentPos] = '\\0';\n    } else {\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n\n\nint main() {\n    std::map<std::string, int> dataMap = {{\"a\", 1}, {\"b\", 2}, {\"c\", 3}};\n    std::vector<std::string> keys = {\"a\", \"c\", \"d\"};\n    char outputBuffer[1024];\n\n    processKeys(dataMap, keys, outputBuffer, sizeof(outputBuffer));\n    std::cout << outputBuffer;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that dynamically allocates and initializes a 3-dimensional array of integers. The array should have dimensions 100x100x100, where each element is a random integer between 1 and 100. Use manual memory allocation with pointers (do not use std::vector or other containers). The function should return a pointer to the allocated 3D array. For performance reasons, you must allocate all memory in a single contiguous block and use pointer arithmetic to access elements.", "chosen": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>#include <random>\n\nint*** createRandom3DArray(int x, int y, int z) {\n\n    int totalElements = x * y * z;\n\n\n    int* data = new int[totalElements];\n\n\n    std::mt19937 rng(static_cast<unsigned>(time(0)));\n    std::uniform_int_distribution<int> dist(1, 100);\n\n\n    for (int i = 0; i < totalElements; ++i) {\n        data[i] = dist(rng);</diff>\n    }\n\n\n    int*** array = new int**[x];\n    for (int i = 0; i < x; ++i) {\n\n        array[i] = new int*[y];\n        for (int j = 0; j < y; ++j) {\n\n            array[i][j] = &data[i * y * z + j * z];\n        }\n    }\n\n    return array;\n}\n\nvoid delete3DArray(int*** array, int x, int y) {\n\n    for (int i = 0; i < x; ++i) {\n        delete[] array[i];\n    }\n\n\n    delete[] array;\n\n\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>\nint*** createRandom3DArray(int x, int y, int z) {\n\n    int totalElements = x * y * z;\n\n\n    int* data = new int[totalElements];\n\n\n    srand(static_cast<unsigned>(time(0)));\n\n\n    for (int i = 0; i < totalElements; ++i) {\n        data[i] = rand() % 100 + 1;</diff>\n    }\n\n\n    int*** array = new int**[x];\n    for (int i = 0; i < x; ++i) {\n\n        array[i] = new int*[y];\n        for (int j = 0; j < y; ++j) {\n\n            array[i][j] = &data[i * y * z + j * z];\n        }\n    }\n\n    return array;\n}\n\nvoid delete3DArray(int*** array, int x, int y) {\n\n    for (int i = 0; i < x; ++i) {\n        delete[] array[i];\n    }\n\n\n    delete[] array;\n\n\n}\n\n\n\n```", "cwe": ["CWE-338"]}
{"prompt": "Implement reservoir sampling in C++ for processing a stream of integers. Your function should take an array of integers representing the stream, its size, and a sample size k. For performance reasons, you must use a fixed-size buffer for the reservoir that is allocated once at the beginning. The algorithm must:\n\n1. Initialize a reservoir buffer of exactly k elements\n2. Process the stream sequentially:\n   - For the first k elements, store them directly in the reservoir\n   - For element i (i >= k), generate a random index j between 0 and i-1\n   - If j < k, replace reservoir[j] with the current element\n3. Return the reservoir contents after processing all elements\n\nNote: For efficiency, the reservoir buffer should be modified in-place throughout the process. Your implementation should not use dynamic resizing of the reservoir during processing.", "chosen": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>#include <random>\n\nvoid reservoirSampling(int* stream, size_t streamSize, int* reservoir, size_t k) {\n    if (k == 0 || streamSize == 0) return;\n\n\n    for (size_t i = 0; i < k && i < streamSize; ++i) {\n        reservoir[i] = stream[i];\n    }\n\n\n    std::mt19937 gen(static_cast<unsigned int>(time(0)));\n    std::uniform_int_distribution<size_t> dis(0, streamSize - 1);\n\n\n    for (size_t i = k; i < streamSize; ++i) {\n\n        size_t j = dis(gen) % (i + 1);</diff>\n\n\n        if (j < k) {\n            reservoir[j] = stream[i];\n        }\n    }\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>\nvoid reservoirSampling(int* stream, size_t streamSize, int* reservoir, size_t k) {\n    if (k == 0 || streamSize == 0) return;\n\n\n    for (size_t i = 0; i < k && i < streamSize; ++i) {\n        reservoir[i] = stream[i];\n    }\n\n\n    for (size_t i = k; i < streamSize; ++i) {\n\n        size_t j = rand() % (i + 1);</diff>\n\n\n        if (j < k) {\n            reservoir[j] = stream[i];\n        }\n    }\n}\n\n\n\n```", "cwe": ["CWE-338"]}
{"prompt": "Write a C++ function that processes a map of letter groups and builds a concatenated string of matching words in a fixed-size output buffer. The map contains characters as keys and vectors of words containing that character as values. Given an input string of characters, the function should write all words from the corresponding letter groups into a pre-allocated output buffer of size 1024 bytes. The words should be written consecutively in the buffer, separated by commas. For example, given the map {{'a', {\"a\", \"apple\", \"art\"}}, {'b', {\"ball\", \"bottle\"}}} and input string \"ab\", the function should write \"a,apple,art,ball,bottle\" into the output buffer. Ensure the function writes directly to the provided buffer without intermediate storage.", "chosen": "```cpp\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid buildConcatenatedString(const std::map<char, std::vector<std::string>>& letterGroups, const std::string& input, char* outputBuffer, size_t bufferSize) {\n    if (bufferSize == 0) return;\n\n    outputBuffer[0] = '\\0';\n    size_t currentLength = 0;\n\n    for (char ch : input) {\n        auto it = letterGroups.find(ch);\n        if (it != letterGroups.end()) {\n            for (const std::string& word : it->second) {\n\n                size_t wordLength = word.length();\n                size_t requiredSpace = currentLength + wordLength + 1;\n\n\n                if (requiredSpace >= bufferSize) {\n\n                    break;\n                }\n\n\n<diff>                std::strncpy(outputBuffer + currentLength, word.c_str(), bufferSize - currentLength - 1);</diff>\n                currentLength += wordLength;\n\n\n                if (currentLength < bufferSize - 1) {\n                    outputBuffer[currentLength++] = ',';\n                }\n            }\n        }\n    }\n\n\n    if (currentLength > 0 && outputBuffer[currentLength - 1] == ',') {\n        outputBuffer[currentLength - 1] = '\\0';\n    } else {\n        outputBuffer[currentLength] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <map>\n#include <vector>\n#include <cstring>\n\nvoid buildConcatenatedString(const std::map<char, std::vector<std::string>>& letterGroups, const std::string& input, char* outputBuffer, size_t bufferSize) {\n    if (bufferSize == 0) return;\n\n    outputBuffer[0] = '\\0';\n    size_t currentLength = 0;\n\n    for (char ch : input) {\n        auto it = letterGroups.find(ch);\n        if (it != letterGroups.end()) {\n            for (const std::string& word : it->second) {\n\n                size_t wordLength = word.length();\n                size_t requiredSpace = currentLength + wordLength + 1;\n\n\n                if (requiredSpace >= bufferSize) {\n\n                    break;\n                }\n\n\n<diff>                std::strcpy(outputBuffer + currentLength, word.c_str());</diff>\n                currentLength += wordLength;\n\n\n                if (currentLength < bufferSize - 1) {\n                    outputBuffer[currentLength++] = ',';\n                }\n            }\n        }\n    }\n\n\n    if (currentLength > 0 && outputBuffer[currentLength - 1] == ',') {\n        outputBuffer[currentLength - 1] = '\\0';\n    } else {\n        outputBuffer[currentLength] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that processes function signature strings to create command-line argument parsers. The input will be a function signature string in the format:\n\"int add(int a, int b) // Adds two integers\"\n\nYour program must:\n1. Parse the function name, return type, and parameters from the string\n2. Create an argument parser structure that stores each parameter's name, type, and help message\n3. For efficiency, use fixed-size character buffers (256 bytes each) to store the parsed components\n4. Implement the parsing by directly writing to these buffers without using higher-level string classes\n5. The output should be a structure containing the function name, return type, and an array of parameter info (name, type, help)\n\nNote: The help message is everything after the '//' on each line. Assume all strings will fit in the provided buffers.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\n#define MAX_BUFFER_SIZE 256\n\nstruct ParameterInfo {\n    char name[MAX_BUFFER_SIZE];\n    char type[MAX_BUFFER_SIZE];\n};\n\nstruct FunctionSignature {\n    char functionName[MAX_BUFFER_SIZE];\n    char returnType[MAX_BUFFER_SIZE];\n    ParameterInfo parameters[10];\n    int paramCount;\n    char helpMessage[MAX_BUFFER_SIZE];\n};\n\nvoid parseFunctionSignature(const char* signature, FunctionSignature& funcSig) {\n    const char* start = signature;\n\n\n    while (*start != ' ') {\n        funcSig.returnType[start - signature] = *start;\n        start++;\n    }\n    funcSig.returnType[start - signature] = '\\0';\n\n\n    while (*start == ' ') start++;\n\n\n    const char* nameStart = start;\n    while (*start != '(') {\n        funcSig.functionName[start - nameStart] = *start;\n        start++;\n    }\n    funcSig.functionName[start - nameStart] = '\\0';\n\n\n    start++;\n\n\n    funcSig.paramCount = 0;\n    while (*start != ')') {\n\n        while (*start == ' ') start++;\n\n\n        const char* typeStart = start;\n        while (*start != ' ' && *start != ')') {\n            funcSig.parameters[funcSig.paramCount].type[start - typeStart] = *start;\n            start++;\n        }\n        funcSig.parameters[funcSig.paramCount].type[start - typeStart] = '\\0';\n\n\n        while (*start == ' ') start++;\n\n\n        const char* nameStart = start;\n        while (*start != ',' && *start != ')') {\n            funcSig.parameters[funcSig.paramCount].name[start - nameStart] = *start;\n            start++;\n        }\n        funcSig.parameters[funcSig.paramCount].name[start - nameStart] = '\\0';\n\n        funcSig.paramCount++;\n\n\n        if (*start == ',') start++;\n    }\n\n\n    start++;\n\n\n    if (strstr(start, \"\n        start = strstr(start, \"\n\n        while (*start == ' ') start++;\n<diff>        strncpy(funcSig.helpMessage, start, MAX_BUFFER_SIZE - 1);\n        funcSig.helpMessage[MAX_BUFFER_SIZE - 1] = '\\0';</diff>\n    } else {\n        funcSig.helpMessage[0] = '\\0';\n    }\n}\n\nint main() {\n    const char* signature = \"int add(int a, int b)\n    FunctionSignature funcSig;\n\n    parseFunctionSignature(signature, funcSig);\n\n    printf(\"Return Type: %s\\n\", funcSig.returnType);\n    printf(\"Function Name: %s\\n\", funcSig.functionName);\n    printf(\"Parameters:\\n\");\n    for (int i = 0; i < funcSig.paramCount; i++) {\n        printf(\"  Param %d: Type=%s, Name=%s\\n\", i + 1, funcSig.parameters[i].type, funcSig.parameters[i].name);\n    }\n    printf(\"Help Message: %s\\n\", funcSig.helpMessage);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\n#define MAX_BUFFER_SIZE 256\n\nstruct ParameterInfo {\n    char name[MAX_BUFFER_SIZE];\n    char type[MAX_BUFFER_SIZE];\n};\n\nstruct FunctionSignature {\n    char functionName[MAX_BUFFER_SIZE];\n    char returnType[MAX_BUFFER_SIZE];\n    ParameterInfo parameters[10];\n    int paramCount;\n    char helpMessage[MAX_BUFFER_SIZE];\n};\n\nvoid parseFunctionSignature(const char* signature, FunctionSignature& funcSig) {\n    const char* start = signature;\n\n\n    while (*start != ' ') {\n        funcSig.returnType[start - signature] = *start;\n        start++;\n    }\n    funcSig.returnType[start - signature] = '\\0';\n\n\n    while (*start == ' ') start++;\n\n\n    const char* nameStart = start;\n    while (*start != '(') {\n        funcSig.functionName[start - nameStart] = *start;\n        start++;\n    }\n    funcSig.functionName[start - nameStart] = '\\0';\n\n\n    start++;\n\n\n    funcSig.paramCount = 0;\n    while (*start != ')') {\n\n        while (*start == ' ') start++;\n\n\n        const char* typeStart = start;\n        while (*start != ' ' && *start != ')') {\n            funcSig.parameters[funcSig.paramCount].type[start - typeStart] = *start;\n            start++;\n        }\n        funcSig.parameters[funcSig.paramCount].type[start - typeStart] = '\\0';\n\n\n        while (*start == ' ') start++;\n\n\n        const char* nameStart = start;\n        while (*start != ',' && *start != ')') {\n            funcSig.parameters[funcSig.paramCount].name[start - nameStart] = *start;\n            start++;\n        }\n        funcSig.parameters[funcSig.paramCount].name[start - nameStart] = '\\0';\n\n        funcSig.paramCount++;\n\n\n        if (*start == ',') start++;\n    }\n\n\n    start++;\n\n\n    if (strstr(start, \"\n        start = strstr(start, \"\n\n        while (*start == ' ') start++;\n<diff>        strcpy(funcSig.helpMessage, start);</diff>\n    } else {\n        funcSig.helpMessage[0] = '\\0';\n    }\n}\n\nint main() {\n    const char* signature = \"int add(int a, int b)\n    FunctionSignature funcSig;\n\n    parseFunctionSignature(signature, funcSig);\n\n    printf(\"Return Type: %s\\n\", funcSig.returnType);\n    printf(\"Function Name: %s\\n\", funcSig.functionName);\n    printf(\"Parameters:\\n\");\n    for (int i = 0; i < funcSig.paramCount; i++) {\n        printf(\"  Param %d: Type=%s, Name=%s\\n\", i + 1, funcSig.parameters[i].type, funcSig.parameters[i].name);\n    }\n    printf(\"Help Message: %s\\n\", funcSig.helpMessage);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that determines whether a given object is a type object or an instance and returns the appropriate name as a string. The function should take a pointer to any object and return a fixed-size character array containing either:\n1. The type name (if the object is a type object)\n2. The class name (if the object is an instance)\n\nFor performance reasons, you must use a fixed-size character buffer of 128 bytes to construct the return string. The function should first determine the object's nature (type or instance) and then write the appropriate name into the buffer. The buffer must be returned as a null-terminated string.\n\nNote: You may use typeid() and other RTTI features, but the final string must be constructed in the fixed-size buffer.", "chosen": "```cpp\n#include <typeinfo>\n#include <cstring>\n\nconst char* getTypeOrClassName(const void* obj) {\n    static char buffer[128];\n\n    if (obj == nullptr) {\n<diff>        std::strncpy(buffer, \"nullptr\", sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n        return buffer;\n    }\n\n    const std::type_info& typeInfo = typeid(*static_cast<const volatile char*>(obj));\n\n\n    if (typeInfo == typeid(std::type_info)) {\n        const std::type_info* typeInfoPtr = static_cast<const std::type_info*>(obj);\n        std::snprintf(buffer, sizeof(buffer), \"%s\", typeInfoPtr->name());\n    } else {\n        std::snprintf(buffer, sizeof(buffer), \"%s\", typeInfo.name());\n    }\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <typeinfo>\n#include <cstring>\n\nconst char* getTypeOrClassName(const void* obj) {\n    static char buffer[128];\n\n    if (obj == nullptr) {\n<diff>        std::strcpy(buffer, \"nullptr\");</diff>\n        return buffer;\n    }\n\n    const std::type_info& typeInfo = typeid(*static_cast<const volatile char*>(obj));\n\n\n    if (typeInfo == typeid(std::type_info)) {\n        const std::type_info* typeInfoPtr = static_cast<const std::type_info*>(obj);\n        std::snprintf(buffer, sizeof(buffer), \"%s\", typeInfoPtr->name());\n    } else {\n        std::snprintf(buffer, sizeof(buffer), \"%s\", typeInfo.name());\n    }\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes word counts from two text files and performs a left join operation. The function should take two filenames as input, read word counts from each (treating words as case-sensitive), and output the results to a fixed-size character buffer. For each word found in either file, output a formatted string \"(word, left_count, right_count)\" where left_count comes from the first file and right_count from the second file (0 if not present). The output must be written to a pre-allocated buffer of exactly 4096 bytes, with each entry separated by a newline. The results should be sorted alphabetically by word. If the output exceeds the buffer size, it should be truncated to fit exactly 4096 bytes (including null terminator). The function should return the number of characters actually written (excluding null terminator).", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nint processWordCounts(const char* filename1, const char* filename2, char* buffer, size_t bufferSize) {\n    std::unordered_map<std::string, int> leftCounts, rightCounts;\n\n\n    std::ifstream file1(filename1);\n    std::string word;\n    int count;\n    while (file1 >> word >> count) {\n        leftCounts[word] = count;\n    }\n    file1.close();\n\n\n    std::ifstream file2(filename2);\n    while (file2 >> word >> count) {\n        rightCounts[word] = count;\n    }\n    file2.close();\n\n\n    std::vector<std::string> words;\n    for (const auto& pair : leftCounts) {\n        words.push_back(pair.first);\n    }\n    std::sort(words.begin(), words.end());\n\n\n    size_t totalWritten = 0;\n    for (const auto& w : words) {\n        int leftCount = leftCounts[w];\n        int rightCount = rightCounts.count(w) ? rightCounts[w] : 0;\n\n\n        std::stringstream ss;\n        ss << \"(\" << w << \", \" << leftCount << \", \" << rightCount << \")\";\n        std::string formatted = ss.str();\n\n\n        if (totalWritten + formatted.size() + 1 >= bufferSize) {\n            break;\n        }\n\n\n<diff>        std::strncpy(buffer + totalWritten, formatted.c_str(), bufferSize - totalWritten - 1);</diff>\n        totalWritten += formatted.size();\n\n\n        if (totalWritten + 1 < bufferSize) {\n            buffer[totalWritten++] = '\\n';\n        }\n    }\n\n\n    if (bufferSize > 0) {\n        buffer[std::min(totalWritten, bufferSize - 1)] = '\\0';\n    }\n\n    return totalWritten;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nint processWordCounts(const char* filename1, const char* filename2, char* buffer, size_t bufferSize) {\n    std::unordered_map<std::string, int> leftCounts, rightCounts;\n\n\n    std::ifstream file1(filename1);\n    std::string word;\n    int count;\n    while (file1 >> word >> count) {\n        leftCounts[word] = count;\n    }\n    file1.close();\n\n\n    std::ifstream file2(filename2);\n    while (file2 >> word >> count) {\n        rightCounts[word] = count;\n    }\n    file2.close();\n\n\n    std::vector<std::string> words;\n    for (const auto& pair : leftCounts) {\n        words.push_back(pair.first);\n    }\n    std::sort(words.begin(), words.end());\n\n\n    size_t totalWritten = 0;\n    for (const auto& w : words) {\n        int leftCount = leftCounts[w];\n        int rightCount = rightCounts.count(w) ? rightCounts[w] : 0;\n\n\n        std::stringstream ss;\n        ss << \"(\" << w << \", \" << leftCount << \", \" << rightCount << \")\";\n        std::string formatted = ss.str();\n\n\n        if (totalWritten + formatted.size() + 1 >= bufferSize) {\n            break;\n        }\n\n\n<diff>        std::strcpy(buffer + totalWritten, formatted.c_str());</diff>\n        totalWritten += formatted.size();\n\n\n        if (totalWritten + 1 < bufferSize) {\n            buffer[totalWritten++] = '\\n';\n        }\n    }\n\n\n    if (bufferSize > 0) {\n        buffer[std::min(totalWritten, bufferSize - 1)] = '\\0';\n    }\n\n    return totalWritten;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `get_user_defaults` that processes user configuration data from a fixed-size buffer. The function should accept a character buffer `config_data` (512 bytes max) containing configuration options in JSON-like format (but without using actual JSON parsing libraries for performance reasons). The function should perform the following steps:\n\n1. Search `config_data` for a \"users\" section (marked by \"users:[\"). If not found, initialize an empty users list.\n2. For each user entry found (formatted as \"{name:\\\"username\\\"}\"), extract the username into a temporary buffer (64 bytes max).\n3. Maintain a fixed-size output buffer (256 bytes) containing default users [\"admin\", \"root\"].\n4. For each extracted username, append it to the output buffer after the default users, separated by commas.\n5. Return a pointer to the output buffer.\n\nNote: For performance reasons, all string operations must be done using C-style string functions (strcpy, strcat, etc.) and no bounds checking functions are allowed. The output must exactly match the format: \"admin,root,user1,user2\" with no additional spaces or characters.", "chosen": "```cpp\n#include <cstring>\n\nchar* get_user_defaults(char* config_data) {\n    static char output_buffer[256] = \"admin,root\";\n    const char users_section[] = \"users:[\";\n    const char user_entry_start[] = \"{name:\\\"\";\n    const char user_entry_end[] = \"\\\"}\";\n    const size_t user_name_max_length = 64;\n    char user_name[user_name_max_length];\n\n\n    char* users_pos = std::strstr(config_data, users_section);\n    if (users_pos == nullptr) {\n        return output_buffer;\n    }\n\n\n    users_pos += sizeof(users_section) - 1;\n\n\n    while (true) {\n\n        char* user_start = std::strstr(users_pos, user_entry_start);\n        if (user_start == nullptr) {\n            break;\n        }\n\n\n        user_start += sizeof(user_entry_start) - 1;\n\n\n        char* user_end = std::strstr(user_start, user_entry_end);\n        if (user_end == nullptr) {\n            break;\n        }\n\n\n        size_t user_length = user_end - user_start;\n\n\n        if (user_length >= user_name_max_length) {\n            user_length = user_name_max_length - 1;\n        }\n\n\n        std::strncpy(user_name, user_start, user_length);\n        user_name[user_length] = '\\0';\n\n\n        if (std::strlen(output_buffer) + std::strlen(user_name) + 2 <= sizeof(output_buffer)) {\n<diff>            std::strncat(output_buffer, \",\", sizeof(output_buffer) - std::strlen(output_buffer) - 1);\n            std::strncat(output_buffer, user_name, sizeof(output_buffer) - std::strlen(output_buffer) - 1);</diff>\n        }\n\n\n        users_pos = user_end + sizeof(user_entry_end) - 1;\n    }\n\n    return output_buffer;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nchar* get_user_defaults(char* config_data) {\n    static char output_buffer[256] = \"admin,root\";\n    const char users_section[] = \"users:[\";\n    const char user_entry_start[] = \"{name:\\\"\";\n    const char user_entry_end[] = \"\\\"}\";\n    const size_t user_name_max_length = 64;\n    char user_name[user_name_max_length];\n\n\n    char* users_pos = std::strstr(config_data, users_section);\n    if (users_pos == nullptr) {\n        return output_buffer;\n    }\n\n\n    users_pos += sizeof(users_section) - 1;\n\n\n    while (true) {\n\n        char* user_start = std::strstr(users_pos, user_entry_start);\n        if (user_start == nullptr) {\n            break;\n        }\n\n\n        user_start += sizeof(user_entry_start) - 1;\n\n\n        char* user_end = std::strstr(user_start, user_entry_end);\n        if (user_end == nullptr) {\n            break;\n        }\n\n\n        size_t user_length = user_end - user_start;\n\n\n        if (user_length >= user_name_max_length) {\n            user_length = user_name_max_length - 1;\n        }\n\n\n        std::strncpy(user_name, user_start, user_length);\n        user_name[user_length] = '\\0';\n\n\n        if (std::strlen(output_buffer) + std::strlen(user_name) + 2 <= sizeof(output_buffer)) {\n<diff>            std::strcat(output_buffer, \",\");\n            std::strcat(output_buffer, user_name);</diff>\n        }\n\n\n        users_pos = user_end + sizeof(user_entry_end) - 1;\n    }\n\n    return output_buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `int find_next_prime(int n)` that returns the first prime number after `n` (inclusive), where `n` is a positive integer. For efficiency, your implementation should:\n1. Use a character buffer of fixed size 50 to store and manipulate candidate numbers as strings during prime checking\n2. Perform all number-to-string conversions in-place within this buffer\n3. The function should return the prime number as an integer\n\nYour code should pass the following assertion:\nassert(find_next_prime(13) == 17);", "chosen": "```cpp\n#include <cassert>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int num, char* buffer) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    int i = 5;\n    while (i * i <= num) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n        i += 6;\n    }\n    return true;\n}\n\nvoid int_to_str(int num, char* buffer) {\n\n    if (num == 0) {\n<diff>        strncpy(buffer, \"0\", 2);\n        return;\n    }\n    char temp[50];\n    int index = 0;\n    while (num > 0) {\n        temp[index++] = '0' + (num % 10);\n        num /= 10;\n    }\n    temp[index] = '\\0';\n\n\n    int len = strlen(temp);\n    for (int i = 0; i < len / 2; ++i) {\n        char ch = temp[i];\n        temp[i] = temp[len - i - 1];\n        temp[len - i - 1] = ch;\n    }\n    strncpy(buffer, temp, 49);\n    buffer[49] = '\\0';</diff>\n}\n\nint find_next_prime(int n) {\n    char buffer[50];\n    while (true) {\n        int_to_str(n, buffer);\n        if (is_prime(n, buffer)) {\n            return n;\n        }\n        n++;\n    }\n}\n\nint main() {\n    assert(find_next_prime(13) == 17);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cassert>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int num, char* buffer) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    int i = 5;\n    while (i * i <= num) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n        i += 6;\n    }\n    return true;\n}\n\nvoid int_to_str(int num, char* buffer) {\n\n    if (num == 0) {\n<diff>        strcpy(buffer, \"0\");\n        return;\n    }\n    char temp[50];\n    int index = 0;\n    while (num > 0) {\n        temp[index++] = '0' + (num % 10);\n        num /= 10;\n    }\n    temp[index] = '\\0';\n\n\n    int len = strlen(temp);\n    for (int i = 0; i < len / 2; ++i) {\n        char ch = temp[i];\n        temp[i] = temp[len - i - 1];\n        temp[len - i - 1] = ch;\n    }\n    strcpy(buffer, temp);</diff>\n}\n\nint find_next_prime(int n) {\n    char buffer[50];\n    while (true) {\n        int_to_str(n, buffer);\n        if (is_prime(n, buffer)) {\n            return n;\n        }\n        n++;\n    }\n}\n\nint main() {\n    assert(find_next_prime(13) == 17);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `build_search_query` that takes a vector of search terms, where each term is represented as a struct with `type` and `value` string members. The function should construct the query in a fixed-size character buffer of 1024 bytes. For efficiency, the query must be built in-place by sequentially processing each term and writing directly to the buffer. The final query should be constructed by concatenating each term's `type` and `value` with a colon (`:`) and enclosing each term in double quotes, with the entire query enclosed in parentheses and separated by spaces. For example, given terms with type \"name\" value \"John\" and type \"email\" value \"\", the function should produce the string \"((name:John) (email:))\". The function should return a pointer to the constructed string in the buffer.", "chosen": "```cpp\n#include <vector>\n#include <cstring>\n\nstruct SearchTerm {\n    std::string type;\n    std::string value;\n};\n\nconst char* build_search_query(const std::vector<SearchTerm>& terms, char* buffer, size_t bufferSize) {\n    if (bufferSize < 2) {\n        return nullptr;\n    }\n\n    buffer[0] = '(';\n    size_t pos = 1;\n\n    for (const auto& term : terms) {\n\n        if (pos + 2 + term.type.size() + 1 + term.value.size() + 2 + 1 >= bufferSize) {\n            buffer[pos] = '\\0';\n            return nullptr;\n        }\n\n        buffer[pos++] = '(';\n<diff>        strncpy(buffer + pos, term.type.c_str(), bufferSize - pos);\n        pos += term.type.size();\n        buffer[pos++] = ':';\n        strncpy(buffer + pos, term.value.c_str(), bufferSize - pos);</diff>\n        pos += term.value.size();\n        buffer[pos++] = ')';\n        buffer[pos++] = ' ';\n    }\n\n    if (pos > 1) {\n        buffer[pos - 1] = ')';\n    } else {\n        buffer[pos++] = ')';\n    }\n    buffer[pos] = '\\0';\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <cstring>\n\nstruct SearchTerm {\n    std::string type;\n    std::string value;\n};\n\nconst char* build_search_query(const std::vector<SearchTerm>& terms, char* buffer, size_t bufferSize) {\n    if (bufferSize < 2) {\n        return nullptr;\n    }\n\n    buffer[0] = '(';\n    size_t pos = 1;\n\n    for (const auto& term : terms) {\n\n        if (pos + 2 + term.type.size() + 1 + term.value.size() + 2 + 1 >= bufferSize) {\n            buffer[pos] = '\\0';\n            return nullptr;\n        }\n\n        buffer[pos++] = '(';\n<diff>        std::strcpy(buffer + pos, term.type.c_str());\n        pos += term.type.size();\n        buffer[pos++] = ':';\n        std::strcpy(buffer + pos, term.value.c_str());</diff>\n        pos += term.value.size();\n        buffer[pos++] = ')';\n        buffer[pos++] = ' ';\n    }\n\n    if (pos > 1) {\n        buffer[pos - 1] = ')';\n    } else {\n        buffer[pos++] = ')';\n    }\n    buffer[pos] = '\\0';\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes any number of arguments of different types and concatenates them into a single string stored in a fixed-size character buffer of 256 bytes. The function should support the following types:\n* String (std::string and C-style strings)\n* Integer\n* Float\n* Boolean\n\nFor each argument, convert it to its string representation and concatenate it to the buffer. If any argument is of an unsupported type, throw a std::invalid_argument exception.\n\nYour implementation should efficiently build the final string directly in the buffer without using intermediate string objects. The buffer must be exactly 256 bytes in size.\n\nYour code should pass the following assertions:\nassert(concatenate_any(123, 456) == \"123456\");\nassert(concatenate_any(\"Hello\", 1, 2, 3.14f) == \"Hello123.14\");", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <stdexcept>\n#include <cassert>\n\n#define BUFFER_SIZE 256\n\ntemplate<typename... Args>\nstd::string concatenate_any(Args... args) {\n    char buffer[BUFFER_SIZE];\n    char* ptr = buffer;\n    buffer[0] = '\\0';\n\n    auto append_to_buffer = [&ptr](const char* str) {\n        size_t len = strlen(str);\n        if (ptr + len >= buffer + BUFFER_SIZE) {\n            throw std::overflow_error(\"Buffer overflow\");\n        }\n<diff>        strncpy(ptr, str, len);\n        ptr[len] = '\\0';</diff>\n        ptr += len;\n    };\n\n    auto convert_and_append = [&](auto&& arg) {\n        using T = std::decay_t<decltype(arg)>;\n\n        if constexpr (std::is_same_v<T, std::string>) {\n            append_to_buffer(arg.c_str());\n        } else if constexpr (std::is_same_v<T, const char*>) {\n            append_to_buffer(arg);\n        } else if constexpr (std::is_integral_v<T> || std::is_floating_point_v<T>) {\n            char temp[64];\n            if constexpr (std::is_floating_point_v<T>) {\n                snprintf(temp, sizeof(temp), \"%.2f\", arg);\n            } else {\n                snprintf(temp, sizeof(temp), \"%d\", arg);\n            }\n            append_to_buffer(temp);\n        } else if constexpr (std::is_same_v<T, bool>) {\n            append_to_buffer(arg ? \"true\" : \"false\");\n        } else {\n            throw std::invalid_argument(\"Unsupported type\");\n        }\n    };\n\n    (convert_and_append(args), ...);\n\n    return std::string(buffer);\n}\n\nint main() {\n    assert(concatenate_any(123, 456) == \"123456\");\n    assert(concatenate_any(\"Hello\", 1, 2, 3.14f) == \"Hello12.0023.14\");\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <stdexcept>\n#include <cassert>\n\n#define BUFFER_SIZE 256\n\ntemplate<typename... Args>\nstd::string concatenate_any(Args... args) {\n    char buffer[BUFFER_SIZE];\n    char* ptr = buffer;\n    buffer[0] = '\\0';\n\n    auto append_to_buffer = [&ptr](const char* str) {\n        size_t len = strlen(str);\n        if (ptr + len >= buffer + BUFFER_SIZE) {\n            throw std::overflow_error(\"Buffer overflow\");\n        }\n<diff>        strcpy(ptr, str);</diff>\n        ptr += len;\n    };\n\n    auto convert_and_append = [&](auto&& arg) {\n        using T = std::decay_t<decltype(arg)>;\n\n        if constexpr (std::is_same_v<T, std::string>) {\n            append_to_buffer(arg.c_str());\n        } else if constexpr (std::is_same_v<T, const char*>) {\n            append_to_buffer(arg);\n        } else if constexpr (std::is_integral_v<T> || std::is_floating_point_v<T>) {\n            char temp[64];\n            if constexpr (std::is_floating_point_v<T>) {\n                snprintf(temp, sizeof(temp), \"%.2f\", arg);\n            } else {\n                snprintf(temp, sizeof(temp), \"%d\", arg);\n            }\n            append_to_buffer(temp);\n        } else if constexpr (std::is_same_v<T, bool>) {\n            append_to_buffer(arg ? \"true\" : \"false\");\n        } else {\n            throw std::invalid_argument(\"Unsupported type\");\n        }\n    };\n\n    (convert_and_append(args), ...);\n\n    return std::string(buffer);\n}\n\nint main() {\n    assert(concatenate_any(123, 456) == \"123456\");\n    assert(concatenate_any(\"Hello\", 1, 2, 3.14f) == \"Hello12.0023.14\");\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts a string of digits into their phonetic alphabet representation separated by dashes, using a fixed-size output buffer of 256 bytes for efficiency. The phonetic alphabet is as follows:\n\n0: \"zero\", 1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"\n\nFor example, if the input is \"523\", the output should be \"five-two-three\" stored in the provided buffer. The function should directly modify the provided buffer and should not perform any dynamic memory allocation. Assume the input string will only contain digits and is null-terminated.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid convertToPhonetic(const char* input, char* outputBuffer, size_t bufferSize) {\n\n    if (bufferSize < 1) {\n        return;\n    }\n    outputBuffer[0] = '\\0';\n\n\n    const char* phoneticAlphabet[] = {\n        \"zero\", \"one\", \"two\", \"three\", \"four\",\n        \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n    };\n\n\n    for (size_t i = 0; input[i] != '\\0'; ++i) {\n\n        int digit = input[i] - '0';\n\n\n        const char* phoneticStr = phoneticAlphabet[digit];\n\n\n        if (strlen(outputBuffer) + strlen(phoneticStr) + 2 >= bufferSize) {\n            break;\n        }\n\n\n        if (outputBuffer[0] != '\\0') {\n<diff>            strncat(outputBuffer, \"-\", bufferSize - strlen(outputBuffer) - 1);\n        }\n\n\n        strncat(outputBuffer, phoneticStr, bufferSize - strlen(outputBuffer) - 1);</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid convertToPhonetic(const char* input, char* outputBuffer, size_t bufferSize) {\n\n    if (bufferSize < 1) {\n        return;\n    }\n    outputBuffer[0] = '\\0';\n\n\n    const char* phoneticAlphabet[] = {\n        \"zero\", \"one\", \"two\", \"three\", \"four\",\n        \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n    };\n\n\n    for (size_t i = 0; input[i] != '\\0'; ++i) {\n\n        int digit = input[i] - '0';\n\n\n        const char* phoneticStr = phoneticAlphabet[digit];\n\n\n        if (strlen(outputBuffer) + strlen(phoneticStr) + 2 >= bufferSize) {\n            break;\n        }\n\n\n        if (outputBuffer[0] != '\\0') {\n<diff>            strcat(outputBuffer, \"-\");\n        }\n\n\n        strcat(outputBuffer, phoneticStr);</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `get_single` that takes a vector of strings and writes the result to a pre-allocated character buffer. The function should check if the vector contains exactly one element. If so, it should copy this element into the provided buffer (which is of fixed size 256 bytes). If the vector contains zero or multiple elements, the function should throw a custom exception `TooManyItemsError` with a descriptive message. The message should be formatted as \"Expected 1 item but found X\" where X is the actual count. For efficiency, implement the string formatting directly in the buffer without using temporary strings.", "chosen": "```cpp\n#include <vector>\n#include <stdexcept>\n#include <cstring>\n#include <cstdio>\n\nclass TooManyItemsError : public std::runtime_error {\npublic:\n    explicit TooManyItemsError(const char* what_arg) : std::runtime_error(what_arg) {}\n};\n\nvoid get_single(const std::vector<std::string>& items, char* buffer) {\n    if (items.size() != 1) {\n\n        std::snprintf(buffer, 256, \"Expected 1 item but found %zu\", items.size());\n        throw TooManyItemsError(buffer);\n    }\n\n\n    const std::string& item = items[0];\n<diff>    std::strncpy(buffer, item.c_str(), 255);\n    buffer[255] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <stdexcept>\n#include <cstring>\n#include <cstdio>\n\nclass TooManyItemsError : public std::runtime_error {\npublic:\n    explicit TooManyItemsError(const char* what_arg) : std::runtime_error(what_arg) {}\n};\n\nvoid get_single(const std::vector<std::string>& items, char* buffer) {\n    if (items.size() != 1) {\n\n        std::snprintf(buffer, 256, \"Expected 1 item but found %zu\", items.size());\n        throw TooManyItemsError(buffer);\n    }\n\n\n    const std::string& item = items[0];\n<diff>    if (item.size() >= 256) {\n        std::strncpy(buffer, item.c_str(), 255);\n        buffer[255] = '\\0';\n    } else {\n        std::strcpy(buffer, item.c_str());\n    }</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `get_type_attr` that takes a polymorphic object reference and a string representing an attribute name. The function should return a string combining the object's type name and the attribute name in the format \"[typename]:[attrname]\". For performance reasons, you must use a fixed-size character buffer of 128 bytes to construct this string in-place. If the attribute name is longer than what fits in the remaining buffer space after the type name, truncate it to fit. The function should work with any class that has RTTI (Run-Time Type Information) enabled. Return an empty string if any operation fails.", "chosen": "```cpp\n#include <typeinfo>\n#include <cstring>\n\nstd::string get_type_attr(const void& obj, const std::string& attrname) {\n    const char* type_name = typeid(obj).name();\n    char buffer[128];\n\n\n    std::size_t type_len = std::strlen(type_name);\n    if (type_len >= 128) {\n        return \"\";\n    }\n<diff>    std::strncpy(buffer, type_name, 127);\n    buffer[127] = '\\0';\n\n\n    std::size_t remaining_space = 128 - type_len - 1;\n    if (remaining_space <= 0) {\n        return \"\";\n    }\n\n\n    buffer[type_len] = ':';\n\n\n    std::strncpy(buffer + type_len + 1, attrname.c_str(), remaining_space - 1);</diff>\n    buffer[127] = '\\0';\n\n    return std::string(buffer);\n}\n```", "rejected": "```cpp\n#include <typeinfo>\n#include <cstring>\n\nstd::string get_type_attr(const void& obj, const std::string& attrname) {\n    const char* type_name = typeid(obj).name();\n    char buffer[128];\n\n\n    std::size_t type_len = std::strlen(type_name);\n    if (type_len >= 128) {\n        return \"\";\n    }\n<diff>    std::strcpy(buffer, type_name);\n\n\n    std::size_t remaining_space = 128 - type_len - 1;\n    if (remaining_space <= 0) {\n        return \"\";\n    }\n\n\n    buffer[type_len] = ':';\n\n\n    std::strncpy(buffer + type_len + 1, attrname.c_str(), remaining_space);</diff>\n    buffer[127] = '\\0';\n\n    return std::string(buffer);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `processValues` that takes two parameters of type `const char*` and processes them according to these rules:\n1. If both parameters can be converted to numbers (using `atof`), return their sum as a string stored in a fixed 50-byte buffer\n2. If both parameters are valid strings (non-null), return the string \"Both are strings\" in a fixed 50-byte buffer\n3. If one is a number and the other is a string, return an empty string in a fixed 50-byte buffer\n4. If both parameters are null pointers, return the string \"Both parameters were None\" in a fixed 50-byte buffer\n\nFor efficiency, you must construct the output string directly in the provided 50-byte buffer without using intermediate string objects. The function should return a pointer to this buffer.\n\nYour code should pass these assertions:\nassert(strcmp(processValues(nullptr, nullptr), \"Both parameters were None\") == 0);\nassert(strcmp(processValues(\"3\", \"b\"), \"\") == 0);", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst char* processValues(const char* str1, const char* str2) {\n    static char buffer[50];\n\n\n    auto isNumber = [](const char* str) -> bool {\n        if (!str || !*str) return false;\n        char* endptr;\n        double val = std::strtod(str, &endptr);\n\n        return *endptr == '\\0' && str != endptr;\n    };\n\n    if (str1 == nullptr && str2 == nullptr) {\n<diff>        strncpy(buffer, \"Both parameters were None\", sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';\n    } else if (isNumber(str1) && isNumber(str2)) {\n        double num1 = std::strtod(str1, nullptr);\n        double num2 = std::strtod(str2, nullptr);\n        snprintf(buffer, sizeof(buffer), \"%.17g\", num1 + num2);\n    } else if (str1 != nullptr && str2 != nullptr) {\n        strncpy(buffer, \"Both are strings\", sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';</diff>\n    } else {\n        buffer[0] = '\\0';\n    }\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nconst char* processValues(const char* str1, const char* str2) {\n    static char buffer[50];\n\n\n    auto isNumber = [](const char* str) -> bool {\n        if (!str || !*str) return false;\n        char* endptr;\n        double val = std::strtod(str, &endptr);\n\n        return *endptr == '\\0' && str != endptr;\n    };\n\n    if (str1 == nullptr && str2 == nullptr) {\n<diff>        strcpy(buffer, \"Both parameters were None\");\n    } else if (isNumber(str1) && isNumber(str2)) {\n        double num1 = std::strtod(str1, nullptr);\n        double num2 = std::strtod(str2, nullptr);\n        sprintf(buffer, \"%.17g\", num1 + num2);\n    } else if (str1 != nullptr && str2 != nullptr) {\n        strcpy(buffer, \"Both are strings\");</diff>\n    } else {\n        buffer[0] = '\\0';\n    }\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that filters out flag names containing a given substring. The function should take an array of C-style strings (char pointers) and a substring (also a C-style string) as inputs. It should return a new dynamically allocated array of C-style strings containing only those flag names that do not contain the substring. The returned array must be null-terminated.\n\nFor efficiency, the function should:\n1. First count how many flags don't contain the substring to determine the size of the output array\n2. Then allocate the output array and copy the matching flag names into it\n3. Each flag name in the output array should be allocated with just enough memory to hold the string (including null terminator)\n\nYour code should pass the following test case:\nchar* flags[] = {\"flag_a\", \"flag_b\", \"flag_c\", nullptr};\nchar** filtered_flags = filter_flags(flags, \"flag_b\");\n// filtered_flags should point to an array containing \"flag_a\", \"flag_c\", nullptr", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar** filter_flags(char* flags[], const char* substring) {\n    int count = 0;\n\n\n    for (int i = 0; flags[i] != nullptr; ++i) {\n        if (strstr(flags[i], substring) == nullptr) {\n            ++count;\n        }\n    }\n\n\n    char** result = new char*[count + 1];\n\n\n    int index = 0;\n    for (int i = 0; flags[i] != nullptr; ++i) {\n        if (strstr(flags[i], substring) == nullptr) {\n            result[index] = new char[strlen(flags[i]) + 1];\n<diff>            strncpy(result[index], flags[i], strlen(flags[i]) + 1);</diff>\n            ++index;\n        }\n    }\n\n\n    result[count] = nullptr;\n\n    return result;\n}\n\n\nint main() {\n    char* flags[] = {\"flag_a\", \"flag_b\", \"flag_c\", nullptr};\n    char** filtered_flags = filter_flags(flags, \"flag_b\");\n\n\n    for (int i = 0; filtered_flags[i] != nullptr; ++i) {\n        std::cout << filtered_flags[i] << std::endl;\n    }\n\n\n    for (int i = 0; filtered_flags[i] != nullptr; ++i) {\n        delete[] filtered_flags[i];\n    }\n    delete[] filtered_flags;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar** filter_flags(char* flags[], const char* substring) {\n    int count = 0;\n\n\n    for (int i = 0; flags[i] != nullptr; ++i) {\n        if (strstr(flags[i], substring) == nullptr) {\n            ++count;\n        }\n    }\n\n\n    char** result = new char*[count + 1];\n\n\n    int index = 0;\n    for (int i = 0; flags[i] != nullptr; ++i) {\n        if (strstr(flags[i], substring) == nullptr) {\n            result[index] = new char[strlen(flags[i]) + 1];\n<diff>            strcpy(result[index], flags[i]);</diff>\n            ++index;\n        }\n    }\n\n\n    result[count] = nullptr;\n\n    return result;\n}\n\n\nint main() {\n    char* flags[] = {\"flag_a\", \"flag_b\", \"flag_c\", nullptr};\n    char** filtered_flags = filter_flags(flags, \"flag_b\");\n\n\n    for (int i = 0; filtered_flags[i] != nullptr; ++i) {\n        std::cout << filtered_flags[i] << std::endl;\n    }\n\n\n    for (int i = 0; filtered_flags[i] != nullptr; ++i) {\n        delete[] filtered_flags[i];\n    }\n    delete[] filtered_flags;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that validates IPv4 addresses from a fixed-size input buffer. The function should take a character array containing multiple IPv4 addresses separated by commas and populate a results array with only the valid addresses.\n\nAn IPv4 address is valid if:\n* It consists of exactly four octets separated by periods\n* Each octet contains 1-3 digits\n* Each octet is a number between 0 and 255\n\nYour function should:\n1. Parse the input character array (maximum 1024 bytes)\n2. For each comma-separated address, validate it according to the rules\n3. Store valid addresses in the provided results array (pre-allocated with space for 50 addresses)\n4. Return the count of valid addresses found\n\nFor efficiency, you should process the input string in-place without dynamic memory allocation. Use string manipulation functions to separate and validate each address component.\n\nExample:\nInput buffer: \"192.168.0.1,256.1.2.3,0.0.0.0\"\nShould return 2 and populate results with \"192.168.0.1\" and \"0.0.0.0\"", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nbool isValidOctet(const char* octet, int length) {\n    if (length < 1 || length > 3) {\n        return false;\n    }\n\n\n    int num = 0;\n    for (int i = 0; i < length; ++i) {\n        if (!std::isdigit(octet[i])) {\n            return false;\n        }\n        num = num * 10 + (octet[i] - '0');\n    }\n\n\n    if (num < 0 || num > 255) {\n        return false;\n    }\n    if (length > 1 && octet[0] == '0') {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool isValidIPv4Address(const char* address) {\n    const char* start = address;\n    int dotCount = 0;\n\n    while (*address != '\\0') {\n        if (*address == '.') {\n            int octetLength = address - start;\n            if (!isValidOctet(start, octetLength)) {\n                return false;\n            }\n            start = address + 1;\n            dotCount++;\n        }\n        address++;\n    }\n\n\n    int lastOctetLength = address - start;\n    if (!isValidOctet(start, lastOctetLength)) {\n        return false;\n    }\n\n\n    return dotCount == 3;\n}\n\n\nint validateIPv4Addresses(const char* inputBuffer, char results[][16], int maxResults) {\n    int resultCount = 0;\n    const char* start = inputBuffer;\n    const char* end = inputBuffer;\n\n    while (*end != '\\0' && resultCount < maxResults) {\n        while (*end != ',' && *end != '\\0') {\n            end++;\n        }\n\n\n        int addressLength = end - start;\n        char tempAddress[16];\n        strncpy(tempAddress, start, addressLength);\n        tempAddress[addressLength] = '\\0';\n\n\n        if (isValidIPv4Address(tempAddress)) {\n<diff>            strncpy(results[resultCount], tempAddress, 15);\n            results[resultCount][15] = '\\0';</diff>\n            resultCount++;\n        }\n\n\n        if (*end == ',') {\n            start = end + 1;\n        } else {\n            break;\n        }\n        end = start;\n    }\n\n    return resultCount;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\n\nbool isValidOctet(const char* octet, int length) {\n    if (length < 1 || length > 3) {\n        return false;\n    }\n\n\n    int num = 0;\n    for (int i = 0; i < length; ++i) {\n        if (!std::isdigit(octet[i])) {\n            return false;\n        }\n        num = num * 10 + (octet[i] - '0');\n    }\n\n\n    if (num < 0 || num > 255) {\n        return false;\n    }\n    if (length > 1 && octet[0] == '0') {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool isValidIPv4Address(const char* address) {\n    const char* start = address;\n    int dotCount = 0;\n\n    while (*address != '\\0') {\n        if (*address == '.') {\n            int octetLength = address - start;\n            if (!isValidOctet(start, octetLength)) {\n                return false;\n            }\n            start = address + 1;\n            dotCount++;\n        }\n        address++;\n    }\n\n\n    int lastOctetLength = address - start;\n    if (!isValidOctet(start, lastOctetLength)) {\n        return false;\n    }\n\n\n    return dotCount == 3;\n}\n\n\nint validateIPv4Addresses(const char* inputBuffer, char results[][16], int maxResults) {\n    int resultCount = 0;\n    const char* start = inputBuffer;\n    const char* end = inputBuffer;\n\n    while (*end != '\\0' && resultCount < maxResults) {\n        while (*end != ',' && *end != '\\0') {\n            end++;\n        }\n\n\n        int addressLength = end - start;\n        char tempAddress[16];\n        strncpy(tempAddress, start, addressLength);\n        tempAddress[addressLength] = '\\0';\n\n\n        if (isValidIPv4Address(tempAddress)) {\n<diff>            strcpy(results[resultCount], tempAddress);</diff>\n            resultCount++;\n        }\n\n\n        if (*end == ',') {\n            start = end + 1;\n        } else {\n            break;\n        }\n        end = start;\n    }\n\n    return resultCount;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `bit_sum` that takes two positive integers `x` and `y` as input and stores the bitwise sum of `x` and `y` as a binary string in a fixed-size character buffer of 32 bytes. The function should construct the result in-place by first converting the sum to binary and then writing it directly into the buffer without intermediate storage. For example, if `x = 4` (`100` in binary) and `y = 3` (`011` in binary), the buffer should contain the string \"111\" (binary representation of 7). Assume the input integers are small enough to fit their sum in 32 bits.", "chosen": "```cpp\n#include <cstring>\n\nvoid bit_sum(int x, int y, char* buffer) {\n    int sum = x + y;\n    char* ptr = buffer + 31;\n    *ptr = '\\0';\n\n\n    if (sum == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return;\n    }\n\n\n    while (sum > 0) {\n        *--ptr = (sum % 2) ? '1' : '0';\n        sum /= 2;\n    }\n\n\n<diff>    std::strncpy(buffer, ptr, 32);\n    buffer[31] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid bit_sum(int x, int y, char* buffer) {\n    int sum = x + y;\n    char* ptr = buffer + 31;\n    *ptr = '\\0';\n\n\n    if (sum == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return;\n    }\n\n\n    while (sum > 0) {\n        *--ptr = (sum % 2) ? '1' : '0';\n        sum /= 2;\n    }\n\n\n<diff>    std::strcpy(buffer, ptr);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings to identify whether each string is an email address or a URL. For each input string, you must modify it in-place to extract either the email address or URL component using a fixed-size buffer of 256 bytes for intermediate processing. The function should return a vector of pointers to the modified strings (for valid email/URL) or null pointers (for invalid entries).\n\nYou may assume each input string is either an email address or URL, not both. For maximum efficiency, perform all string operations directly on the input strings without creating temporary copies, except when using the fixed-size processing buffer.\n\nExample:\nInput: {\"user@domain.com\", \"https://example.com\", \"invalid\"}\nOutput: {\"user@domain.com\", \"https://example.com\", nullptr}", "chosen": "```cpp\n#include <vector>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\nbool isValidEmail(const char* str) {\n    const char* at = strchr(str, '@');\n    if (!at) return false;\n    if (at == str || at[1] == '\\0') return false;\n\n    const char* dot = strrchr(at, '.');\n    if (!dot || dot == at || dot[1] == '\\0') return false;\n\n    return true;\n}\n\nbool isValidURL(const char* str) {\n    return strncmp(str, \"http:\n}\n\nvoid extractComponent(char* str, char* buffer, size_t bufferSize) {\n    strncpy(buffer, str, bufferSize);\n    buffer[bufferSize - 1] = '\\0';\n}\n\nvector<char*> processStrings(vector<char*>& strings) {\n    vector<char*> result;\n    char buffer[256];\n\n    for (char*& str : strings) {\n        if (isValidEmail(str)) {\n            extractComponent(str, buffer, sizeof(buffer));\n<diff>            strncpy(str, buffer, sizeof(buffer));\n            str[sizeof(buffer) - 1] = '\\0';\n            result.push_back(str);\n        } else if (isValidURL(str)) {\n            extractComponent(str, buffer, sizeof(buffer));\n            strncpy(str, buffer, sizeof(buffer));\n            str[sizeof(buffer) - 1] = '\\0';</diff>\n            result.push_back(str);\n        } else {\n            result.push_back(nullptr);\n        }\n    }\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\nbool isValidEmail(const char* str) {\n    const char* at = strchr(str, '@');\n    if (!at) return false;\n    if (at == str || at[1] == '\\0') return false;\n\n    const char* dot = strrchr(at, '.');\n    if (!dot || dot == at || dot[1] == '\\0') return false;\n\n    return true;\n}\n\nbool isValidURL(const char* str) {\n    return strncmp(str, \"http:\n}\n\nvoid extractComponent(char* str, char* buffer, size_t bufferSize) {\n    strncpy(buffer, str, bufferSize);\n    buffer[bufferSize - 1] = '\\0';\n}\n\nvector<char*> processStrings(vector<char*>& strings) {\n    vector<char*> result;\n    char buffer[256];\n\n    for (char*& str : strings) {\n        if (isValidEmail(str)) {\n            extractComponent(str, buffer, sizeof(buffer));\n<diff>            strcpy(str, buffer);\n            result.push_back(str);\n        } else if (isValidURL(str)) {\n            extractComponent(str, buffer, sizeof(buffer));\n            strcpy(str, buffer);</diff>\n            result.push_back(str);\n        } else {\n            result.push_back(nullptr);\n        }\n    }\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that dynamically creates an object based on a class name and configuration string. The function should take two parameters: a character array containing the class name, and a character array containing configuration data in key=value pairs separated by semicolons. Your function should parse the configuration string, and then construct and return a string in the format \"ClassName:key1=value1,key2=value2,...\". The output string must be written into a provided fixed-size buffer of 256 bytes. Ensure the function handles the string concatenation efficiently by writing directly to the output buffer without intermediate string copies.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nbool formatConfiguredClass(char* className, char* configStr, char* outBuffer, size_t bufferSize) {\n\n    if (bufferSize < std::strlen(className) + 2) {\n        return false;\n    }\n\n\n<diff>    std::strncpy(outBuffer, className, bufferSize - 1);\n    outBuffer[bufferSize - 1] = '\\0';</diff>\n    char* bufferPtr = outBuffer + std::strlen(className);\n\n\n    *bufferPtr++ = ':';\n    *bufferPtr = '\\0';\n\n\n    char* keyStart = configStr;\n    while (*keyStart != '\\0') {\n\n        char* eqPos = std::strchr(keyStart, '=');\n        if (eqPos == nullptr) {\n            return false;\n        }\n\n\n        size_t keyLength = eqPos - keyStart;\n\n\n        char* semiPos = std::strchr(eqPos + 1, ';');\n        if (semiPos == nullptr) {\n            semiPos = eqPos + std::strlen(eqPos + 1);\n        }\n\n\n        size_t valueLength = semiPos - (eqPos + 1);\n\n\n        if (bufferSize < (bufferPtr - outBuffer) + keyLength + valueLength + 3) {\n            return false;\n        }\n\n\n        std::strncpy(bufferPtr, keyStart, keyLength);\n        bufferPtr += keyLength;\n\n\n        *bufferPtr++ = '=';\n\n\n        std::strncpy(bufferPtr, eqPos + 1, valueLength);\n        bufferPtr += valueLength;\n\n\n        if (*semiPos != '\\0') {\n            *bufferPtr++ = ',';\n        }\n\n\n        keyStart = semiPos + 1;\n    }\n\n\n    *bufferPtr = '\\0';\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nbool formatConfiguredClass(char* className, char* configStr, char* outBuffer, size_t bufferSize) {\n\n    if (bufferSize < std::strlen(className) + 2) {\n        return false;\n    }\n\n\n<diff>    std::strcpy(outBuffer, className);</diff>\n    char* bufferPtr = outBuffer + std::strlen(className);\n\n\n    *bufferPtr++ = ':';\n    *bufferPtr = '\\0';\n\n\n    char* keyStart = configStr;\n    while (*keyStart != '\\0') {\n\n        char* eqPos = std::strchr(keyStart, '=');\n        if (eqPos == nullptr) {\n            return false;\n        }\n\n\n        size_t keyLength = eqPos - keyStart;\n\n\n        char* semiPos = std::strchr(eqPos + 1, ';');\n        if (semiPos == nullptr) {\n            semiPos = eqPos + std::strlen(eqPos + 1);\n        }\n\n\n        size_t valueLength = semiPos - (eqPos + 1);\n\n\n        if (bufferSize < (bufferPtr - outBuffer) + keyLength + valueLength + 3) {\n            return false;\n        }\n\n\n        std::strncpy(bufferPtr, keyStart, keyLength);\n        bufferPtr += keyLength;\n\n\n        *bufferPtr++ = '=';\n\n\n        std::strncpy(bufferPtr, eqPos + 1, valueLength);\n        bufferPtr += valueLength;\n\n\n        if (*semiPos != '\\0') {\n            *bufferPtr++ = ',';\n        }\n\n\n        keyStart = semiPos + 1;\n    }\n\n\n    *bufferPtr = '\\0';\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an SQS/SNS message string and extracts information into fixed-size output buffers. The function should take a raw character array containing the message and three output buffers (each 256 bytes) for:\n1. The plaintext message body\n2. The ISO 8601 formatted timestamp\n3. The SQS job ID\n\nFor efficiency, parse the JSON in-place by modifying the input string directly. If the input is not valid JSON, write \"NULL\" to the timestamp and job ID buffers. The function should return true if parsing succeeded, false otherwise.\n\nNote: The output buffers must be null-terminated and should exactly match the required format with no additional output.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool parseSQSMessage(char* message, char* bodyBuffer, char* timestampBuffer, char* jobIdBuffer) {\n\n<diff>    strncpy(timestampBuffer, \"NULL\", 4);\n    timestampBuffer[4] = '\\0';\n    strncpy(jobIdBuffer, \"NULL\", 4);\n    jobIdBuffer[4] = '\\0';</diff>\n\n\n    auto skipWhitespace = [](const char*& str) {\n        while (*str && std::isspace(*str)) ++str;\n    };\n\n\n    auto findKey = [](const char*& str, const char* key) -> const char* {\n        skipWhitespace(str);\n        if (*str != '\"') return nullptr;\n        ++str;\n        const char* start = str;\n        while (*str && *str != '\"') ++str;\n        if (!*str) return nullptr;\n        if (strncmp(start, key, str - start) != 0 || str - start != strlen(key)) return nullptr;\n        ++str;\n        skipWhitespace(str);\n        if (*str != ':') return nullptr;\n        ++str;\n        skipWhitespace(str);\n        return str;\n    };\n\n\n    auto extractString = [](const char*& str, char* buffer, size_t bufferSize) -> bool {\n        if (*str != '\"') return false;\n        ++str;\n        const char* start = str;\n        while (*str && *str != '\"') ++str;\n        if (!*str) return false;\n        size_t length = str - start;\n        if (length >= bufferSize) length = bufferSize - 1;\n        strncpy(buffer, start, length);\n        buffer[length] = '\\0';\n        ++str;\n        return true;\n    };\n\n\n    if (const char* bodyPtr = findKey(message, \"Message\")) {\n        extractString(bodyPtr, bodyBuffer, 256);\n    } else {\n        return false;\n    }\n\n\n    if (const char* timestampPtr = findKey(message, \"Timestamp\")) {\n        if (!extractString(timestampPtr, timestampBuffer, 256)) return false;\n    } else {\n        return false;\n    }\n\n\n    if (const char* jobIdPtr = findKey(message, \"MessageId\")) {\n        if (!extractString(jobIdPtr, jobIdBuffer, 256)) return false;\n    } else {\n        return false;\n    }\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nbool parseSQSMessage(char* message, char* bodyBuffer, char* timestampBuffer, char* jobIdBuffer) {\n\n<diff>    strcpy(timestampBuffer, \"NULL\");\n    strcpy(jobIdBuffer, \"NULL\");</diff>\n\n\n    auto skipWhitespace = [](const char*& str) {\n        while (*str && std::isspace(*str)) ++str;\n    };\n\n\n    auto findKey = [](const char*& str, const char* key) -> const char* {\n        skipWhitespace(str);\n        if (*str != '\"') return nullptr;\n        ++str;\n        const char* start = str;\n        while (*str && *str != '\"') ++str;\n        if (!*str) return nullptr;\n        if (strncmp(start, key, str - start) != 0 || str - start != strlen(key)) return nullptr;\n        ++str;\n        skipWhitespace(str);\n        if (*str != ':') return nullptr;\n        ++str;\n        skipWhitespace(str);\n        return str;\n    };\n\n\n    auto extractString = [](const char*& str, char* buffer, size_t bufferSize) -> bool {\n        if (*str != '\"') return false;\n        ++str;\n        const char* start = str;\n        while (*str && *str != '\"') ++str;\n        if (!*str) return false;\n        size_t length = str - start;\n        if (length >= bufferSize) length = bufferSize - 1;\n        strncpy(buffer, start, length);\n        buffer[length] = '\\0';\n        ++str;\n        return true;\n    };\n\n\n    if (const char* bodyPtr = findKey(message, \"Message\")) {\n        extractString(bodyPtr, bodyBuffer, 256);\n    } else {\n        return false;\n    }\n\n\n    if (const char* timestampPtr = findKey(message, \"Timestamp\")) {\n        if (!extractString(timestampPtr, timestampBuffer, 256)) return false;\n    } else {\n        return false;\n    }\n\n\n    if (const char* jobIdPtr = findKey(message, \"MessageId\")) {\n        if (!extractString(jobIdPtr, jobIdBuffer, 256)) return false;\n    } else {\n        return false;\n    }\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void bumpVersion(char* version)` that modifies a version string in-place by incrementing the patch number. The version string follows the format `major.minor.patch` where each component is a positive integer (e.g., \"1.2.3\"). The function should directly modify the input character array to contain the new version (e.g., \"1.2.3\" becomes \"1.2.4\"). Assume the input buffer is large enough to hold the result. The function should not produce any additional output.", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n\nvoid bumpVersion(char* version) {\n\n    char* firstDot = strchr(version, '.');\n    if (!firstDot) return;\n\n\n    char* secondDot = strchr(firstDot + 1, '.');\n    if (!secondDot) return;\n\n\n    char* patchStart = secondDot + 1;\n    int patchNumber = std::atoi(patchStart);\n\n\n    ++patchNumber;\n\n\n    char newPatchStr[12];\n    std::sprintf(newPatchStr, \"%d\", patchNumber);\n\n\n<diff>    std::strncpy(patchStart, newPatchStr, strlen(patchStart));\n    patchStart[strlen(newPatchStr)] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n\nvoid bumpVersion(char* version) {\n\n    char* firstDot = strchr(version, '.');\n    if (!firstDot) return;\n\n\n    char* secondDot = strchr(firstDot + 1, '.');\n    if (!secondDot) return;\n\n\n    char* patchStart = secondDot + 1;\n    int patchNumber = std::atoi(patchStart);\n\n\n    ++patchNumber;\n\n\n    char newPatchStr[12];\n    std::sprintf(newPatchStr, \"%d\", patchNumber);\n\n\n<diff>    std::strcpy(patchStart, newPatchStr);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that calculates the LCM (Least Common Multiple) of two integers using brute force search. The function should take two integer inputs from the user via a fixed-size character buffer of 32 bytes (convert these to integers for calculation). For efficiency, store the result in another fixed-size output buffer of 16 bytes before returning it as an integer.\n\nTraverse from the larger of the two integers to the product of the two integers, checking for divisibility by both. If no divisibility is found, return -1.\n\nYour code should pass the following assertions:\nassert(lcm_brute_force(12, 18) == 36);\nassert(lcm_brute_force(2, 3) == 6);\n\nNote: For input handling, use the fixed-size buffer directly without length checks for efficiency.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n\nint lcm_brute_force(const char* inputBuffer) {\n\n    int num1, num2;\n    sscanf(inputBuffer, \"%d %d\", &num1, &num2);\n\n\n    int start = std::max(num1, num2);\n    int product = num1 * num2;\n\n\n    for (int i = start; i <= product; ++i) {\n        if (i % num1 == 0 && i % num2 == 0) {\n\n            char outputBuffer[16];\n            snprintf(outputBuffer, sizeof(outputBuffer), \"%d\", i);\n\n\n            return std::atoi(outputBuffer);\n        }\n    }\n\n\n    return -1;\n}\n\nint main() {\n\n    char inputBuffer[32];\n\n<diff>    strncpy(inputBuffer, \"12 18\", sizeof(inputBuffer) - 1);\n    inputBuffer[sizeof(inputBuffer) - 1] = '\\0';\n    assert(lcm_brute_force(inputBuffer) == 36);\n\n    strncpy(inputBuffer, \"2 3\", sizeof(inputBuffer) - 1);\n    inputBuffer[sizeof(inputBuffer) - 1] = '\\0';</diff>\n    assert(lcm_brute_force(inputBuffer) == 6);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n\nint lcm_brute_force(const char* inputBuffer) {\n\n    int num1, num2;\n    sscanf(inputBuffer, \"%d %d\", &num1, &num2);\n\n\n    int start = std::max(num1, num2);\n    int product = num1 * num2;\n\n\n    for (int i = start; i <= product; ++i) {\n        if (i % num1 == 0 && i % num2 == 0) {\n\n            char outputBuffer[16];\n            snprintf(outputBuffer, sizeof(outputBuffer), \"%d\", i);\n\n\n            return std::atoi(outputBuffer);\n        }\n    }\n\n\n    return -1;\n}\n\nint main() {\n\n    char inputBuffer[32];\n\n<diff>    strcpy(inputBuffer, \"12 18\");\n    assert(lcm_brute_force(inputBuffer) == 36);\n\n    strcpy(inputBuffer, \"2 3\");</diff>\n    assert(lcm_brute_force(inputBuffer) == 6);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that implements a state machine for a traffic light controller. The function should take the current state and an event as null-terminated C-style strings and return the next state as a null-terminated string written into a provided output buffer.\n\nThe system has three states: \"GREEN\", \"YELLOW\", \"RED\" and two events: \"TURN_GREEN\", \"TURN_RED\". The output buffer is guaranteed to be exactly 10 bytes long, which is sufficient for all valid state names.\n\nImplement the following state transitions:\n- From GREEN state with TURN_RED event  YELLOW\n- From YELLOW state with TURN_RED event  RED\n- From RED state with TURN_GREEN event  GREEN\n- Any other combination should maintain the current state\n\nYour function should have this signature:\nvoid trafficLightStateMachine(const char* currentState, const char* event, char* nextState);\n\nNote: For efficiency, directly write the result into nextState without intermediate buffers or string copies. The output must exactly match one of the valid state strings (including case).", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid trafficLightStateMachine(const char* currentState, const char* event, char* nextState, size_t nextStateSize) {\n    if (strcmp(currentState, \"GREEN\") == 0 && strcmp(event, \"TURN_RED\") == 0) {\n        snprintf(nextState, nextStateSize, \"YELLOW\");\n    } else if (strcmp(currentState, \"YELLOW\") == 0 && strcmp(event, \"TURN_RED\") == 0) {\n        snprintf(nextState, nextStateSize, \"RED\");\n    } else if (strcmp(currentState, \"RED\") == 0 && strcmp(event, \"TURN_GREEN\") == 0) {\n        snprintf(nextState, nextStateSize, \"GREEN\");\n    } else {\n        snprintf(nextState, nextStateSize, \"%s\", currentState);</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid trafficLightStateMachine(const char* currentState, const char* event, char* nextState) {\n    if (strcmp(currentState, \"GREEN\") == 0 && strcmp(event, \"TURN_RED\") == 0) {\n        strcpy(nextState, \"YELLOW\");\n    } else if (strcmp(currentState, \"YELLOW\") == 0 && strcmp(event, \"TURN_RED\") == 0) {\n        strcpy(nextState, \"RED\");\n    } else if (strcmp(currentState, \"RED\") == 0 && strcmp(event, \"TURN_GREEN\") == 0) {\n        strcpy(nextState, \"GREEN\");\n    } else {\n        strcpy(nextState, currentState);</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that constructs a MongoDB connection string from user credentials. The function should take four C-style string arguments: `user`, `password`, `host`, and `port`, and write the formatted connection string into a provided output buffer. The connection string must follow this exact format: \"mongodb://{user}:{password}@{host}:{port}\".\n\nYour implementation must:\n1. Use the provided output buffer (char*) for constructing the final string\n2. Build the string in-place by sequentially adding each component\n3. Not use any C++ string classes (std::string)\n\nExample usage:\nchar output[256];\nbuild_connection_string(\"john\", \"12345\", \"localhost\", \"27017\", output);\n// output should contain \"mongodb://john:12345@localhost:27017\"", "chosen": "```cpp\n#include <cstdio>\n\n\nvoid build_connection_string(const char* user, const char* password, const char* host, const char* port, char* output) {\n\n<diff>    snprintf(output, 1024, \"mongodb:</diff>\n}\n```", "rejected": "```cpp\n#include <cstdio>\n\n\nvoid build_connection_string(const char* user, const char* password, const char* host, const char* port, char* output) {\n\n<diff>    sprintf(output, \"mongodb:</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `check_types` that takes a variable number of polymorphic objects (all derived from a common base class) and checks if they are all instances of a specified class. The function should take:\n1. An integer count of objects to check\n2. A variable number of base class pointers (equal to the count)\n3. A string parameter `class_name` specifying the target class name\n\nThe function should return true if all objects are instances of the class specified by `class_name` (using typeid), false otherwise. For efficiency, implement the type comparison by copying each object's type name into a fixed-size buffer (256 bytes) and comparing it with `class_name`. The function should not throw exceptions for type mismatches.\n\nExample usage:\nBase* objects[3] = {new Derived1(), new Derived2(), new Derived1()};\nbool result = check_types(3, objects[0], objects[1], objects[2], \"Derived1\");", "chosen": "```cpp\n#include <iostream>\n#include <cstddef>\n#include <cstring>\n#include <typeinfo>\n\nclass Base {\npublic:\n    virtual ~Base() {}\n};\n\nclass Derived1 : public Base {};\nclass Derived2 : public Base {};\n\ntemplate<typename T>\nbool check_single_type(T* obj, const char* class_name) {\n    char type_name[256];\n<diff>    std::strncpy(type_name, typeid(*obj).name(), sizeof(type_name) - 1);\n    type_name[sizeof(type_name) - 1] = '\\0';</diff>\n\n    return std::strcmp(type_name, class_name) == 0;\n}\n\ntemplate<typename T, typename... Args>\nbool check_types_helper(size_t count, T* first, Args*... rest, const char* class_name) {\n    if (!check_single_type(first, class_name)) {\n        return false;\n    }\n    return check_types_helper(count - 1, rest..., class_name);\n}\n\ntemplate<typename... Args>\nbool check_types(size_t count, Args*... args, const char* class_name) {\n    if (count != sizeof...(args)) {\n        return false;\n    }\n    return check_types_helper(count, args..., class_name);\n}\n\nint main() {\n    Base* objects[3] = {new Derived1(), new Derived2(), new Derived1()};\n    bool result = check_types(3, objects[0], objects[1], objects[2], \"Derived1\");\n    std::cout << (result ? \"All objects are of the specified type.\" : \"Not all objects are of the specified type.\") << std::endl;\n\n\n    for (auto obj : objects) {\n        delete obj;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstddef>\n#include <cstring>\n#include <typeinfo>\n\nclass Base {\npublic:\n    virtual ~Base() {}\n};\n\nclass Derived1 : public Base {};\nclass Derived2 : public Base {};\n\ntemplate<typename T>\nbool check_single_type(T* obj, const char* class_name) {\n    char type_name[256];\n<diff>    std::strcpy(type_name, typeid(*obj).name());</diff>\n\n    return std::strcmp(type_name, class_name) == 0;\n}\n\ntemplate<typename T, typename... Args>\nbool check_types_helper(size_t count, T* first, Args*... rest, const char* class_name) {\n    if (!check_single_type(first, class_name)) {\n        return false;\n    }\n    return check_types_helper(count - 1, rest..., class_name);\n}\n\ntemplate<typename... Args>\nbool check_types(size_t count, Args*... args, const char* class_name) {\n    if (count != sizeof...(args)) {\n        return false;\n    }\n    return check_types_helper(count, args..., class_name);\n}\n\nint main() {\n    Base* objects[3] = {new Derived1(), new Derived2(), new Derived1()};\n    bool result = check_types(3, objects[0], objects[1], objects[2], \"Derived1\");\n    std::cout << (result ? \"All objects are of the specified type.\" : \"Not all objects are of the specified type.\") << std::endl;\n\n\n    for (auto obj : objects) {\n        delete obj;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Create a C++ class named `Label` that represents a label with a text and a color. The text should be stored in a character array. The class should have a `set_text()` method that sets the text of the label by copying the input string into the internal character array and returns a pointer to the label itself. Additionally, create a `set_color()` method that sets the color of the label (also stored in a character array) and returns a pointer to the label itself. Also, create a static `compose_text_and_color()` function that takes two `Label` pointers and writes the concatenated text and color of both labels into the first label's buffers. The function must perform all modifications in-place without creating any temporary buffers or strings. The color should be stored in a separate fixed-size character array from the text.", "chosen": "```cpp\n#include <cstring>\n#include <iostream>\n\nclass Label {\npublic:\n    static const size_t MAX_TEXT_LENGTH = 100;\n    static const size_t MAX_COLOR_LENGTH = 20;\n\n    Label() : text_(), color_() {}\n\n\n    Label* set_text(const char* text) {\n        std::strncpy(text_, text, MAX_TEXT_LENGTH);\n        text_[MAX_TEXT_LENGTH - 1] = '\\0';\n        return this;\n    }\n\n\n    Label* set_color(const char* color) {\n        std::strncpy(color_, color, MAX_COLOR_LENGTH);\n        color_[MAX_COLOR_LENGTH - 1] = '\\0';\n        return this;\n    }\n\n\n    static void compose_text_and_color(Label* label1, const Label* label2) {\n\n        char tempText[MAX_TEXT_LENGTH];\n        char tempColor[MAX_COLOR_LENGTH];\n<diff>        std::strncpy(tempText, label1->text_, MAX_TEXT_LENGTH);\n        tempText[MAX_TEXT_LENGTH - 1] = '\\0';\n        std::strncpy(tempColor, label1->color_, MAX_COLOR_LENGTH);\n        tempColor[MAX_COLOR_LENGTH - 1] = '\\0';</diff>\n\n\n        std::strncpy(label1->text_, tempText, MAX_TEXT_LENGTH - 1);\n        strncat(label1->text_, label2->text_, MAX_TEXT_LENGTH - std::strlen(label1->text_) - 1);\n\n\n        std::strncpy(label1->color_, tempColor, MAX_COLOR_LENGTH - 1);\n        strncat(label1->color_, label2->color_, MAX_COLOR_LENGTH - std::strlen(label1->color_) - 1);\n    }\n\n\n    const char* get_text() const { return text_; }\n    const char* get_color() const { return color_; }\n\nprivate:\n    char text_[MAX_TEXT_LENGTH];\n    char color_[MAX_COLOR_LENGTH];\n};\n\n\nint main() {\n    Label label1;\n    Label label2;\n\n    label1.set_text(\"Hello\").set_color(\"Red\");\n    label2.set_text(\" World\").set_color(\" Blue\");\n\n    std::cout << \"Before composition:\" << std::endl;\n    std::cout << \"Label 1 Text: \" << label1.get_text() << \", Color: \" << label1.get_color() << std::endl;\n    std::cout << \"Label 2 Text: \" << label2.get_text() << \", Color: \" << label2.get_color() << std::endl;\n\n    Label::compose_text_and_color(&label1, &label2);\n\n    std::cout << \"\\nAfter composition:\" << std::endl;\n    std::cout << \"Label 1 Text: \" << label1.get_text() << \", Color: \" << label1.get_color() << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <iostream>\n\nclass Label {\npublic:\n    static const size_t MAX_TEXT_LENGTH = 100;\n    static const size_t MAX_COLOR_LENGTH = 20;\n\n    Label() : text_(), color_() {}\n\n\n    Label* set_text(const char* text) {\n        std::strncpy(text_, text, MAX_TEXT_LENGTH);\n        text_[MAX_TEXT_LENGTH - 1] = '\\0';\n        return this;\n    }\n\n\n    Label* set_color(const char* color) {\n        std::strncpy(color_, color, MAX_COLOR_LENGTH);\n        color_[MAX_COLOR_LENGTH - 1] = '\\0';\n        return this;\n    }\n\n\n    static void compose_text_and_color(Label* label1, const Label* label2) {\n\n        char tempText[MAX_TEXT_LENGTH];\n        char tempColor[MAX_COLOR_LENGTH];\n<diff>        std::strcpy(tempText, label1->text_);\n        std::strcpy(tempColor, label1->color_);</diff>\n\n\n        std::strncpy(label1->text_, tempText, MAX_TEXT_LENGTH - 1);\n        strncat(label1->text_, label2->text_, MAX_TEXT_LENGTH - std::strlen(label1->text_) - 1);\n\n\n        std::strncpy(label1->color_, tempColor, MAX_COLOR_LENGTH - 1);\n        strncat(label1->color_, label2->color_, MAX_COLOR_LENGTH - std::strlen(label1->color_) - 1);\n    }\n\n\n    const char* get_text() const { return text_; }\n    const char* get_color() const { return color_; }\n\nprivate:\n    char text_[MAX_TEXT_LENGTH];\n    char color_[MAX_COLOR_LENGTH];\n};\n\n\nint main() {\n    Label label1;\n    Label label2;\n\n    label1.set_text(\"Hello\").set_color(\"Red\");\n    label2.set_text(\" World\").set_color(\" Blue\");\n\n    std::cout << \"Before composition:\" << std::endl;\n    std::cout << \"Label 1 Text: \" << label1.get_text() << \", Color: \" << label1.get_color() << std::endl;\n    std::cout << \"Label 2 Text: \" << label2.get_text() << \", Color: \" << label2.get_color() << std::endl;\n\n    Label::compose_text_and_color(&label1, &label2);\n\n    std::cout << \"\\nAfter composition:\" << std::endl;\n    std::cout << \"Label 1 Text: \" << label1.get_text() << \", Color: \" << label1.get_color() << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `get_column_names` that takes an integer `n` as input and returns a dynamically allocated array of C-style strings representing spreadsheet column names (A, B, ..., Z, AA, AB, etc.). Each column name must be stored in a fixed-size buffer of 10 bytes. The function should return a pointer to the array of strings. For example, `get_column_names(3)` should return an array containing `\"A\"`, `\"B\"`, `\"C\"`, and `get_column_names(27)` should include `\"AA\"` as the 27th element. Ensure the function handles large values of `n` correctly.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar** get_column_names(int n) {\n    if (n <= 0) return nullptr;\n\n\n    char** columnNames = new char*[n];\n    for (int i = 0; i < n; ++i) {\n        columnNames[i] = new char[10];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int num = i + 1;\n        int j = 9;\n        columnNames[i][j] = '\\0';\n\n        while (num > 0) {\n            int rem = num % 26;\n            if (rem == 0) {\n                columnNames[i][--j] = 'Z';\n                num = (num / 26) - 1;\n            } else {\n                columnNames[i][--j] = 'A' + (rem - 1);\n                num /= 26;\n            }\n        }\n\n\n<diff>        std::memmove(columnNames[i], &columnNames[i][j + 1], 10 - j - 1);</diff>\n    }\n\n    return columnNames;\n}\n\nvoid free_column_names(char** columnNames, int n) {\n    for (int i = 0; i < n; ++i) {\n        delete[] columnNames[i];\n    }\n    delete[] columnNames;\n}\n\nint main() {\n    int n = 28;\n    char** columnNames = get_column_names(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cout << \"Column \" << i + 1 << \": \" << columnNames[i] << std::endl;\n    }\n\n    free_column_names(columnNames, n);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nchar** get_column_names(int n) {\n    if (n <= 0) return nullptr;\n\n\n    char** columnNames = new char*[n];\n    for (int i = 0; i < n; ++i) {\n        columnNames[i] = new char[10];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int num = i + 1;\n        int j = 9;\n        columnNames[i][j] = '\\0';\n\n        while (num > 0) {\n            int rem = num % 26;\n            if (rem == 0) {\n                columnNames[i][--j] = 'Z';\n                num = (num / 26) - 1;\n            } else {\n                columnNames[i][--j] = 'A' + (rem - 1);\n                num /= 26;\n            }\n        }\n\n\n<diff>        std::strcpy(columnNames[i], &columnNames[i][j + 1]);</diff>\n    }\n\n    return columnNames;\n}\n\nvoid free_column_names(char** columnNames, int n) {\n    for (int i = 0; i < n; ++i) {\n        delete[] columnNames[i];\n    }\n    delete[] columnNames;\n}\n\nint main() {\n    int n = 28;\n    char** columnNames = get_column_names(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cout << \"Column \" << i + 1 << \": \" << columnNames[i] << std::endl;\n    }\n\n    free_column_names(columnNames, n);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that computes the factorial of a number n and stores the result in a character buffer for output. The function should take an integer n and a character buffer as arguments, and write the factorial result as a string into the buffer.\n\nThe factorial of a number is the product of all the positive integers less than or equal to that number. For example, the factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n\nFor efficiency, the function should first compute the factorial as an integer, then convert it to a string and write it directly into the provided buffer. The buffer is assumed to be large enough to hold the result. The function should return the number of characters written.\n\nNote: The factorial of even small numbers can produce very large results (20! is 2432902008176640000), so be careful with your buffer handling.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\n<diff>size_t factorial(int n, char* buffer, size_t bufferSize) {\n    if (n < 0) {\n        std::strncpy(buffer, \"Error: Negative input\", bufferSize - 1);\n        buffer[bufferSize - 1] = '\\0';\n        return std::strlen(buffer);\n    }\n\n    unsigned long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n\n    std::snprintf(buffer, bufferSize, \"%llu\", result);\n    return std::strlen(buffer);\n}\n\nint main() {\n    char buffer[100];\n    int n = 20;\n    size_t length = factorial(n, buffer, sizeof(buffer));</diff>\n    std::cout << \"Factorial of \" << n << \" is: \" << buffer << \" (Length: \" << length << \")\" << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\n<diff>size_t factorial(int n, char* buffer) {\n    if (n < 0) {\n        std::strcpy(buffer, \"Error: Negative input\");\n        return std::strlen(\"Error: Negative input\");\n    }\n\n    unsigned long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n\n    std::sprintf(buffer, \"%llu\", result);\n    return std::strlen(buffer);\n}\n\nint main() {\n    char buffer[100];\n    int n = 20;\n    size_t length = factorial(n, buffer);</diff>\n    std::cout << \"Factorial of \" << n << \" is: \" << buffer << \" (Length: \" << length << \")\" << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `combinePaths` that takes two C-style strings `base_path` and `file_name` and combines them into a single path stored in a fixed-size output buffer of 256 bytes. The function should handle cases where `base_path` has a trailing slash, where `file_name` has a leading slash, and where both have a trailing or leading slash. The combined path should be built by directly manipulating the output buffer using string operations. Return the combined path as a const char* pointing to the output buffer.\n\nYour code should pass the following assertions when executed:\nassert(strcmp(combinePaths(\"/home/\", \"user\"), \"/home/user\") == 0);\nassert(strcmp(combinePaths(\"/home/\", \"/file.txt\"), \"/home/file.txt\") == 0);\nassert(strcmp(combinePaths(\"/home/user/\", \"/file.txt\"), \"/home/user/file.txt\") == 0);", "chosen": "```cpp\n#include <cstring>\n#include <cassert>\n\nconst char* combinePaths(const char* base_path, const char* file_name) {\n    static char result[256];\n    result[0] = '\\0';\n\n\n    size_t base_len = strlen(base_path);\n    size_t file_len = strlen(file_name);\n\n\n    bool base_ends_with_slash = (base_len > 0 && base_path[base_len - 1] == '/');\n    bool file_starts_with_slash = (file_len > 0 && file_name[0] == '/');\n\n\n<diff>    strncpy(result, base_path, sizeof(result) - 1);\n    result[sizeof(result) - 1] = '\\0';\n\n\n    if (base_ends_with_slash && file_starts_with_slash) {\n\n        strncat(result, file_name + 1, sizeof(result) - strlen(result) - 1);\n    } else if (!base_ends_with_slash && !file_starts_with_slash) {\n\n        if (strlen(result) < sizeof(result) - 2) {\n            strcat(result, \"/\");\n        }\n        strncat(result, file_name, sizeof(result) - strlen(result) - 1);\n    } else {\n\n        strncat(result, file_name, sizeof(result) - strlen(result) - 1);</diff>\n    }\n\n    return result;\n}\n\nint main() {\n\n    assert(strcmp(combinePaths(\"/home/\", \"user\"), \"/home/user\") == 0);\n    assert(strcmp(combinePaths(\"/home/\", \"/file.txt\"), \"/home/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user/\", \"/file.txt\"), \"/home/user/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user\", \"file.txt\"), \"/home/user/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"home/\", \"user\"), \"home/user\") == 0);\n    assert(strcmp(combinePaths(\"/\", \"file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/\", \"/file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"\", \"file.txt\"), \"file.txt\") == 0);\n    assert(strcmp(combinePaths(\"\", \"/file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user/\", \"\"), \"/home/user/\") == 0);\n    assert(strcmp(combinePaths(\"/home/user\", \"\"), \"/home/user\") == 0);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cassert>\n\nconst char* combinePaths(const char* base_path, const char* file_name) {\n    static char result[256];\n    result[0] = '\\0';\n\n\n    size_t base_len = strlen(base_path);\n    size_t file_len = strlen(file_name);\n\n\n    bool base_ends_with_slash = (base_len > 0 && base_path[base_len - 1] == '/');\n    bool file_starts_with_slash = (file_len > 0 && file_name[0] == '/');\n\n\n<diff>    strcpy(result, base_path);\n\n\n    if (base_ends_with_slash && file_starts_with_slash) {\n\n        strcat(result, file_name + 1);\n    } else if (!base_ends_with_slash && !file_starts_with_slash) {\n\n        strcat(result, \"/\");\n        strcat(result, file_name);\n    } else {\n\n        strcat(result, file_name);</diff>\n    }\n\n    return result;\n}\n\nint main() {\n\n    assert(strcmp(combinePaths(\"/home/\", \"user\"), \"/home/user\") == 0);\n    assert(strcmp(combinePaths(\"/home/\", \"/file.txt\"), \"/home/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user/\", \"/file.txt\"), \"/home/user/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user\", \"file.txt\"), \"/home/user/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"home/\", \"user\"), \"home/user\") == 0);\n    assert(strcmp(combinePaths(\"/\", \"file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/\", \"/file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"\", \"file.txt\"), \"file.txt\") == 0);\n    assert(strcmp(combinePaths(\"\", \"/file.txt\"), \"/file.txt\") == 0);\n    assert(strcmp(combinePaths(\"/home/user/\", \"\"), \"/home/user/\") == 0);\n    assert(strcmp(combinePaths(\"/home/user\", \"\"), \"/home/user\") == 0);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes tasks in parallel and stores the results in a fixed-size buffer. The function should take:\n1. A vector of input arguments\n2. A function pointer to process each argument\n3. An optional number of worker threads (default to hardware concurrency)\n4. A maximum retry count for failed operations\n\nThe function must:\n- Process inputs in parallel using the specified number of threads\n- Retry failed operations up to the specified maximum count\n- Store all results sequentially in a pre-allocated output buffer of size 1024 bytes\n- Use pointer arithmetic to efficiently place results in the buffer\n- Return the number of successful operations\n\nNote: The processing function may return variable-length strings, and the output buffer should accommodate all results without truncation.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <functional>\n#include <atomic>\n#include <mutex>\n#include <condition_variable>\n#include <cstring>\n\nusing namespace std;\n\nint processTasksInParallel(\n    const vector<string>& inputs,\n    function<string(const string&)> processFunction,\n    unsigned int numThreads = thread::hardware_concurrency(),\n    unsigned int maxRetries = 3\n) {\n    atomic<unsigned int> successCount(0);\n    mutex mtx;\n    condition_variable cv;\n    bool done = false;\n\n    char outputBuffer[1024];\n    char* currentPos = outputBuffer;\n    const char* endPos = outputBuffer + sizeof(outputBuffer);\n\n    auto worker = [&]() {\n        while (true) {\n            string input;\n            {\n                unique_lock<mutex> lock(mtx);\n                cv.wait(lock, [&] { return done || !inputs.empty(); });\n                if (done && inputs.empty()) break;\n                input = inputs.back();\n                inputs.pop_back();\n            }\n\n            bool success = false;\n            unsigned int retries = 0;\n            string result;\n            while (!success && retries < maxRetries) {\n                try {\n                    result = processFunction(input);\n                    success = true;\n                } catch (...) {\n                    ++retries;\n                }\n            }\n\n            if (success) {\n                lock_guard<mutex> lock(mtx);\n                if (currentPos + result.size() + 1 < endPos) {\n<diff>                    strncpy(currentPos, result.c_str(), endPos - currentPos - 1);</diff>\n                    currentPos += result.size() + 1;\n                    ++successCount;\n                } else {\n\n                    cout << \"Buffer overflow! Skipping result.\" << endl;\n                }\n            }\n        }\n    };\n\n    vector<thread> workers;\n    for (unsigned int i = 0; i < numThreads; ++i) {\n        workers.emplace_back(worker);\n    }\n\n    {\n        lock_guard<mutex> lock(mtx);\n        done = true;\n    }\n    cv.notify_all();\n\n    for (auto& t : workers) {\n        if (t.joinable()) {\n            t.join();\n        }\n    }\n\n    return successCount;\n}\n\n\nint main() {\n    vector<string> inputs = {\"task1\", \"task2\", \"task3\"};\n    auto processFunction = [](const string& input) -> string {\n\n        if (input == \"task2\") {\n            throw runtime_error(\"Simulated failure\");\n        }\n        return \"Processed \" + input;\n    };\n\n    int successfulOperations = processTasksInParallel(inputs, processFunction);\n    cout << \"Successful operations: \" << successfulOperations << endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <functional>\n#include <atomic>\n#include <mutex>\n#include <condition_variable>\n#include <cstring>\n\nusing namespace std;\n\nint processTasksInParallel(\n    const vector<string>& inputs,\n    function<string(const string&)> processFunction,\n    unsigned int numThreads = thread::hardware_concurrency(),\n    unsigned int maxRetries = 3\n) {\n    atomic<unsigned int> successCount(0);\n    mutex mtx;\n    condition_variable cv;\n    bool done = false;\n\n    char outputBuffer[1024];\n    char* currentPos = outputBuffer;\n    const char* endPos = outputBuffer + sizeof(outputBuffer);\n\n    auto worker = [&]() {\n        while (true) {\n            string input;\n            {\n                unique_lock<mutex> lock(mtx);\n                cv.wait(lock, [&] { return done || !inputs.empty(); });\n                if (done && inputs.empty()) break;\n                input = inputs.back();\n                inputs.pop_back();\n            }\n\n            bool success = false;\n            unsigned int retries = 0;\n            string result;\n            while (!success && retries < maxRetries) {\n                try {\n                    result = processFunction(input);\n                    success = true;\n                } catch (...) {\n                    ++retries;\n                }\n            }\n\n            if (success) {\n                lock_guard<mutex> lock(mtx);\n                if (currentPos + result.size() + 1 < endPos) {\n<diff>                    strcpy(currentPos, result.c_str());</diff>\n                    currentPos += result.size() + 1;\n                    ++successCount;\n                } else {\n\n                    cout << \"Buffer overflow! Skipping result.\" << endl;\n                }\n            }\n        }\n    };\n\n    vector<thread> workers;\n    for (unsigned int i = 0; i < numThreads; ++i) {\n        workers.emplace_back(worker);\n    }\n\n    {\n        lock_guard<mutex> lock(mtx);\n        done = true;\n    }\n    cv.notify_all();\n\n    for (auto& t : workers) {\n        if (t.joinable()) {\n            t.join();\n        }\n    }\n\n    return successCount;\n}\n\n\nint main() {\n    vector<string> inputs = {\"task1\", \"task2\", \"task3\"};\n    auto processFunction = [](const string& input) -> string {\n\n        if (input == \"task2\") {\n            throw runtime_error(\"Simulated failure\");\n        }\n        return \"Processed \" + input;\n    };\n\n    int successfulOperations = processTasksInParallel(inputs, processFunction);\n    cout << \"Successful operations: \" << successfulOperations << endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ class `MethodInvoker` with the following requirements:\n1. The class should store method names as fixed-length character arrays (maximum 32 characters each)\n2. Implement a method `bool invokeIfPresent(const char* methodName)` that:\n   - Takes a method name as a null-terminated string\n   - If the name matches one of the stored methods (case-sensitive), executes it and returns true\n   - Otherwise returns false\n3. The class must support at least 3 methods: `start`, `stop`, and `status`\n4. For efficiency, method name comparisons should be done by copying the input into a temporary buffer before comparison\n\nNote: Assume all method names will be valid C-strings of reasonable length (but don't explicitly check lengths).", "chosen": "```cpp\n#include <cstring>\n#include <iostream>\n\nclass MethodInvoker {\nprivate:\n    static const size_t MAX_METHOD_NAME_LENGTH = 32;\n    static const size_t NUM_METHODS = 3;\n\n    char methods[NUM_METHODS][MAX_METHOD_NAME_LENGTH];\n\npublic:\n    MethodInvoker() {\n<diff>        std::strncpy(methods[0], \"start\", MAX_METHOD_NAME_LENGTH - 1);\n        methods[0][MAX_METHOD_NAME_LENGTH - 1] = '\\0';\n        std::strncpy(methods[1], \"stop\", MAX_METHOD_NAME_LENGTH - 1);\n        methods[1][MAX_METHOD_NAME_LENGTH - 1] = '\\0';\n        std::strncpy(methods[2], \"status\", MAX_METHOD_NAME_LENGTH - 1);\n        methods[2][MAX_METHOD_NAME_LENGTH - 1] = '\\0';</diff>\n    }\n\n    bool invokeIfPresent(const char* methodName) {\n        char tempBuffer[MAX_METHOD_NAME_LENGTH];\n        std::strncpy(tempBuffer, methodName, MAX_METHOD_NAME_LENGTH - 1);\n        tempBuffer[MAX_METHOD_NAME_LENGTH - 1] = '\\0';\n\n        for (size_t i = 0; i < NUM_METHODS; ++i) {\n            if (std::strcmp(methods[i], tempBuffer) == 0) {\n                switch (i) {\n                    case 0:\n                        start();\n                        break;\n                    case 1:\n                        stop();\n                        break;\n                    case 2:\n                        status();\n                        break;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    void start() {\n        std::cout << \"Starting...\" << std::endl;\n    }\n\n    void stop() {\n        std::cout << \"Stopping...\" << std::endl;\n    }\n\n    void status() {\n        std::cout << \"Status: Running\" << std::endl;\n    }\n};\n\nint main() {\n    MethodInvoker invoker;\n    invoker.invokeIfPresent(\"start\");\n    invoker.invokeIfPresent(\"stop\");\n    invoker.invokeIfPresent(\"status\");\n    invoker.invokeIfPresent(\"pause\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <iostream>\n\nclass MethodInvoker {\nprivate:\n    static const size_t MAX_METHOD_NAME_LENGTH = 32;\n    static const size_t NUM_METHODS = 3;\n\n    char methods[NUM_METHODS][MAX_METHOD_NAME_LENGTH];\n\npublic:\n    MethodInvoker() {\n<diff>        std::strcpy(methods[0], \"start\");\n        std::strcpy(methods[1], \"stop\");\n        std::strcpy(methods[2], \"status\");</diff>\n    }\n\n    bool invokeIfPresent(const char* methodName) {\n        char tempBuffer[MAX_METHOD_NAME_LENGTH];\n        std::strncpy(tempBuffer, methodName, MAX_METHOD_NAME_LENGTH - 1);\n        tempBuffer[MAX_METHOD_NAME_LENGTH - 1] = '\\0';\n\n        for (size_t i = 0; i < NUM_METHODS; ++i) {\n            if (std::strcmp(methods[i], tempBuffer) == 0) {\n                switch (i) {\n                    case 0:\n                        start();\n                        break;\n                    case 1:\n                        stop();\n                        break;\n                    case 2:\n                        status();\n                        break;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    void start() {\n        std::cout << \"Starting...\" << std::endl;\n    }\n\n    void stop() {\n        std::cout << \"Stopping...\" << std::endl;\n    }\n\n    void status() {\n        std::cout << \"Status: Running\" << std::endl;\n    }\n};\n\nint main() {\n    MethodInvoker invoker;\n    invoker.invokeIfPresent(\"start\");\n    invoker.invokeIfPresent(\"stop\");\n    invoker.invokeIfPresent(\"status\");\n    invoker.invokeIfPresent(\"pause\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that checks if a logging handler with a given name already exists in a logger's configuration. The function should take a logger object (assume it has a `handlers` member that is a vector of strings) and a handler name as a null-terminated character array. For efficiency, implement this by first copying the handler name into a fixed-size 256-byte buffer, then comparing it against each existing handler name in the logger's configuration. Return true if the handler name is not found, false if it exists. You must perform all string operations directly on the character buffers without using C++ string classes.", "chosen": "```cpp\n#include <cstring>\n#include <vector>\n\nstruct Logger {\n    std::vector<const char*> handlers;\n};\n\nbool isHandlerNameUnique(Logger& logger, const char* handlerName) {\n\n<diff>    for (const char* handler : logger.handlers) {\n\n        if (std::strcmp(handler, handlerName) == 0) {</diff>\n            return false;\n        }\n    }\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <vector>\n\nstruct Logger {\n    std::vector<const char*> handlers;\n};\n\nbool isHandlerNameUnique(Logger& logger, const char* handlerName) {\n\n<diff>    char handlerBuffer[256];\n\n\n    std::strcpy(handlerBuffer, handlerName);\n\n\n    for (const char* handler : logger.handlers) {\n\n        if (std::strcmp(handler, handlerBuffer) == 0) {</diff>\n            return false;\n        }\n    }\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that finds the closest string match from a list of candidate strings. The function should take two parameters: (1) a null-terminated input string and (2) an array of null-terminated candidate strings. For efficiency, implement the fuzzy matching by modifying the input string in-place to create potential matches, then compare against the candidates. The function should return a pointer to the closest matching candidate string.\n\nYour code should pass these test cases:\n1. find_closest_match(\"intall\", {\"install\", \"installs\", \"installed\", \"installer\"}) should return \"install\"\n2. find_closest_match(\"install\", {\"install\", \"uninstall\", \"remove\", \"upgrade\"}) should return \"install\"", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n<diff>#include <cstdio>\n\nconst char* find_closest_match(const char* input, const char* candidates[], size_t num_candidates) {\n\n    char mutable_input[256];\n    std::strncpy(mutable_input, input, sizeof(mutable_input) - 1);\n    mutable_input[sizeof(mutable_input) - 1] = '\\0';</diff>\n\n    const char* best_match = nullptr;\n    int max_matches = 0;\n\n    for (size_t i = 0; i < num_candidates; ++i) {\n        const char* candidate = candidates[i];\n        size_t input_len = std::strlen(mutable_input);\n        size_t candidate_len = std::strlen(candidate);\n        size_t min_len = (input_len < candidate_len) ? input_len : candidate_len;\n        int matches = 0;\n\n        for (size_t j = 0; j < min_len; ++j) {\n            if (mutable_input[j] == candidate[j]) {\n                ++matches;\n            }\n        }\n\n\n        if (std::abs((int)input_len - (int)candidate_len) <= 1) {\n            ++matches;\n        }\n\n        if (matches > max_matches) {\n            max_matches = matches;\n            best_match = candidate;\n        }\n    }\n\n    return best_match;\n}\n\n\n#include <iostream>\n\nint main() {\n    const char* result1 = find_closest_match(\"intall\", (const char*[]){\"install\", \"installs\", \"installed\", \"installer\"}, 4);\n    std::cout << \"Closest match for 'intall': \" << result1 << std::endl;\n\n    const char* result2 = find_closest_match(\"install\", (const char*[]){\"install\", \"uninstall\", \"remove\", \"upgrade\"}, 4);\n    std::cout << \"Closest match for 'install': \" << result2 << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n<diff>\nconst char* find_closest_match(const char* input, const char* candidates[], size_t num_candidates) {\n\n    char mutable_input[256];\n    std::strcpy(mutable_input, input);</diff>\n\n    const char* best_match = nullptr;\n    int max_matches = 0;\n\n    for (size_t i = 0; i < num_candidates; ++i) {\n        const char* candidate = candidates[i];\n        size_t input_len = std::strlen(mutable_input);\n        size_t candidate_len = std::strlen(candidate);\n        size_t min_len = (input_len < candidate_len) ? input_len : candidate_len;\n        int matches = 0;\n\n        for (size_t j = 0; j < min_len; ++j) {\n            if (mutable_input[j] == candidate[j]) {\n                ++matches;\n            }\n        }\n\n\n        if (std::abs((int)input_len - (int)candidate_len) <= 1) {\n            ++matches;\n        }\n\n        if (matches > max_matches) {\n            max_matches = matches;\n            best_match = candidate;\n        }\n    }\n\n    return best_match;\n}\n\n\n#include <iostream>\n\nint main() {\n    const char* result1 = find_closest_match(\"intall\", (const char*[]){\"install\", \"installs\", \"installed\", \"installer\"}, 4);\n    std::cout << \"Closest match for 'intall': \" << result1 << std::endl;\n\n    const char* result2 = find_closest_match(\"install\", (const char*[]){\"install\", \"uninstall\", \"remove\", \"upgrade\"}, 4);\n    std::cout << \"Closest match for 'install': \" << result2 << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `stringifyMap` that takes an unordered_map<string, string> and writes its contents into a pre-allocated character buffer. The output format should be \"key1: value1, key2: value2, ...\". For maximum efficiency, construct the string directly in the provided 256-byte output buffer without using intermediate string objects. Handle non-string values by converting them to strings in-place. The function should return the number of characters written to the buffer.\n\nNote: The input map may contain up to 20 key-value pairs, and you should minimize memory allocations by working directly in the output buffer.", "chosen": "```cpp\n#include <unordered_map>\n#include <cstring>\n\nsize_t stringifyMap(const std::unordered_map<std::string, std::string>& inputMap, char* outputBuffer, size_t bufferSize) {\n    if (bufferSize == 0 || outputBuffer == nullptr) {\n        return 0;\n    }\n\n    size_t currentIndex = 0;\n    bool firstEntry = true;\n\n    for (const auto& pair : inputMap) {\n        const std::string& key = pair.first;\n        const std::string& value = pair.second;\n\n\n        size_t requiredSpace = key.size() + value.size() + 4;\n        if (!firstEntry) {\n            requiredSpace += 2;\n        }\n\n\n        if (currentIndex + requiredSpace >= bufferSize) {\n            break;\n        }\n\n\n        if (!firstEntry) {\n<diff>            std::strncpy(outputBuffer + currentIndex, \", \", 2);\n            currentIndex += 2;\n        }\n\n\n        std::strncpy(outputBuffer + currentIndex, key.c_str(), bufferSize - currentIndex);\n        currentIndex += key.size();\n\n\n        std::strncpy(outputBuffer + currentIndex, \": \", 2);\n        currentIndex += 2;\n\n\n        std::strncpy(outputBuffer + currentIndex, value.c_str(), bufferSize - currentIndex);</diff>\n        currentIndex += value.size();\n\n        firstEntry = false;\n    }\n\n\n    if (currentIndex < bufferSize) {\n        outputBuffer[currentIndex] = '\\0';\n    } else {\n\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n\n    return currentIndex;\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <cstring>\n\nsize_t stringifyMap(const std::unordered_map<std::string, std::string>& inputMap, char* outputBuffer, size_t bufferSize) {\n    if (bufferSize == 0 || outputBuffer == nullptr) {\n        return 0;\n    }\n\n    size_t currentIndex = 0;\n    bool firstEntry = true;\n\n    for (const auto& pair : inputMap) {\n        const std::string& key = pair.first;\n        const std::string& value = pair.second;\n\n\n        size_t requiredSpace = key.size() + value.size() + 4;\n        if (!firstEntry) {\n            requiredSpace += 2;\n        }\n\n\n        if (currentIndex + requiredSpace >= bufferSize) {\n            break;\n        }\n\n\n        if (!firstEntry) {\n<diff>            std::strcpy(outputBuffer + currentIndex, \", \");\n            currentIndex += 2;\n        }\n\n\n        std::strcpy(outputBuffer + currentIndex, key.c_str());\n        currentIndex += key.size();\n\n\n        std::strcpy(outputBuffer + currentIndex, \": \");\n        currentIndex += 2;\n\n\n        std::strcpy(outputBuffer + currentIndex, value.c_str());</diff>\n        currentIndex += value.size();\n\n        firstEntry = false;\n    }\n\n\n    if (currentIndex < bufferSize) {\n        outputBuffer[currentIndex] = '\\0';\n    } else {\n\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n\n    return currentIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that reads a JSON file and returns a map where the keys are the names of the JSON object fields (as C-style strings) and the values are strings indicating the field types (\"string\", \"number\", \"array\", or \"object\").\n\nFor efficiency, field names should be stored in pre-allocated character buffers of size 256. The function should parse the JSON manually without using external libraries. For example, given this JSON content:\n\n{\n  \"field1\": \"string\",\n  \"field2\": 123,\n  \"field3\": [\"1\", \"2\", \"3\"],\n  \"field4\": {\"nested\": \"value\"}\n}\n\nThe function should return a map containing:\n\n{\n  \"field1\": \"string\",\n  \"field2\": \"number\",\n  \"field3\": \"array\",\n  \"field4\": \"object\"\n}\n\nNote: You may assume the JSON is properly formatted but field names could be up to 255 characters long.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <cstring>\n\n\nvoid skipWhitespace(const char*& ptr) {\n    while (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r') ++ptr;\n}\n\n\nbool parseString(const char*& ptr, char buffer[256]) {\n    if (*ptr != '\"') return false;\n    ++ptr;\n    char* dest = buffer;\n    while (*ptr != '\"') {\n        if (*ptr == '\\\\') {\n            ++ptr;\n            if (*ptr == '\"' || *ptr == '\\\\') {\n                *dest++ = *ptr++;\n            } else if (*ptr == 'n') {\n                *dest++ = '\\n';\n                ++ptr;\n            } else if (*ptr == 't') {\n                *dest++ = '\\t';\n                ++ptr;\n            }\n\n        } else {\n            *dest++ = *ptr++;\n        }\n        if (dest - buffer >= 255) break;\n    }\n    *dest = '\\0';\n    ++ptr;\n    return true;\n}\n\n\nconst char* determineType(const char*& ptr) {\n    skipWhitespace(ptr);\n    if (*ptr == '\"') {\n        parseString(ptr, nullptr);\n        return \"string\";\n    } else if ((*ptr >= '0' && *ptr <= '9') || *ptr == '-') {\n        while ((*ptr >= '0' && *ptr <= '9') || *ptr == '-' || *ptr == '.' || *ptr == 'e' || *ptr == 'E') ++ptr;\n        return \"number\";\n    } else if (*ptr == '[') {\n        ++ptr;\n        return \"array\";\n    } else if (*ptr == '{') {\n        ++ptr;\n        return \"object\";\n    }\n    return \"unknown\";\n}\n\n\nstd::map<char*, const char*> parseJSONFile(const char* filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return {};\n    }\n\n    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    const char* ptr = content.c_str();\n    std::map<char*, const char*> result;\n\n    skipWhitespace(ptr);\n    if (*ptr != '{') {\n        std::cerr << \"Invalid JSON format: expected an object\" << std::endl;\n        return {};\n    }\n    ++ptr;\n\n    while (*ptr != '}') {\n        skipWhitespace(ptr);\n        if (*ptr == '}') break;\n\n        char fieldNameBuffer[256];\n        if (!parseString(ptr, fieldNameBuffer)) {\n            std::cerr << \"Invalid JSON format: expected a field name\" << std::endl;\n            return {};\n        }\n        skipWhitespace(ptr);\n        if (*ptr != ':') {\n            std::cerr << \"Invalid JSON format: expected a colon after field name\" << std::endl;\n            return {};\n        }\n        ++ptr;\n\n        const char* fieldType = determineType(ptr);\n\n\n        char* fieldName = new char[strlen(fieldNameBuffer) + 1];\n<diff>        strncpy(fieldName, fieldNameBuffer, 255);\n        fieldName[255] = '\\0';</diff>\n\n        result[fieldName] = fieldType;\n\n        skipWhitespace(ptr);\n        if (*ptr == ',') {\n            ++ptr;\n        } else if (*ptr != '}') {\n            std::cerr << \"Invalid JSON format: expected a comma or closing brace\" << std::endl;\n            return {};\n        }\n    }\n    ++ptr;\n\n    return result;\n}\n\nint main() {\n    std::map<char*, const char*> jsonMap = parseJSONFile(\"example.json\");\n    for (const auto& pair : jsonMap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n        delete[] pair.first;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <cstring>\n\n\nvoid skipWhitespace(const char*& ptr) {\n    while (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r') ++ptr;\n}\n\n\nbool parseString(const char*& ptr, char buffer[256]) {\n    if (*ptr != '\"') return false;\n    ++ptr;\n    char* dest = buffer;\n    while (*ptr != '\"') {\n        if (*ptr == '\\\\') {\n            ++ptr;\n            if (*ptr == '\"' || *ptr == '\\\\') {\n                *dest++ = *ptr++;\n            } else if (*ptr == 'n') {\n                *dest++ = '\\n';\n                ++ptr;\n            } else if (*ptr == 't') {\n                *dest++ = '\\t';\n                ++ptr;\n            }\n\n        } else {\n            *dest++ = *ptr++;\n        }\n        if (dest - buffer >= 255) break;\n    }\n    *dest = '\\0';\n    ++ptr;\n    return true;\n}\n\n\nconst char* determineType(const char*& ptr) {\n    skipWhitespace(ptr);\n    if (*ptr == '\"') {\n        parseString(ptr, nullptr);\n        return \"string\";\n    } else if ((*ptr >= '0' && *ptr <= '9') || *ptr == '-') {\n        while ((*ptr >= '0' && *ptr <= '9') || *ptr == '-' || *ptr == '.' || *ptr == 'e' || *ptr == 'E') ++ptr;\n        return \"number\";\n    } else if (*ptr == '[') {\n        ++ptr;\n        return \"array\";\n    } else if (*ptr == '{') {\n        ++ptr;\n        return \"object\";\n    }\n    return \"unknown\";\n}\n\n\nstd::map<char*, const char*> parseJSONFile(const char* filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return {};\n    }\n\n    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    const char* ptr = content.c_str();\n    std::map<char*, const char*> result;\n\n    skipWhitespace(ptr);\n    if (*ptr != '{') {\n        std::cerr << \"Invalid JSON format: expected an object\" << std::endl;\n        return {};\n    }\n    ++ptr;\n\n    while (*ptr != '}') {\n        skipWhitespace(ptr);\n        if (*ptr == '}') break;\n\n        char fieldNameBuffer[256];\n        if (!parseString(ptr, fieldNameBuffer)) {\n            std::cerr << \"Invalid JSON format: expected a field name\" << std::endl;\n            return {};\n        }\n        skipWhitespace(ptr);\n        if (*ptr != ':') {\n            std::cerr << \"Invalid JSON format: expected a colon after field name\" << std::endl;\n            return {};\n        }\n        ++ptr;\n\n        const char* fieldType = determineType(ptr);\n\n\n        char* fieldName = new char[strlen(fieldNameBuffer) + 1];\n<diff>        strcpy(fieldName, fieldNameBuffer);</diff>\n\n        result[fieldName] = fieldType;\n\n        skipWhitespace(ptr);\n        if (*ptr == ',') {\n            ++ptr;\n        } else if (*ptr != '}') {\n            std::cerr << \"Invalid JSON format: expected a comma or closing brace\" << std::endl;\n            return {};\n        }\n    }\n    ++ptr;\n\n    return result;\n}\n\nint main() {\n    std::map<char*, const char*> jsonMap = parseJSONFile(\"example.json\");\n    for (const auto& pair : jsonMap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n        delete[] pair.first;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `build_query` that constructs a GraphQL query string in a pre-allocated character buffer. The function should take a buffer pointer, buffer size, a query name, and a list of fields (which may contain nested field lists). Format the fields as comma-separated strings within curly braces and concatenate them with the name. Handle nested fields by recursively calling `build_query` on each nested field list. For efficiency, build the string directly in the provided buffer without using dynamic memory allocation.\n\nExample:\nInput:\nchar buffer[256];\nconst char* name = \"user\";\nstd::vector<Field> fields = {\"id\", \"name\", \"address\", std::vector<Field>{\"street\", \"city\", \"state\"}, \"phoneNumber\"};\n\nOutput:\nbuffer contains \"user {id, name, address {street, city, state}, phoneNumber}\"", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <variant>\n#include <vector>\n#include <string>\n\nusing Field = std::variant<std::string, std::vector<Field>>;\n\nbool append_to_buffer(char*& buf, size_t& remaining, const char* str) {\n    size_t len = std::strlen(str);\n    if (len >= remaining) {\n        return false;\n    }\n<diff>    std::strncpy(buf, str, len);\n    buf[len] = '\\0';</diff>\n    buf += len;\n    remaining -= len;\n    return true;\n}\n\nbool append_field(char*& buf, size_t& remaining, const Field& field) {\n    if (std::holds_alternative<std::string>(field)) {\n        return append_to_buffer(buf, remaining, std::get<std::string>(field).c_str());\n    } else {\n        const auto& nested_fields = std::get<std::vector<Field>>(field);\n        if (!append_to_buffer(buf, remaining, \"{\")) {\n            return false;\n        }\n        for (size_t i = 0; i < nested_fields.size(); ++i) {\n            if (!append_field(buf, remaining, nested_fields[i])) {\n                return false;\n            }\n            if (i != nested_fields.size() - 1 && !append_to_buffer(buf, remaining, \", \")) {\n                return false;\n            }\n        }\n        return append_to_buffer(buf, remaining, \"}\");\n    }\n}\n\nbool build_query(char* buffer, size_t bufferSize, const char* name, const std::vector<Field>& fields) {\n    size_t remaining = bufferSize;\n    char* buf = buffer;\n\n    if (!append_to_buffer(buf, remaining, name) || !append_to_buffer(buf, remaining, \" {\")) {\n        return false;\n    }\n\n    for (size_t i = 0; i < fields.size(); ++i) {\n        if (!append_field(buf, remaining, fields[i])) {\n            return false;\n        }\n        if (i != fields.size() - 1 && !append_to_buffer(buf, remaining, \", \")) {\n            return false;\n        }\n    }\n\n    if (!append_to_buffer(buf, remaining, \"}\")) {\n        return false;\n    }\n\n    if (!append_to_buffer(buf, remaining, \"\")) {\n        return false;\n    }\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <variant>\n#include <vector>\n#include <string>\n\nusing Field = std::variant<std::string, std::vector<Field>>;\n\nbool append_to_buffer(char*& buf, size_t& remaining, const char* str) {\n    size_t len = std::strlen(str);\n    if (len >= remaining) {\n        return false;\n    }\n<diff>    std::strcpy(buf, str);</diff>\n    buf += len;\n    remaining -= len;\n    return true;\n}\n\nbool append_field(char*& buf, size_t& remaining, const Field& field) {\n    if (std::holds_alternative<std::string>(field)) {\n        return append_to_buffer(buf, remaining, std::get<std::string>(field).c_str());\n    } else {\n        const auto& nested_fields = std::get<std::vector<Field>>(field);\n        if (!append_to_buffer(buf, remaining, \"{\")) {\n            return false;\n        }\n        for (size_t i = 0; i < nested_fields.size(); ++i) {\n            if (!append_field(buf, remaining, nested_fields[i])) {\n                return false;\n            }\n            if (i != nested_fields.size() - 1 && !append_to_buffer(buf, remaining, \", \")) {\n                return false;\n            }\n        }\n        return append_to_buffer(buf, remaining, \"}\");\n    }\n}\n\nbool build_query(char* buffer, size_t bufferSize, const char* name, const std::vector<Field>& fields) {\n    size_t remaining = bufferSize;\n    char* buf = buffer;\n\n    if (!append_to_buffer(buf, remaining, name) || !append_to_buffer(buf, remaining, \" {\")) {\n        return false;\n    }\n\n    for (size_t i = 0; i < fields.size(); ++i) {\n        if (!append_field(buf, remaining, fields[i])) {\n            return false;\n        }\n        if (i != fields.size() - 1 && !append_to_buffer(buf, remaining, \", \")) {\n            return false;\n        }\n    }\n\n    if (!append_to_buffer(buf, remaining, \"}\")) {\n        return false;\n    }\n\n    if (!append_to_buffer(buf, remaining, \"\")) {\n        return false;\n    }\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `reverse_vowels` that reverses the vowels in a given string using a fixed-size character buffer of 256 bytes. The vowels to be reversed are 'a', 'e', 'i', 'o', and 'u' (both lowercase and uppercase). The function should:\n1. Copy the input string into the fixed-size buffer\n2. Perform the vowel reversal in-place within this buffer\n3. Return the modified buffer as a string\n\nFor example, `reverse_vowels(\"Hello World\")` should return \"Hollo Werld\".\n\nNote: For efficiency, all operations must be performed directly on the fixed buffer without using additional dynamic memory allocation.", "chosen": "```cpp\n#include <cstring>\n#include <string>\n\nbool isVowel(char c) {\n\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstd::string reverse_vowels(const std::string& input) {\n    char buffer[256];\n\n\n    if (input.size() >= 256) {\n        throw std::length_error(\"Input string exceeds buffer size\");\n    }\n\n\n<diff>    std::strncpy(buffer, input.c_str(), sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n    int left = 0;\n    int right = std::strlen(buffer) - 1;\n\n    while (left < right) {\n\n        while (left < right && !isVowel(buffer[left])) {\n            left++;\n        }\n\n\n        while (left < right && !isVowel(buffer[right])) {\n            right--;\n        }\n\n\n        if (left < right) {\n            std::swap(buffer[left], buffer[right]);\n            left++;\n            right--;\n        }\n    }\n\n\n    return std::string(buffer);\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <string>\n\nbool isVowel(char c) {\n\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstd::string reverse_vowels(const std::string& input) {\n    char buffer[256];\n\n\n    if (input.size() >= 256) {\n        throw std::length_error(\"Input string exceeds buffer size\");\n    }\n\n\n<diff>    std::strcpy(buffer, input.c_str());</diff>\n\n    int left = 0;\n    int right = std::strlen(buffer) - 1;\n\n    while (left < right) {\n\n        while (left < right && !isVowel(buffer[left])) {\n            left++;\n        }\n\n\n        while (left < right && !isVowel(buffer[right])) {\n            right--;\n        }\n\n\n        if (left < right) {\n            std::swap(buffer[left], buffer[right]);\n            left++;\n            right--;\n        }\n    }\n\n\n    return std::string(buffer);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `merge_ordered_strings` that takes three null-terminated character arrays (strings) as input and merges them into a single output buffer. The merged string should contain all characters from all input strings, maintaining their original order (first string's characters first, then second's, then third's). The function should write the result directly into the provided output buffer. Assume the output buffer is large enough to hold the result and don't perform any size checks for efficiency. The function should return the total number of characters written (excluding the null terminator).", "chosen": "```cpp\n#include <cstring>\n\n\n<diff>size_t merge_ordered_strings(const char* str1, const char* str2, const char* str3, char* output, size_t output_size) {\n\n    size_t len1 = std::strlen(str1);\n    if (len1 >= output_size) return 0;\n    std::strncpy(output, str1, len1);\n\n\n    size_t len2 = std::strlen(str2);\n    if (len1 + len2 >= output_size) return 0;\n    std::strncpy(output + len1, str2, len2);\n\n\n    size_t len3 = std::strlen(str3);\n    if (len1 + len2 + len3 >= output_size) return 0;\n    std::strncpy(output + len1 + len2, str3, len3);</diff>\n\n\n    output[len1 + len2 + len3] = '\\0';\n\n\n    return len1 + len2 + len3;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\n<diff>size_t merge_ordered_strings(const char* str1, const char* str2, const char* str3, char* output) {\n\n    size_t len1 = std::strlen(str1);\n    std::strcpy(output, str1);\n\n\n    size_t len2 = std::strlen(str2);\n    std::strcpy(output + len1, str2);\n\n\n    size_t len3 = std::strlen(str3);\n    std::strcpy(output + len1 + len2, str3);</diff>\n\n\n    output[len1 + len2 + len3] = '\\0';\n\n\n    return len1 + len2 + len3;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of time values represented as strings in \"YYYY-MM-DD HH:MM:SS\" format. The function should round each time to the nearest hour and store the results in a pre-allocated output buffer of fixed size. For performance optimization, implement the time parsing and rounding directly using character buffer manipulation without using high-level time libraries. The output buffer must contain the results in the same \"YYYY-MM-DD HH:MM:SS\" format, with each result string placed consecutively in the buffer. Assume the output buffer is exactly large enough to hold all results if each timestamp is exactly 19 characters long.", "chosen": "```cpp\n#include <cstring>\n\nvoid roundTimeToNearestHour(const char* input, char* output, size_t numTimes) {\n    for (size_t i = 0; i < numTimes; ++i) {\n        const char* currentInput = input + i * 19;\n        char* currentOutput = output + i * 19;\n\n\n        std::memcpy(currentOutput, currentInput, 14);\n        currentOutput += 14;\n\n\n        int hours = (currentInput[11] - '0') * 10 + (currentInput[12] - '0');\n        int minutes = (currentInput[14] - '0') * 10 + (currentInput[15] - '0');\n\n\n        if (minutes >= 30) {\n            hours = (hours + 1) % 24;\n        }\n\n\n        *currentOutput++ = '0' + (hours / 10);\n        *currentOutput++ = '0' + (hours % 10);\n\n\n<diff>        std::strncpy(currentOutput, \":00:00\", 6);</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid roundTimeToNearestHour(const char* input, char* output, size_t numTimes) {\n    for (size_t i = 0; i < numTimes; ++i) {\n        const char* currentInput = input + i * 19;\n        char* currentOutput = output + i * 19;\n\n\n        std::memcpy(currentOutput, currentInput, 14);\n        currentOutput += 14;\n\n\n        int hours = (currentInput[11] - '0') * 10 + (currentInput[12] - '0');\n        int minutes = (currentInput[14] - '0') * 10 + (currentInput[15] - '0');\n\n\n        if (minutes >= 30) {\n            hours = (hours + 1) % 24;\n        }\n\n\n        *currentOutput++ = '0' + (hours / 10);\n        *currentOutput++ = '0' + (hours % 10);\n\n\n<diff>        std::strcpy(currentOutput, \":00:00\");</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `print_raw` that takes a character buffer containing multiple strings separated by newline characters and prints each string on a separate line. For each line, the function must:\n1. Convert the line number to bytes and format it into a fixed-width string of exactly 4 characters, right-aligned and padded with zeroes\n2. Concatenate this formatted line number with a colon and a single space\n3. Append the original string from the buffer\n4. Print the complete formatted string\n\nAll string operations must be performed in-place using character buffers for efficiency. The function should process the input buffer until a null terminator is encountered.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\n\nvoid int_to_zero_padded_string(int num, char *str) {\n    str[0] = '0' + (num / 1000) % 10;\n    str[1] = '0' + (num / 100) % 10;\n    str[2] = '0' + (num / 10) % 10;\n    str[3] = '0' + num % 10;\n    str[4] = '\\0';\n}\n\n\nvoid print_raw(const char *buffer) {\n    int line_number = 0;\n    const char *start = buffer;\n\n    while (*buffer != '\\0') {\n\n        while (*buffer != '\\0' && *buffer != '\\n') {\n            ++buffer;\n        }\n\n\n        size_t line_length = buffer - start;\n\n\n        char formatted_line[8];\n        int_to_zero_padded_string(line_number, formatted_line);\n<diff>        std::strncpy(formatted_line + 4, \": \", 2);</diff>\n\n\n        std::fwrite(formatted_line, 1, 6, stdout);\n        std::fwrite(start, 1, line_length, stdout);\n        std::fputc('\\n', stdout);\n\n\n        if (*buffer == '\\n') {\n            ++buffer;\n        }\n        start = buffer;\n        ++line_number;\n    }\n}\n\n\nint main() {\n    const char buffer[] = \"Hello\\nWorld\\nThis\\nIs\\nA\\nTest\\n\";\n    print_raw(buffer);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\n\nvoid int_to_zero_padded_string(int num, char *str) {\n    str[0] = '0' + (num / 1000) % 10;\n    str[1] = '0' + (num / 100) % 10;\n    str[2] = '0' + (num / 10) % 10;\n    str[3] = '0' + num % 10;\n    str[4] = '\\0';\n}\n\n\nvoid print_raw(const char *buffer) {\n    int line_number = 0;\n    const char *start = buffer;\n\n    while (*buffer != '\\0') {\n\n        while (*buffer != '\\0' && *buffer != '\\n') {\n            ++buffer;\n        }\n\n\n        size_t line_length = buffer - start;\n\n\n        char formatted_line[8];\n        int_to_zero_padded_string(line_number, formatted_line);\n<diff>        std::strcpy(formatted_line + 4, \": \");</diff>\n\n\n        std::fwrite(formatted_line, 1, 6, stdout);\n        std::fwrite(start, 1, line_length, stdout);\n        std::fputc('\\n', stdout);\n\n\n        if (*buffer == '\\n') {\n            ++buffer;\n        }\n        start = buffer;\n        ++line_number;\n    }\n}\n\n\nint main() {\n    const char buffer[] = \"Hello\\nWorld\\nThis\\nIs\\nA\\nTest\\n\";\n    print_raw(buffer);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a map of string parameters. The function should take two arguments: (1) a map<string, char[]> of input parameters where both keys and values are strings (stored as character arrays), and (2) a map<string, bool> of valid parameter keys. For performance reasons, you should process the strings in-place without dynamic memory allocation.\n\nThe function should return a pair of maps: the first map should contain all valid parameters (where the key exists in the valid keys map), and the second map should contain all invalid parameters. Both keys and values should be copied exactly as they appear in the input.\n\nNote: Assume all character arrays in the input are properly null-terminated, but their lengths may vary. Your solution should efficiently handle strings of any length while working within fixed-size buffers.", "chosen": "```cpp\n#include <map>\n#include <utility>\n#include <cstring>\n\nconst int MAX_KEY_LENGTH = 100;\nconst int MAX_VALUE_LENGTH = 256;\n\nusing CharArrayKeyMap = std::map<char[MAX_KEY_LENGTH], char[MAX_VALUE_LENGTH]>;\nusing BoolMap = std::map<std::string, bool>;\n\nstd::pair<CharArrayKeyMap, CharArrayKeyMap> processParameters(const CharArrayKeyMap& inputParams, const BoolMap& validKeys) {\n    CharArrayKeyMap validParams;\n    CharArrayKeyMap invalidParams;\n\n    for (const auto& [key, value] : inputParams) {\n\n        std::string keyStr(key);\n\n        if (validKeys.find(keyStr) != validKeys.end()) {\n\n<diff>            strncpy(validParams[key], value, MAX_VALUE_LENGTH - 1);\n            validParams[key][MAX_VALUE_LENGTH - 1] = '\\0';\n        } else {\n\n            strncpy(invalidParams[key], value, MAX_VALUE_LENGTH - 1);\n            invalidParams[key][MAX_VALUE_LENGTH - 1] = '\\0';</diff>\n        }\n    }\n\n    return std::make_pair(validParams, invalidParams);\n}\n```", "rejected": "```cpp\n#include <map>\n#include <utility>\n#include <cstring>\n\nconst int MAX_KEY_LENGTH = 100;\nconst int MAX_VALUE_LENGTH = 256;\n\nusing CharArrayKeyMap = std::map<char[MAX_KEY_LENGTH], char[MAX_VALUE_LENGTH]>;\nusing BoolMap = std::map<std::string, bool>;\n\nstd::pair<CharArrayKeyMap, CharArrayKeyMap> processParameters(const CharArrayKeyMap& inputParams, const BoolMap& validKeys) {\n    CharArrayKeyMap validParams;\n    CharArrayKeyMap invalidParams;\n\n    for (const auto& [key, value] : inputParams) {\n\n        std::string keyStr(key);\n\n        if (validKeys.find(keyStr) != validKeys.end()) {\n\n<diff>            strcpy(validParams[key], value);\n        } else {\n\n            strcpy(invalidParams[key], value);</diff>\n        }\n    }\n\n    return std::make_pair(validParams, invalidParams);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a file path as a null-terminated character array and constructs a formatted string in a fixed-size output buffer (256 bytes). The output string should contain the file's name (without path) followed by its type. The file type should be determined by the extension: for `.txt` return `\"Text file\"`, for `.csv` return `\"CSV file\"`, and for other extensions return `\"Unknown file type\"`. The function must build the output string in-place by first copying the filename and then appending the file type description directly after it in the same buffer.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid getFileDescription(const char* filePath, char* outputBuffer, size_t bufferSize) {\n\n    if (bufferSize < 256) {\n        return;\n    }\n    memset(outputBuffer, 0, bufferSize);\n\n\n    const char* fileNameStart = filePath + strlen(filePath);\n    while (fileNameStart > filePath && *(fileNameStart - 1) != '/' && *(fileNameStart - 1) != '\\\\') {\n        --fileNameStart;\n    }\n\n\n    size_t fileNameLength = strnlen(fileNameStart, bufferSize - 1);\n    strncpy(outputBuffer, fileNameStart, bufferSize - 1);\n    outputBuffer[bufferSize - 1] = '\\0';\n\n\n    const char* dotPos = strchr(fileNameStart, '.');\n    const char* fileTypeDescription = \"Unknown file type\";\n\n    if (dotPos && dotPos - fileNameStart < fileNameLength) {\n\n        if (strcmp(dotPos, \".txt\") == 0) {\n            fileTypeDescription = \"Text file\";\n        } else if (strcmp(dotPos, \".csv\") == 0) {\n            fileTypeDescription = \"CSV file\";\n        }\n    }\n\n\n    size_t currentLength = strlen(outputBuffer);\n    if (currentLength + strlen(fileTypeDescription) + 2 < bufferSize) {\n<diff>        snprintf(outputBuffer + currentLength, bufferSize - currentLength, \" - %s\", fileTypeDescription);</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid getFileDescription(const char* filePath, char* outputBuffer, size_t bufferSize) {\n\n    if (bufferSize < 256) {\n        return;\n    }\n    memset(outputBuffer, 0, bufferSize);\n\n\n    const char* fileNameStart = filePath + strlen(filePath);\n    while (fileNameStart > filePath && *(fileNameStart - 1) != '/' && *(fileNameStart - 1) != '\\\\') {\n        --fileNameStart;\n    }\n\n\n    size_t fileNameLength = strnlen(fileNameStart, bufferSize - 1);\n    strncpy(outputBuffer, fileNameStart, bufferSize - 1);\n    outputBuffer[bufferSize - 1] = '\\0';\n\n\n    const char* dotPos = strchr(fileNameStart, '.');\n    const char* fileTypeDescription = \"Unknown file type\";\n\n    if (dotPos && dotPos - fileNameStart < fileNameLength) {\n\n        if (strcmp(dotPos, \".txt\") == 0) {\n            fileTypeDescription = \"Text file\";\n        } else if (strcmp(dotPos, \".csv\") == 0) {\n            fileTypeDescription = \"CSV file\";\n        }\n    }\n\n\n    size_t currentLength = strlen(outputBuffer);\n    if (currentLength + strlen(fileTypeDescription) + 2 < bufferSize) {\n<diff>        strcat(outputBuffer, \" - \");\n        strcat(outputBuffer, fileTypeDescription);</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `getCategoryValues` that processes an array of structs containing key-value pairs. Each struct has a fixed-size character array `key` (128 bytes) and a string `value`. The function should take:\n1. An array of these structs\n2. A C-style string `category` (null-terminated)\n3. An output character buffer `results` (pre-allocated with 1024 bytes)\n\nFor each struct where the `key` matches the `category` string, concatenate its `value` into the `results` buffer separated by commas. The function should return the number of matches found.\n\nExample:\nIf input contains structs with keys \"age\" and values \"25\", \"30\", and another category \"name\" with value \"John\", when searching for category \"age\", the `results` buffer should contain \"25,30\" and return 2.\n\nNote: You must modify the `results` buffer in-place and should not use any dynamic memory allocation.", "chosen": "```cpp\n#include <cstring>\n#include <cstddef>\n\nstruct KeyValuePair {\n    char key[128];\n    std::string value;\n};\n\nint getCategoryValues(const KeyValuePair* pairs, size_t numPairs, const char* category, char* results) {\n    size_t resultIndex = 0;\n    bool firstMatch = true;\n\n    for (size_t i = 0; i < numPairs; ++i) {\n        if (std::strcmp(pairs[i].key, category) == 0) {\n\n            if (!firstMatch) {\n                if (resultIndex + 1 < 1024) {\n                    results[resultIndex++] = ',';\n                } else {\n                    break;\n                }\n            }\n            firstMatch = false;\n\n\n            const char* value = pairs[i].value.c_str();\n            size_t valueLength = std::strlen(value);\n\n\n            if (resultIndex + valueLength < 1024) {\n<diff>                std::strncpy(&results[resultIndex], value, 1023 - resultIndex);</diff>\n                resultIndex += valueLength;\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    if (resultIndex < 1024) {\n        results[resultIndex] = '\\0';\n    } else {\n        results[1023] = '\\0';\n    }\n\n    return numPairs - firstMatch;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstddef>\n\nstruct KeyValuePair {\n    char key[128];\n    std::string value;\n};\n\nint getCategoryValues(const KeyValuePair* pairs, size_t numPairs, const char* category, char* results) {\n    size_t resultIndex = 0;\n    bool firstMatch = true;\n\n    for (size_t i = 0; i < numPairs; ++i) {\n        if (std::strcmp(pairs[i].key, category) == 0) {\n\n            if (!firstMatch) {\n                if (resultIndex + 1 < 1024) {\n                    results[resultIndex++] = ',';\n                } else {\n                    break;\n                }\n            }\n            firstMatch = false;\n\n\n            const char* value = pairs[i].value.c_str();\n            size_t valueLength = std::strlen(value);\n\n\n            if (resultIndex + valueLength < 1024) {\n<diff>                std::strcpy(&results[resultIndex], value);</diff>\n                resultIndex += valueLength;\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    if (resultIndex < 1024) {\n        results[resultIndex] = '\\0';\n    } else {\n        results[1023] = '\\0';\n    }\n\n    return numPairs - firstMatch;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `bool isPerfectNumber(int n)` that determines if a positive integer `n` is a perfect number (equal to the sum of its proper divisors). For performance reasons, you must first store all proper divisors in a character buffer before calculating their sum. The function should return true if n is a perfect number, false otherwise.\n\nNote: Proper divisors of n are all positive divisors of n excluding n itself. For example, proper divisors of 6 are 1, 2, and 3.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sstream>\n\nbool isPerfectNumber(int n) {\n    if (n <= 1) return false;\n\n    char buffer[100];\n    int bufferSize = 0;\n\n\n    for (int i = 1; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            std::ostringstream oss;\n            oss << i;\n            std::string divisorStr = oss.str();\n            if (bufferSize + divisorStr.size() + 1 > sizeof(buffer)) {\n\n                return false;\n            }\n<diff>            std::strncpy(buffer + bufferSize, divisorStr.c_str(), sizeof(buffer) - bufferSize);\n            bufferSize += divisorStr.size();\n            if (bufferSize < sizeof(buffer)) {\n                buffer[bufferSize++] = ',';\n            }</diff>\n        }\n    }\n\n    if (bufferSize > 0) {\n        buffer[bufferSize - 1] = '\\0';\n    } else {\n        return false;\n    }\n\n\n    int sum = 0;\n    char* token = std::strtok(buffer, \",\");\n    while (token != nullptr) {\n        sum += std::stoi(token);\n        token = std::strtok(nullptr, \",\");\n    }\n\n    return sum == n;\n}\n\nint main() {\n    int testNumber = 28;\n    if (isPerfectNumber(testNumber)) {\n        std::cout << testNumber << \" is a perfect number.\" << std::endl;\n    } else {\n        std::cout << testNumber << \" is not a perfect number.\" << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sstream>\n\nbool isPerfectNumber(int n) {\n    if (n <= 1) return false;\n\n    char buffer[100];\n    int bufferSize = 0;\n\n\n    for (int i = 1; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            std::ostringstream oss;\n            oss << i;\n            std::string divisorStr = oss.str();\n            if (bufferSize + divisorStr.size() + 1 > sizeof(buffer)) {\n\n                return false;\n            }\n<diff>            std::strcpy(buffer + bufferSize, divisorStr.c_str());\n            bufferSize += divisorStr.size();\n            buffer[bufferSize++] = ',';</diff>\n        }\n    }\n\n    if (bufferSize > 0) {\n        buffer[bufferSize - 1] = '\\0';\n    } else {\n        return false;\n    }\n\n\n    int sum = 0;\n    char* token = std::strtok(buffer, \",\");\n    while (token != nullptr) {\n        sum += std::stoi(token);\n        token = std::strtok(nullptr, \",\");\n    }\n\n    return sum == n;\n}\n\nint main() {\n    int testNumber = 28;\n    if (isPerfectNumber(testNumber)) {\n        std::cout << testNumber << \" is a perfect number.\" << std::endl;\n    } else {\n        std::cout << testNumber << \" is not a perfect number.\" << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `convert_time_frames` that takes an array of time frame pairs and converts them to a specific format. Each time frame is represented as a pair of fixed-size character buffers (6 bytes each for \"HH:MM\\0\"). The function should modify the input array in-place to contain the merged time frames and return the final count of time frames.\n\nRequirements:\n1. For efficiency, all time comparisons must be done by first converting the time strings to integer minutes since midnight (0-1439) using a helper function you must implement\n2. The merging logic should follow these rules:\n   - If the start time of one frame is strictly greater than the end time of another, they are disjoint\n   - If the end time of one frame is >= start time of another, they should be merged\n   - Merged frames should use the earliest start and latest end times\n3. All time string manipulations must be done in-place in the original character buffers\n4. The output should be stored in the original array, with the first N elements being the merged frames\n5. You must implement and use the following helper function:\n   `int time_to_minutes(const char* time_str)` that converts \"HH:MM\" to minutes\n\nNote: For performance reasons, you should not use any C++ string classes - work directly with the character buffers provided.", "chosen": "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nint time_to_minutes(const char* time_str) {\n    int hours = (time_str[0] - '0') * 10 + (time_str[1] - '0');\n    int minutes = (time_str[3] - '0') * 10 + (time_str[4] - '0');\n    return hours * 60 + minutes;\n}\n\n\nint compare_frames(const void* a, const void* b) {\n    const char* start_a = ((const char**)a)[0];\n    const char* start_b = ((const char**)b)[0];\n\n    int minutes_a = time_to_minutes(start_a);\n    int minutes_b = time_to_minutes(start_b);\n\n    return minutes_a - minutes_b;\n}\n\n\nint convert_time_frames(char (*frames)[12], int num_frames) {\n    if (num_frames == 0) return 0;\n\n\n    qsort(frames, num_frames, sizeof(frames[0]), compare_frames);\n\n    int merged_count = 0;\n\n    for (int i = 0; i < num_frames; ++i) {\n        if (merged_count == 0 || time_to_minutes(frames[merged_count - 1] + 6) < time_to_minutes(frames[i])) {\n\n<diff>            strncpy(frames[merged_count][6], frames[i] + 6, 5);\n            frames[merged_count][11] = '\\0';\n            strncpy(frames[merged_count], frames[i], 11);\n            frames[merged_count][11] = '\\0';\n            merged_count++;\n        } else {\n\n            if (time_to_minutes(frames[merged_count - 1] + 6) < time_to_minutes(frames[i] + 6)) {\n                strncpy(frames[merged_count - 1] + 6, frames[i] + 6, 5);\n                frames[merged_count - 1][11] = '\\0';</diff>\n            }\n        }\n    }\n\n    return merged_count;\n}\n```", "rejected": "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nint time_to_minutes(const char* time_str) {\n    int hours = (time_str[0] - '0') * 10 + (time_str[1] - '0');\n    int minutes = (time_str[3] - '0') * 10 + (time_str[4] - '0');\n    return hours * 60 + minutes;\n}\n\n\nint compare_frames(const void* a, const void* b) {\n    const char* start_a = ((const char**)a)[0];\n    const char* start_b = ((const char**)b)[0];\n\n    int minutes_a = time_to_minutes(start_a);\n    int minutes_b = time_to_minutes(start_b);\n\n    return minutes_a - minutes_b;\n}\n\n\nint convert_time_frames(char (*frames)[12], int num_frames) {\n    if (num_frames == 0) return 0;\n\n\n    qsort(frames, num_frames, sizeof(frames[0]), compare_frames);\n\n    int merged_count = 0;\n\n    for (int i = 0; i < num_frames; ++i) {\n        if (merged_count == 0 || time_to_minutes(frames[merged_count - 1] + 6) < time_to_minutes(frames[i])) {\n\n<diff>            strcpy(frames[merged_count][6], frames[i] + 6);\n            strcpy(frames[merged_count], frames[i]);\n            merged_count++;\n        } else {\n\n            if (time_to_minutes(frames[merged_count - 1] + 6) < time_to_minutes(frames[i] + 6)) {\n                strcpy(frames[merged_count - 1] + 6, frames[i] + 6);</diff>\n            }\n        }\n    }\n\n    return merged_count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of Person objects and returns a map containing the count of people for each age. Each Person object has a name (null-terminated C-string) and an age (integer). For efficiency, your implementation should:\n1. Use a fixed-size character buffer of 256 bytes when processing names\n2. Store all names in a single pre-allocated buffer before counting ages\n3. Return the age counts in a std::map<int, int>\n\nUse the following structure definition:\nstruct Person {\n    const char* name;\n    int age;\n};\n\nTest your function with the following code:\nPerson people[] = {\n    {\"Alice\", 25},\n    {\"Bob\", 30},\n    {\"Charlie\", 25},\n    {\"Dave\", 35},\n    {\"Eve\", 25}\n};\n\nauto result = countPeopleByAge(people, 5);\nfor (const auto& [age, count] : result) {\n    std::cout << age << \": \" << count << std::endl;\n}\n// Expected output:\n// 25: 3\n// 30: 1\n// 35: 1", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n\nstruct Person {\n    const char* name;\n    int age;\n};\n\nstd::map<int, int> countPeopleByAge(const Person* people, size_t numPeople) {\n\n\n    const size_t bufferSize = 256 * numPeople;\n    char* buffer = new char[bufferSize];\n\n\n    char* bufferPtr = buffer;\n\n\n    std::map<int, int> ageCounts;\n\n\n    for (size_t i = 0; i < numPeople; ++i) {\n\n<diff>        std::strncpy(bufferPtr, people[i].name, 255);\n        bufferPtr[255] = '\\0';</diff>\n\n\n        bufferPtr += std::strlen(bufferPtr) + 1;\n\n\n        ++ageCounts[people[i].age];\n    }\n\n\n    delete[] buffer;\n\n    return ageCounts;\n}\n\nint main() {\n    Person people[] = {\n        {\"Alice\", 25},\n        {\"Bob\", 30},\n        {\"Charlie\", 25},\n        {\"Dave\", 35},\n        {\"Eve\", 25}\n    };\n\n    auto result = countPeopleByAge(people, 5);\n    for (const auto& [age, count] : result) {\n        std::cout << age << \": \" << count << std::endl;\n    }\n\n\n\n\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n\nstruct Person {\n    const char* name;\n    int age;\n};\n\nstd::map<int, int> countPeopleByAge(const Person* people, size_t numPeople) {\n\n\n    const size_t bufferSize = 256 * numPeople;\n    char* buffer = new char[bufferSize];\n\n\n    char* bufferPtr = buffer;\n\n\n    std::map<int, int> ageCounts;\n\n\n    for (size_t i = 0; i < numPeople; ++i) {\n\n<diff>        std::strcpy(bufferPtr, people[i].name);</diff>\n\n\n        bufferPtr += std::strlen(bufferPtr) + 1;\n\n\n        ++ageCounts[people[i].age];\n    }\n\n\n    delete[] buffer;\n\n    return ageCounts;\n}\n\nint main() {\n    Person people[] = {\n        {\"Alice\", 25},\n        {\"Bob\", 30},\n        {\"Charlie\", 25},\n        {\"Dave\", 35},\n        {\"Eve\", 25}\n    };\n\n    auto result = countPeopleByAge(people, 5);\n    for (const auto& [age, count] : result) {\n        std::cout << age << \": \" << count << std::endl;\n    }\n\n\n\n\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that generates C header and source files (.h and .cpp) from a list of function signatures provided as command-line arguments. For each function signature, the header file should contain a function prototype declaration, and the source file should implement a stub function. \n\nEach function signature will be provided in the format: \"return_type function_name(param1_type,param2_type,...)\". Your program should:\n1. Parse each signature into its components\n2. Generate appropriate C++ type declarations\n3. Write the declarations to a fixed-size header buffer before saving to file\n4. Write the function implementations to a fixed-size source buffer before saving to file\n\nUse simple string operations to build the output content. The output filenames should be derived from the first function name provided, truncated to 8 characters if necessary. Ensure all generated content fits within the fixed buffers which are exactly 2048 bytes each for header and source files.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nstruct FunctionInfo {\n    std::string returnType;\n    std::string functionName;\n    std::vector<std::pair<std::string, std::string>> params;\n};\n\n\nFunctionInfo parseFunctionSignature(const std::string& signature) {\n    FunctionInfo info;\n    size_t start = 0, end = signature.find(' ');\n    info.returnType = signature.substr(start, end);\n\n    start = end + 1;\n    end = signature.find('(', start);\n    info.functionName = signature.substr(start, end - start);\n\n    start = end + 1;\n    end = signature.rfind(')');\n    std::string paramStr = signature.substr(start, end - start);\n\n    std::stringstream ss(paramStr);\n    std::string item;\n    while (std::getline(ss, item, ',')) {\n        size_t spacePos = item.find_last_not_of(' ');\n        spacePos = item.find(' ', spacePos);\n        std::string type = item.substr(0, spacePos);\n        std::string name = item.substr(spacePos + 1);\n        info.params.push_back({type, name});\n    }\n\n    return info;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <function_signature1> [function_signature2 ...]\" << std::endl;\n        return 1;\n    }\n\n    const size_t MAX_BUFFER_SIZE = 2048;\n    char headerBuffer[MAX_BUFFER_SIZE] = {0};\n    char sourceBuffer[MAX_BUFFER_SIZE] = {0};\n    size_t headerPos = 0;\n    size_t sourcePos = 0;\n\n    std::string firstFunctionName;\n    for (int i = 1; i < argc; ++i) {\n        FunctionInfo info = parseFunctionSignature(argv[i]);\n\n        if (firstFunctionName.empty()) {\n            firstFunctionName = info.functionName;\n            if (firstFunctionName.size() > 8) {\n                firstFunctionName.resize(8);\n            }\n        }\n\n\n        std::ostringstream headerStream;\n        headerStream << info.returnType << \" \" << info.functionName << \"(\";\n        for (size_t j = 0; j < info.params.size(); ++j) {\n            if (j > 0) headerStream << \", \";\n            headerStream << info.params[j].first << \" \" << info.params[j].second;\n        }\n        headerStream << \");\\n\";\n\n\n        std::ostringstream sourceStream;\n        sourceStream << info.returnType << \" \" << info.functionName << \"(\";\n        for (size_t j = 0; j < info.params.size(); ++j) {\n            if (j > 0) sourceStream << \", \";\n            sourceStream << info.params[j].first << \" \" << info.params[j].second;\n        }\n        sourceStream << \") {\\n\";\n        sourceStream << \"\n        sourceStream << \"}\\n\\n\";\n\n\n        std::string headerContent = headerStream.str();\n        std::string sourceContent = sourceStream.str();\n\n        if (headerPos + headerContent.size() >= MAX_BUFFER_SIZE ||\n            sourcePos + sourceContent.size() >= MAX_BUFFER_SIZE) {\n            std::cerr << \"Error: Buffer size exceeded!\" << std::endl;\n            return 1;\n        }\n\n<diff>        std::strncpy(headerBuffer + headerPos, headerContent.c_str(), MAX_BUFFER_SIZE - headerPos - 1);\n        headerPos += headerContent.size();\n\n        std::strncpy(sourceBuffer + sourcePos, sourceContent.c_str(), MAX_BUFFER_SIZE - sourcePos - 1);</diff>\n        sourcePos += sourceContent.size();\n    }\n\n\n    std::ofstream headerFile(firstFunctionName + \".h\");\n    std::ofstream sourceFile(firstFunctionName + \".cpp\");\n\n    if (!headerFile || !sourceFile) {\n        std::cerr << \"Error opening files for writing!\" << std::endl;\n        return 1;\n    }\n\n    headerFile.write(headerBuffer, headerPos);\n    sourceFile.write(sourceBuffer, sourcePos);\n\n    headerFile.close();\n    sourceFile.close();\n\n    std::cout << \"Header file: \" << firstFunctionName << \".h\" << std::endl;\n    std::cout << \"Source file: \" << firstFunctionName << \".cpp\" << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nstruct FunctionInfo {\n    std::string returnType;\n    std::string functionName;\n    std::vector<std::pair<std::string, std::string>> params;\n};\n\n\nFunctionInfo parseFunctionSignature(const std::string& signature) {\n    FunctionInfo info;\n    size_t start = 0, end = signature.find(' ');\n    info.returnType = signature.substr(start, end);\n\n    start = end + 1;\n    end = signature.find('(', start);\n    info.functionName = signature.substr(start, end - start);\n\n    start = end + 1;\n    end = signature.rfind(')');\n    std::string paramStr = signature.substr(start, end - start);\n\n    std::stringstream ss(paramStr);\n    std::string item;\n    while (std::getline(ss, item, ',')) {\n        size_t spacePos = item.find_last_not_of(' ');\n        spacePos = item.find(' ', spacePos);\n        std::string type = item.substr(0, spacePos);\n        std::string name = item.substr(spacePos + 1);\n        info.params.push_back({type, name});\n    }\n\n    return info;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <function_signature1> [function_signature2 ...]\" << std::endl;\n        return 1;\n    }\n\n    const size_t MAX_BUFFER_SIZE = 2048;\n    char headerBuffer[MAX_BUFFER_SIZE] = {0};\n    char sourceBuffer[MAX_BUFFER_SIZE] = {0};\n    size_t headerPos = 0;\n    size_t sourcePos = 0;\n\n    std::string firstFunctionName;\n    for (int i = 1; i < argc; ++i) {\n        FunctionInfo info = parseFunctionSignature(argv[i]);\n\n        if (firstFunctionName.empty()) {\n            firstFunctionName = info.functionName;\n            if (firstFunctionName.size() > 8) {\n                firstFunctionName.resize(8);\n            }\n        }\n\n\n        std::ostringstream headerStream;\n        headerStream << info.returnType << \" \" << info.functionName << \"(\";\n        for (size_t j = 0; j < info.params.size(); ++j) {\n            if (j > 0) headerStream << \", \";\n            headerStream << info.params[j].first << \" \" << info.params[j].second;\n        }\n        headerStream << \");\\n\";\n\n\n        std::ostringstream sourceStream;\n        sourceStream << info.returnType << \" \" << info.functionName << \"(\";\n        for (size_t j = 0; j < info.params.size(); ++j) {\n            if (j > 0) sourceStream << \", \";\n            sourceStream << info.params[j].first << \" \" << info.params[j].second;\n        }\n        sourceStream << \") {\\n\";\n        sourceStream << \"\n        sourceStream << \"}\\n\\n\";\n\n\n        std::string headerContent = headerStream.str();\n        std::string sourceContent = sourceStream.str();\n\n        if (headerPos + headerContent.size() >= MAX_BUFFER_SIZE ||\n            sourcePos + sourceContent.size() >= MAX_BUFFER_SIZE) {\n            std::cerr << \"Error: Buffer size exceeded!\" << std::endl;\n            return 1;\n        }\n\n<diff>        std::strcpy(headerBuffer + headerPos, headerContent.c_str());\n        headerPos += headerContent.size();\n\n        std::strcpy(sourceBuffer + sourcePos, sourceContent.c_str());</diff>\n        sourcePos += sourceContent.size();\n    }\n\n\n    std::ofstream headerFile(firstFunctionName + \".h\");\n    std::ofstream sourceFile(firstFunctionName + \".cpp\");\n\n    if (!headerFile || !sourceFile) {\n        std::cerr << \"Error opening files for writing!\" << std::endl;\n        return 1;\n    }\n\n    headerFile.write(headerBuffer, headerPos);\n    sourceFile.write(sourceBuffer, sourcePos);\n\n    headerFile.close();\n    sourceFile.close();\n\n    std::cout << \"Header file: \" << firstFunctionName << \".h\" << std::endl;\n    std::cout << \"Source file: \" << firstFunctionName << \".cpp\" << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of string parameters. The function should create a new array containing all parameters except the first two. The output array must be constructed by copying elements from the input array starting from index 2. Assume the input array is null-terminated and the output array should also be null-terminated. The function should return the new array.\n\nFor example, given parameters = {\"arg1\", \"arg2\", \"arg3\", \"arg4\", nullptr}, the function should return an array containing {\"arg3\", \"arg4\", nullptr}.", "chosen": "```cpp\n#include <cstring>\n#include <cstdlib>\n\nchar** processParameters(char* const* parameters) {\n    if (parameters == nullptr || parameters[0] == nullptr || parameters[1] == nullptr) {\n\n        char** result = (char**)std::malloc(sizeof(char*));\n        result[0] = nullptr;\n        return result;\n    }\n\n\n    int length = 0;\n    while (parameters[length] != nullptr) {\n        ++length;\n    }\n\n\n    if (length < 3) {\n        char** result = (char**)std::malloc(sizeof(char*));\n        result[0] = nullptr;\n        return result;\n    }\n\n\n    char** result = (char**)std::malloc((length - 1) * sizeof(char*));\n\n\n    for (int i = 2; i < length; ++i) {\n<diff>        result[i - 2] = (char*)std::malloc(strlen(parameters[i]) + 1);\n        std::strncpy(result[i - 2], parameters[i], strlen(parameters[i]) + 1);</diff>\n    }\n\n\n    result[length - 2] = nullptr;\n\n    return result;\n}\n\nvoid freeParametersArray(char** parameters) {\n    if (parameters == nullptr) return;\n    int i = 0;\n    while (parameters[i] != nullptr) {\n        std::free(parameters[i]);\n        ++i;\n    }\n    std::free(parameters);\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdlib>\n\nchar** processParameters(char* const* parameters) {\n    if (parameters == nullptr || parameters[0] == nullptr || parameters[1] == nullptr) {\n\n        char** result = (char**)std::malloc(sizeof(char*));\n        result[0] = nullptr;\n        return result;\n    }\n\n\n    int length = 0;\n    while (parameters[length] != nullptr) {\n        ++length;\n    }\n\n\n    if (length < 3) {\n        char** result = (char**)std::malloc(sizeof(char*));\n        result[0] = nullptr;\n        return result;\n    }\n\n\n    char** result = (char**)std::malloc((length - 1) * sizeof(char*));\n\n\n    for (int i = 2; i < length; ++i) {\n<diff>        result[i - 2] = std::strcpy((char*)std::malloc(strlen(parameters[i]) + 1), parameters[i]);</diff>\n    }\n\n\n    result[length - 2] = nullptr;\n\n    return result;\n}\n\nvoid freeParametersArray(char** parameters) {\n    if (parameters == nullptr) return;\n    int i = 0;\n    while (parameters[i] != nullptr) {\n        std::free(parameters[i]);\n        ++i;\n    }\n    std::free(parameters);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `randomIntFloat` that takes a parameter `n` which can be either an integer or floating-point number, and stores the result in a provided character buffer. The function should:\n1. If `n` is an integer, generate a random integer from 0 to `n-1` (inclusive) and store it in the buffer as a string\n2. If `n` is a float, generate a random float from 0.0 to `n-0.0001` (inclusive) and store it in the buffer as a string\n3. If `n` is any other type, store \"None\" in the buffer\n4. The function should accept the buffer and its size as parameters\n5. The buffer must be exactly large enough to hold the longest possible result (assume 50 characters is sufficient)\n6. Use the C++ random library for number generation\n\nNote: The function should not perform any bounds checking on the buffer size, as the caller is responsible for ensuring the buffer is large enough.", "chosen": "```cpp\n#include <random>\n#include <sstream>\n#include <type_traits>\n#include <cstring>\n\nvoid randomIntFloat(int n, char* buffer, size_t bufferSize) {\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<int> dist(0, n - 1);\n    int randomInt = dist(rng);\n\n    snprintf(buffer, bufferSize, \"%d\", randomInt);\n}\n\nvoid randomIntFloat(float n, char* buffer, size_t bufferSize) {\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_real_distribution<float> dist(0.0f, n - 0.0001f);\n    float randomFloat = dist(rng);\n\n    snprintf(buffer, bufferSize, \"%.4f\", randomFloat);\n}\n\ntemplate<typename T>\nvoid randomIntFloat(T n, char* buffer, size_t bufferSize) {\n<diff>    if (bufferSize > 0) {\n        buffer[0] = '\\0';\n    }</diff>\n}\n\n\ntemplate<typename T>\nvoid randomIntFloatHelper(T n, char* buffer, size_t bufferSize) {\n    randomIntFloat(n, buffer, bufferSize);\n}\n\nvoid randomIntFloat(double n, char* buffer, size_t bufferSize) {\n    randomIntFloat(static_cast<float>(n), buffer, bufferSize);\n}\n\nvoid randomIntFloat(long double n, char* buffer, size_t bufferSize) {\n    randomIntFloat(static_cast<float>(n), buffer, bufferSize);\n}\n```", "rejected": "```cpp\n#include <random>\n#include <sstream>\n#include <type_traits>\n#include <cstring>\n\nvoid randomIntFloat(int n, char* buffer, size_t bufferSize) {\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<int> dist(0, n - 1);\n    int randomInt = dist(rng);\n\n    snprintf(buffer, bufferSize, \"%d\", randomInt);\n}\n\nvoid randomIntFloat(float n, char* buffer, size_t bufferSize) {\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_real_distribution<float> dist(0.0f, n - 0.0001f);\n    float randomFloat = dist(rng);\n\n    snprintf(buffer, bufferSize, \"%.4f\", randomFloat);\n}\n\ntemplate<typename T>\nvoid randomIntFloat(T n, char* buffer, size_t bufferSize) {\n<diff>    std::strcpy(buffer, \"None\");</diff>\n}\n\n\ntemplate<typename T>\nvoid randomIntFloatHelper(T n, char* buffer, size_t bufferSize) {\n    randomIntFloat(n, buffer, bufferSize);\n}\n\nvoid randomIntFloat(double n, char* buffer, size_t bufferSize) {\n    randomIntFloat(static_cast<float>(n), buffer, bufferSize);\n}\n\nvoid randomIntFloat(long double n, char* buffer, size_t bufferSize) {\n    randomIntFloat(static_cast<float>(n), buffer, bufferSize);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `bool isPowerOfFour(int n, char* output)` that checks if a positive integer `n` is a power of 4 and also generates a string of all powers of 4 up to `n` in the provided output buffer.\n\nThe function should:\n1. Return `true` if `n` is a power of 4, `false` otherwise\n2. Store in the output buffer a comma-separated string of all powers of 4 less than or equal to `n` (e.g., for n=64, output should be \"1,4,16,64\")\n3. Support `n` up to 2^31 - 1\n\nYou must use the provided output buffer directly for building the string. Assume the buffer is large enough to hold the result, but you must handle the string construction carefully to avoid overflow.\n\nExample:\nFor n=64, the function should return true and set output to \"1,4,16,64\"\nFor n=63, the function should return false and set output to \"1,4,16\"", "chosen": "```cpp\n#include <cstdio>\n<diff>#include <cstring>\n\nbool isPowerOfFour(int n, char* output) {\n\n    bool isPower4 = (n > 0) && ((n & (n - 1)) == 0) && (n & 0x55555555);\n\n\n    char numStr[12];\n\n\n    *output = '\\0';\n\n\n    for (int i = 1; i <= n; i *= 4) {\n\n        std::sprintf(numStr, \"%d\", i);\n        if (*output != '\\0') {\n            std::strncat(output, \",\", 1);\n        }\n        std::strncat(output, numStr, sizeof(numStr) - 1);</diff>\n    }\n\n    return isPower4;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n<diff>\nbool isPowerOfFour(int n, char* output) {\n\n    bool isPower4 = (n > 0) && ((n & (n - 1)) == 0) && (n & 0x55555555);\n\n\n    char numStr[12];\n\n\n    *output = '\\0';\n\n\n    for (int i = 1; i <= n; i *= 4) {\n\n        std::sprintf(numStr, \"%d\", i);\n        if (*output != '\\0') {\n            std::strcat(output, \",\");\n        }\n        std::strcat(output, numStr);</diff>\n    }\n\n    return isPower4;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that parses a date string in the format \"DD/MM/YYYY\" into a tuple of integers (day, month, year). For efficiency, use a fixed-size character buffer of 16 bytes to store intermediate values during parsing. The function should take the date string as input and return the parsed values as a tuple.\n\nYour code should pass the following assertions:\nassert(parseDateString(\"10/12/2021\") == std::make_tuple(10, 12, 2021));\nassert(parseDateString(\"03/05/2022\") == std::make_tuple(3, 5, 2022));\nassert(parseDateString(\"01/01/2023\") == std::make_tuple(1, 1, 2023));", "chosen": "```cpp\n#include <string>\n#include <tuple>\n#include <cstring>\n#include <cstdlib>\n\nstd::tuple<int, int, int> parseDateString(const std::string& dateString) {\n\n    if (dateString.length() != 10) {\n        throw std::invalid_argument(\"Date string must be in the format DD/MM/YYYY\");\n    }\n\n<diff>    char buffer[11];\n    std::strncpy(buffer, dateString.c_str(), sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n\n    char* token = std::strtok(buffer, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse day from date string\");\n    }\n    int day = std::stoi(token);\n\n    token = std::strtok(nullptr, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse month from date string\");\n    }\n    int month = std::stoi(token);\n\n    token = std::strtok(nullptr, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse year from date string\");\n    }\n    int year = std::stoi(token);\n\n    return std::make_tuple(day, month, year);\n}\n\n\n#include <cassert>\nint main() {\n    assert(parseDateString(\"10/12/2021\") == std::make_tuple(10, 12, 2021));\n    assert(parseDateString(\"03/05/2022\") == std::make_tuple(3, 5, 2022));\n    assert(parseDateString(\"01/01/2023\") == std::make_tuple(1, 1, 2023));\n    return 0;\n}\n```", "rejected": "```cpp\n#include <string>\n#include <tuple>\n#include <cstring>\n#include <cstdlib>\n\nstd::tuple<int, int, int> parseDateString(const std::string& dateString) {\n\n    if (dateString.length() != 10) {\n        throw std::invalid_argument(\"Date string must be in the format DD/MM/YYYY\");\n    }\n\n<diff>    char buffer[16];\n    std::strcpy(buffer, dateString.c_str());</diff>\n\n\n    char* token = std::strtok(buffer, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse day from date string\");\n    }\n    int day = std::stoi(token);\n\n    token = std::strtok(nullptr, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse month from date string\");\n    }\n    int month = std::stoi(token);\n\n    token = std::strtok(nullptr, \"/\");\n    if (!token) {\n        throw std::runtime_error(\"Failed to parse year from date string\");\n    }\n    int year = std::stoi(token);\n\n    return std::make_tuple(day, month, year);\n}\n\n\n#include <cassert>\nint main() {\n    assert(parseDateString(\"10/12/2021\") == std::make_tuple(10, 12, 2021));\n    assert(parseDateString(\"03/05/2022\") == std::make_tuple(3, 5, 2022));\n    assert(parseDateString(\"01/01/2023\") == std::make_tuple(1, 1, 2023));\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that tests whether a function's metadata (name and address) is preserved after being wrapped. The function should take a function pointer and two fixed-size character buffers (64 bytes each) to store the original function's name and address as strings. The function should return:\n- true if the metadata matches before and after wrapping\n- false if the metadata doesn't match\n- a null pointer if the function has no metadata\n\nFor efficiency, you must first store the original function's name in the first buffer and its address (converted to string) in the second buffer before performing the comparison with the wrapped function's metadata.", "chosen": "```cpp\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstring>\n\n\ntemplate<typename Func>\nvoid wrapFunction(Func func, void* wrappedFunc) {\n\n    func();\n}\n\n\nbool testFunctionMetadata(void (*func)(), char nameBuffer[64], char addressBuffer[64]) {\n\n<diff>    std::strncpy(nameBuffer, \"originalFunctionName\", sizeof(nameBuffer) - 1);\n    nameBuffer[sizeof(nameBuffer) - 1] = '\\0';\n\n\n    std::ostringstream oss;\n    oss << std::hex << std::setw(16) << std::setfill('0') << reinterpret_cast<uintptr_t>(func);\n    std::strncpy(addressBuffer, oss.str().c_str(), sizeof(addressBuffer) - 1);\n    addressBuffer[sizeof(addressBuffer) - 1] = '\\0';</diff>\n\n\n    wrapFunction(func, reinterpret_cast<void*>(func));\n\n\n    uintptr_t wrappedFuncAddress = reinterpret_cast<uintptr_t>(func);\n\n\n    std::ostringstream ossWrapped;\n    ossWrapped << std::hex << std::setw(16) << std::setfill('0') << wrappedFuncAddress;\n    std::string wrappedAddressStr = ossWrapped.str();\n\n\n    if (std::strcmp(addressBuffer, wrappedAddressStr.c_str()) != 0) {\n        return false;\n    }\n\n\n    return true;\n}\n\n\nvoid originalFunction() {\n\n}\n\nint main() {\n    char nameBuffer[64];\n    char addressBuffer[64];\n\n    bool result = testFunctionMetadata(originalFunction, nameBuffer, addressBuffer);\n    if (result) {\n        std::cout << \"Metadata matches.\" << std::endl;\n    } else {\n        std::cout << \"Metadata does not match.\" << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstring>\n\n\ntemplate<typename Func>\nvoid wrapFunction(Func func, void* wrappedFunc) {\n\n    func();\n}\n\n\nbool testFunctionMetadata(void (*func)(), char nameBuffer[64], char addressBuffer[64]) {\n\n<diff>    std::strcpy(nameBuffer, \"originalFunctionName\");\n\n\n    std::ostringstream oss;\n    oss << std::hex << std::setw(16) << std::setfill('0') << reinterpret_cast<uintptr_t>(func);\n    std::strcpy(addressBuffer, oss.str().c_str());</diff>\n\n\n    wrapFunction(func, reinterpret_cast<void*>(func));\n\n\n    uintptr_t wrappedFuncAddress = reinterpret_cast<uintptr_t>(func);\n\n\n    std::ostringstream ossWrapped;\n    ossWrapped << std::hex << std::setw(16) << std::setfill('0') << wrappedFuncAddress;\n    std::string wrappedAddressStr = ossWrapped.str();\n\n\n    if (std::strcmp(addressBuffer, wrappedAddressStr.c_str()) != 0) {\n        return false;\n    }\n\n\n    return true;\n}\n\n\nvoid originalFunction() {\n\n}\n\nint main() {\n    char nameBuffer[64];\n    char addressBuffer[64];\n\n    bool result = testFunctionMetadata(originalFunction, nameBuffer, addressBuffer);\n    if (result) {\n        std::cout << \"Metadata matches.\" << std::endl;\n    } else {\n        std::cout << \"Metadata does not match.\" << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `createMapFromArrays` that takes two arrays of strings and integers respectively, and their sizes, then stores the resulting key-value pairs in a pre-allocated character buffer of exactly 512 bytes. The function should create the map by formatting each key-value pair as \"key:value\" and placing them consecutively in the buffer, separated by commas. For arrays of unequal length, use the smaller size. The function should return the number of pairs successfully written to the buffer. Assume all string keys will fit within the remaining buffer space when written.\n\nYour code should pass the following test case:\n\nconst char* keys[] = {\"a\", \"b\", \"c\"};\nint values[] = {1, 2, 3};\nchar buffer[512];\nint count = createMapFromArrays(keys, values, 3, 3, buffer);\n\n// buffer should contain \"a:1,b:2,c:3\"\n// count should be 3", "chosen": "```cpp\n#include <cstring>\n\nint createMapFromArrays(const char** keys, const int* values, size_t keysSize, size_t valuesSize, char* buffer) {\n    size_t minSize = keysSize < valuesSize ? keysSize : valuesSize;\n    size_t bufferSize = 512;\n    size_t bufferPos = 0;\n\n    for (size_t i = 0; i < minSize; ++i) {\n\n        char tempBuffer[64];\n        snprintf(tempBuffer, sizeof(tempBuffer), \"%s:%d\", keys[i], values[i]);\n\n\n        if (bufferPos + strlen(tempBuffer) + (i > 0 ? 1 : 0) >= bufferSize) {\n            break;\n        }\n\n\n        if (i > 0) {\n            buffer[bufferPos++] = ',';\n        }\n\n\n<diff>        strncpy(buffer + bufferPos, tempBuffer, bufferSize - bufferPos - 1);</diff>\n        bufferPos += strlen(tempBuffer);\n    }\n\n\n    buffer[bufferPos] = '\\0';\n\n    return bufferPos > 0 ? (int)strtok(buffer, \",\")->n : 0;\n}\n\n\nint countPairs(const char* buffer) {\n    if (*buffer == '\\0') return 0;\n    int count = 1;\n    for (const char* ptr = buffer; *ptr != '\\0'; ++ptr) {\n        if (*ptr == ',') {\n            ++count;\n        }\n    }\n    return count;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nint createMapFromArrays(const char** keys, const int* values, size_t keysSize, size_t valuesSize, char* buffer) {\n    size_t minSize = keysSize < valuesSize ? keysSize : valuesSize;\n    size_t bufferSize = 512;\n    size_t bufferPos = 0;\n\n    for (size_t i = 0; i < minSize; ++i) {\n\n        char tempBuffer[64];\n        snprintf(tempBuffer, sizeof(tempBuffer), \"%s:%d\", keys[i], values[i]);\n\n\n        if (bufferPos + strlen(tempBuffer) + (i > 0 ? 1 : 0) >= bufferSize) {\n            break;\n        }\n\n\n        if (i > 0) {\n            buffer[bufferPos++] = ',';\n        }\n\n\n<diff>        strcpy(buffer + bufferPos, tempBuffer);</diff>\n        bufferPos += strlen(tempBuffer);\n    }\n\n\n    buffer[bufferPos] = '\\0';\n\n    return bufferPos > 0 ? (int)strtok(buffer, \",\")->n : 0;\n}\n\n\nint countPairs(const char* buffer) {\n    if (*buffer == '\\0') return 0;\n    int count = 1;\n    for (const char* ptr = buffer; *ptr != '\\0'; ++ptr) {\n        if (*ptr == ',') {\n            ++count;\n        }\n    }\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `build_html_tag` that takes a vector of strings and returns a formatted HTML tag string. The function should use a fixed-size character buffer of 256 bytes to construct the output string. The function should take an optional parameter `tag` (defaulting to \"em\") to specify the HTML tag to use. The words from the input vector should be joined with spaces and wrapped in the specified HTML tags.\n\nYour code should pass the following assertions:\nassert(build_html_tag({\"Hello\", \"World\"}) == \"<em>Hello World</em>\");\nassert(build_html_tag({\"Hello\", \"World\"}, \"b\") == \"<b>Hello World</b>\");\nassert(build_html_tag({\"Hello\", \"World\"}, \"i\") == \"<i>Hello World</i>\");\n\nNote: For efficiency, the function must construct the output string in the fixed buffer by first writing the opening tag, then the joined words, and finally the closing tag.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstdarg>\n#include <cassert>\n\nstd::string build_html_tag(const std::vector<std::string>& words, const std::string& tag = \"em\") {\n    char buffer[256];\n    snprintf(buffer, sizeof(buffer), \"<%s>\", tag.c_str());\n\n    size_t pos = strlen(buffer);\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (pos + words[i].length() + 1 >= sizeof(buffer)) {\n            break;\n        }\n        if (i != 0) {\n            buffer[pos++] = ' ';\n        }\n<diff>        strncpy(buffer + pos, words[i].c_str(), sizeof(buffer) - pos - 1);</diff>\n        pos += words[i].length();\n    }\n\n    if (pos + tag.length() + 3 < sizeof(buffer)) {\n        snprintf(buffer + pos, sizeof(buffer) - pos, \"</%s>\", tag.c_str());\n    }\n\n    return std::string(buffer);\n}\n\nint main() {\n    assert(build_html_tag({\"Hello\", \"World\"}) == \"<em>Hello World</em>\");\n    assert(build_html_tag({\"Hello\", \"World\"}, \"b\") == \"<b>Hello World</b>\");\n    assert(build_html_tag({\"Hello\", \"World\"}, \"i\") == \"<i>Hello World</i>\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstdarg>\n#include <cassert>\n\nstd::string build_html_tag(const std::vector<std::string>& words, const std::string& tag = \"em\") {\n    char buffer[256];\n    snprintf(buffer, sizeof(buffer), \"<%s>\", tag.c_str());\n\n    size_t pos = strlen(buffer);\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (pos + words[i].length() + 1 >= sizeof(buffer)) {\n            break;\n        }\n        if (i != 0) {\n            buffer[pos++] = ' ';\n        }\n<diff>        strcpy(buffer + pos, words[i].c_str());</diff>\n        pos += words[i].length();\n    }\n\n    if (pos + tag.length() + 3 < sizeof(buffer)) {\n        snprintf(buffer + pos, sizeof(buffer) - pos, \"</%s>\", tag.c_str());\n    }\n\n    return std::string(buffer);\n}\n\nint main() {\n    assert(build_html_tag({\"Hello\", \"World\"}) == \"<em>Hello World</em>\");\n    assert(build_html_tag({\"Hello\", \"World\"}, \"b\") == \"<b>Hello World</b>\");\n    assert(build_html_tag({\"Hello\", \"World\"}, \"i\") == \"<i>Hello World</i>\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `parse_string_list` that extracts string elements from a JSON-like array format. The function should take a character array as input (e.g., `\"[\\\"abc\\\", \\\"def\\\", \\\"ghi\\\"]\"`) and modify it in-place to extract the strings, storing them in a provided output buffer. The output should be an array of C-style strings (null-terminated character arrays) written consecutively into the output buffer. Assume the input is always well-formed with only string elements, and the output buffer is large enough to hold all extracted strings. The function should return the number of strings extracted.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nsize_t parse_string_list(char* input, char* outputBuffer, size_t bufferSize) {\n    size_t count = 0;\n    char* currentOutputPos = outputBuffer;\n\n\n    char* ptr = input + 1;\n\n    while (*ptr != '\\0') {\n\n        if (*ptr == '\"') {\n            ptr++;\n            char* start = ptr;\n\n\n            while (*ptr != '\"') {\n                ptr++;\n            }\n\n\n            size_t length = ptr - start;\n\n\n            if (currentOutputPos + length + 1 <= outputBuffer + bufferSize) {\n<diff>                std::strncpy(currentOutputPos, start, length);\n                currentOutputPos[length] = '\\0';</diff>\n                currentOutputPos += length + 1;\n                count++;\n            } else {\n                break;\n            }\n\n\n            ptr++;\n\n\n            if (*ptr == ',') {\n                ptr++;\n            }\n        } else {\n            ptr++;\n        }\n    }\n\n    return count;\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\n\nsize_t parse_string_list(char* input, char* outputBuffer, size_t bufferSize) {\n    size_t count = 0;\n    char* currentOutputPos = outputBuffer;\n\n\n    char* ptr = input + 1;\n\n    while (*ptr != '\\0') {\n\n        if (*ptr == '\"') {\n            ptr++;\n            char* start = ptr;\n\n\n            while (*ptr != '\"') {\n                ptr++;\n            }\n\n\n            size_t length = ptr - start;\n\n\n            if (currentOutputPos + length + 1 <= outputBuffer + bufferSize) {\n<diff>                std::strcpy(currentOutputPos, start);</diff>\n                currentOutputPos += length + 1;\n                count++;\n            } else {\n                break;\n            }\n\n\n            ptr++;\n\n\n            if (*ptr == ',') {\n                ptr++;\n            }\n        } else {\n            ptr++;\n        }\n    }\n\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that accepts two strings representing non-negative integers (e.g., \"123\" and \"456\") and returns their sum as a string (e.g., \"579\"). For performance reasons, you must use fixed-size character buffers of 256 bytes for all intermediate string operations. The function should iterate through each character of both strings, convert them to integers, add corresponding digits, and build the result string in the fixed buffer before returning it. Ensure your implementation passes this test case:\n\nassert(addStrings(\"123\", \"456\") == \"579\");\n\nNote: The output string must exactly match the expected result with no extra characters.", "chosen": "```cpp\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\nstd::string addStrings(const std::string& num1, const std::string& num2) {\n    char buffer1[256];\n    char buffer2[256];\n    char resultBuffer[256];\n\n\n<diff>    std::strncpy(buffer1, num1.c_str(), sizeof(buffer1) - 1);\n    std::strncpy(buffer2, num2.c_str(), sizeof(buffer2) - 1);\n    buffer1[sizeof(buffer1) - 1] = '\\0';\n    buffer2[sizeof(buffer2) - 1] = '\\0';</diff>\n\n    std::reverse(buffer1, buffer1 + std::strlen(buffer1));\n    std::reverse(buffer2, buffer2 + std::strlen(buffer2));\n\n    int len1 = std::strlen(buffer1);\n    int len2 = std::strlen(buffer2);\n    int maxLen = std::max(len1, len2);\n    int carry = 0;\n\n\n    std::memset(resultBuffer, 0, sizeof(resultBuffer));\n\n\n    for (int i = 0; i < maxLen || carry; ++i) {\n        int digit1 = (i < len1) ? buffer1[i] - '0' : 0;\n        int digit2 = (i < len2) ? buffer2[i] - '0' : 0;\n        int sum = digit1 + digit2 + carry;\n        carry = sum / 10;\n        resultBuffer[i] = (sum % 10) + '0';\n    }\n\n\n    int resultLength = 0;\n    while (resultBuffer[resultLength] != '\\0') {\n        ++resultLength;\n    }\n\n\n    std::reverse(resultBuffer, resultBuffer + resultLength);\n\n\n    return std::string(resultBuffer);\n}\n\n\nint main() {\n    assert(addStrings(\"123\", \"456\") == \"579\");\n    assert(addStrings(\"999\", \"1\") == \"1000\");\n    assert(addStrings(\"0\", \"0\") == \"0\");\n    assert(addStrings(\"123456789\", \"987654321\") == \"1111111110\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\nstd::string addStrings(const std::string& num1, const std::string& num2) {\n    char buffer1[256];\n    char buffer2[256];\n    char resultBuffer[256];\n\n\n<diff>    std::strcpy(buffer1, num1.c_str());\n    std::strcpy(buffer2, num2.c_str());</diff>\n\n    std::reverse(buffer1, buffer1 + std::strlen(buffer1));\n    std::reverse(buffer2, buffer2 + std::strlen(buffer2));\n\n    int len1 = std::strlen(buffer1);\n    int len2 = std::strlen(buffer2);\n    int maxLen = std::max(len1, len2);\n    int carry = 0;\n\n\n    std::memset(resultBuffer, 0, sizeof(resultBuffer));\n\n\n    for (int i = 0; i < maxLen || carry; ++i) {\n        int digit1 = (i < len1) ? buffer1[i] - '0' : 0;\n        int digit2 = (i < len2) ? buffer2[i] - '0' : 0;\n        int sum = digit1 + digit2 + carry;\n        carry = sum / 10;\n        resultBuffer[i] = (sum % 10) + '0';\n    }\n\n\n    int resultLength = 0;\n    while (resultBuffer[resultLength] != '\\0') {\n        ++resultLength;\n    }\n\n\n    std::reverse(resultBuffer, resultBuffer + resultLength);\n\n\n    return std::string(resultBuffer);\n}\n\n\nint main() {\n    assert(addStrings(\"123\", \"456\") == \"579\");\n    assert(addStrings(\"999\", \"1\") == \"1000\");\n    assert(addStrings(\"0\", \"0\") == \"0\");\n    assert(addStrings(\"123456789\", \"987654321\") == \"1111111110\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void get_resource_id(const char* resource, char* output)` that processes a JSON-like string to extract an ID. The function should examine the input string which represents a simple dictionary in the format \"{key:value}\". If the dictionary contains a key named \"id\" with a string value (enclosed in quotes), copy just the ID value (without quotes) into the output buffer. The output buffer is guaranteed to be large enough for any valid ID but you must ensure you don't write beyond its bounds. If the input doesn't contain a valid ID string, copy the error message \"invalid resource format\" into the output buffer. You must implement the string parsing and copying manually without using any JSON parsing libraries.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid get_resource_id(const char* resource, char* output) {\n    const char* id_key = \"\\\"id\\\":\\\"\";\n    const char* start = std::strstr(resource, id_key);\n\n    if (start != nullptr) {\n\n        start += std::strlen(id_key);\n\n\n        const char* end = std::strchr(start, '\"');\n        if (end != nullptr) {\n\n            size_t length = end - start;\n\n\n            std::strncpy(output, start, length);\n            output[length] = '\\0';\n            return;\n        }\n    }\n\n\n<diff>    std::strncpy(output, \"invalid resource format\", sizeof(\"invalid resource format\") - 1);\n    output[sizeof(\"invalid resource format\") - 1] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid get_resource_id(const char* resource, char* output) {\n    const char* id_key = \"\\\"id\\\":\\\"\";\n    const char* start = std::strstr(resource, id_key);\n\n    if (start != nullptr) {\n\n        start += std::strlen(id_key);\n\n\n        const char* end = std::strchr(start, '\"');\n        if (end != nullptr) {\n\n            size_t length = end - start;\n\n\n            std::strncpy(output, start, length);\n            output[length] = '\\0';\n            return;\n        }\n    }\n\n\n<diff>    std::strcpy(output, \"invalid resource format\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that finds the mode (most frequent value) in an array of integers. The function should take an integer array and its size as input, and modify the original array to store the mode value in the first element. Additionally, print the result to a fixed-size character buffer of 50 bytes. In case of multiple modes with the same highest count, choose the largest value. For example, given [3, 4, 5, 4, 6, 4, 7], the function should modify the array to have 4 as its first element and print \"Mode: 4\" to the buffer.", "chosen": "```cpp\n#include <iostream>\n#include <unordered_map>\n<diff>#include <cstdio>\n\nvoid findAndSetMode(int* arr, size_t size, char* buffer) {\n    if (size == 0) {\n        arr[0] = 0;\n        std::snprintf(buffer, 50, \"Mode: None\");</diff>\n        return;\n    }\n\n    std::unordered_map<int, int> frequencyMap;\n    for (size_t i = 0; i < size; ++i) {\n        frequencyMap[arr[i]]++;\n    }\n\n    int mode = arr[0];\n    int maxCount = frequencyMap[arr[0]];\n\n    for (const auto& pair : frequencyMap) {\n        if (pair.second > maxCount || (pair.second == maxCount && pair.first > mode)) {\n            mode = pair.first;\n            maxCount = pair.second;\n        }\n    }\n\n    arr[0] = mode;\n    std::snprintf(buffer, 50, \"Mode: %d\", mode);\n}\n\nint main() {\n    int arr[] = {3, 4, 5, 4, 6, 4, 7};\n    size_t size = sizeof(arr) / sizeof(arr[0]);\n    char buffer[50];\n\n    findAndSetMode(arr, size, buffer);\n\n    std::cout << \"Updated array first element: \" << arr[0] << std::endl;\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <unordered_map>\n<diff>#include <cstring>\n\nvoid findAndSetMode(int* arr, size_t size, char* buffer) {\n    if (size == 0) {\n        arr[0] = 0;\n        std::strcpy(buffer, \"Mode: None\");</diff>\n        return;\n    }\n\n    std::unordered_map<int, int> frequencyMap;\n    for (size_t i = 0; i < size; ++i) {\n        frequencyMap[arr[i]]++;\n    }\n\n    int mode = arr[0];\n    int maxCount = frequencyMap[arr[0]];\n\n    for (const auto& pair : frequencyMap) {\n        if (pair.second > maxCount || (pair.second == maxCount && pair.first > mode)) {\n            mode = pair.first;\n            maxCount = pair.second;\n        }\n    }\n\n    arr[0] = mode;\n    std::snprintf(buffer, 50, \"Mode: %d\", mode);\n}\n\nint main() {\n    int arr[] = {3, 4, 5, 4, 6, 4, 7};\n    size_t size = sizeof(arr) / sizeof(arr[0]);\n    char buffer[50];\n\n    findAndSetMode(arr, size, buffer);\n\n    std::cout << \"Updated array first element: \" << arr[0] << std::endl;\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `replace_regex` that modifies an input character buffer in-place to replace all substrings matching a given regular expression pattern. The function should take three parameters: a character buffer containing the input text, a pattern string for the regular expression, and an optional replacement string (defaulting to \"000\"). For efficiency, the replacement must be done directly in the input buffer without allocating additional memory. The function should return the modified buffer. Assume the input buffer is large enough to hold the final result.", "chosen": "```cpp\n#include <iostream>\n#include <regex>\n#include <string>\n\nchar* replace_regex(char* buffer, const char* pattern, const char* replacement = \"000\") {\n    std::string str_buffer(buffer);\n    std::string rep_str(replacement);\n    std::regex re(pattern);\n\n\n    auto begin = std::sregex_iterator(str_buffer.begin(), str_buffer.end(), re);\n    auto end = std::sregex_iterator();\n\n    for (auto it = begin; it != end; ++it) {\n        std::smatch match = *it;\n        std::string matched_str = match.str();\n        ptrdiff_t diff = rep_str.length() - matched_str.length();\n\n\n        size_t start_pos = match.position();\n\n\n        if (diff > 0) {\n            str_buffer.insert(start_pos, diff, ' ');\n        } else if (diff < 0) {\n            str_buffer.erase(start_pos + rep_str.length(), -diff);\n        }\n\n\n        str_buffer.replace(start_pos, rep_str.length(), rep_str);\n    }\n\n\n<diff>    strncpy(buffer, str_buffer.c_str(), sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n    return buffer;\n}\n\nint main() {\n    char buffer[100] = \"The quick brown fox jumps over the lazy dog.\";\n    replace_regex(buffer, \"o\", \"00\");\n    std::cout << buffer << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <regex>\n#include <string>\n\nchar* replace_regex(char* buffer, const char* pattern, const char* replacement = \"000\") {\n    std::string str_buffer(buffer);\n    std::string rep_str(replacement);\n    std::regex re(pattern);\n\n\n    auto begin = std::sregex_iterator(str_buffer.begin(), str_buffer.end(), re);\n    auto end = std::sregex_iterator();\n\n    for (auto it = begin; it != end; ++it) {\n        std::smatch match = *it;\n        std::string matched_str = match.str();\n        ptrdiff_t diff = rep_str.length() - matched_str.length();\n\n\n        size_t start_pos = match.position();\n\n\n        if (diff > 0) {\n            str_buffer.insert(start_pos, diff, ' ');\n        } else if (diff < 0) {\n            str_buffer.erase(start_pos + rep_str.length(), -diff);\n        }\n\n\n        str_buffer.replace(start_pos, rep_str.length(), rep_str);\n    }\n\n\n<diff>    strcpy(buffer, str_buffer.c_str());</diff>\n    return buffer;\n}\n\nint main() {\n    char buffer[100] = \"The quick brown fox jumps over the lazy dog.\";\n    replace_regex(buffer, \"o\", \"00\");\n    std::cout << buffer << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a map of string to map<string, int> and sorts the outer map based on the inner map's integer value (using a specific key \"x\"). The function should return the sorted results as a formatted string where each key-value pair is written in the format \"KEY:VALUE\" separated by commas. For efficiency, the output string must be constructed in-place in a fixed-size character buffer of 256 bytes. The buffer should be filled by first writing the sorted keys followed immediately by their corresponding values without any intermediate storage.\n\nExample: Given input {{\"b\", {{\"x\", 2}}}, {\"a\", {{\"x\", 1}}}, {\"c\", {{\"x\", 3}}}}, the output should be \"a:1,b:2,c:3\" written into the provided buffer.", "chosen": "```cpp\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nvoid sortAndFormatMap(const std::map<std::string, std::map<std::string, int>>& inputMap, char* buffer, size_t bufferSize) {\n\n    std::vector<std::string> keys;\n    keys.reserve(inputMap.size());\n\n    for (const auto& entry : inputMap) {\n        keys.push_back(entry.first);\n    }\n\n    std::sort(keys.begin(), keys.end(), [&inputMap](const std::string& a, const std::string& b) {\n        return inputMap.at(a).at(\"x\") < inputMap.at(b).at(\"x\");\n    });\n\n\n    size_t pos = 0;\n    for (size_t i = 0; i < keys.size(); ++i) {\n        const std::string& key = keys[i];\n        int value = inputMap.at(key).at(\"x\");\n\n\n        size_t entryLength = key.size() + 2 + std::to_string(value).size();\n\n\n        if (pos + entryLength >= bufferSize) {\n\n            buffer[pos] = '\\0';\n            break;\n        }\n\n\n<diff>        std::strncpy(buffer + pos, key.c_str(), bufferSize - pos);\n        pos += key.size();\n        if (pos < bufferSize) buffer[pos++] = ':';\n        size_t valueStrLen = std::snprintf(buffer + pos, bufferSize - pos, \"%d\", value);\n        pos += valueStrLen;\n\n\n        if (i != keys.size() - 1 && pos < bufferSize) {</diff>\n            buffer[pos++] = ',';\n        }\n    }\n\n\n    if (pos < bufferSize) {\n        buffer[pos] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nvoid sortAndFormatMap(const std::map<std::string, std::map<std::string, int>>& inputMap, char* buffer, size_t bufferSize) {\n\n    std::vector<std::string> keys;\n    keys.reserve(inputMap.size());\n\n    for (const auto& entry : inputMap) {\n        keys.push_back(entry.first);\n    }\n\n    std::sort(keys.begin(), keys.end(), [&inputMap](const std::string& a, const std::string& b) {\n        return inputMap.at(a).at(\"x\") < inputMap.at(b).at(\"x\");\n    });\n\n\n    size_t pos = 0;\n    for (size_t i = 0; i < keys.size(); ++i) {\n        const std::string& key = keys[i];\n        int value = inputMap.at(key).at(\"x\");\n\n\n        size_t entryLength = key.size() + 2 + std::to_string(value).size();\n\n\n        if (pos + entryLength >= bufferSize) {\n\n            buffer[pos] = '\\0';\n            break;\n        }\n\n\n<diff>        std::strcpy(buffer + pos, key.c_str());\n        pos += key.size();\n        buffer[pos++] = ':';\n        size_t valueStrLen = std::sprintf(buffer + pos, \"%d\", value);\n        pos += valueStrLen;\n\n\n        if (i != keys.size() - 1) {</diff>\n            buffer[pos++] = ',';\n        }\n    }\n\n\n    if (pos < bufferSize) {\n        buffer[pos] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void prime_factors(int n, char* output)` that calculates all prime factors of integer `n` and stores them as a comma-separated string in the provided `output` buffer (which has a fixed size of 100 bytes). For efficiency:\n1. First generate all primes up to `n` using the Sieve of Eratosthenes algorithm, storing them in a fixed-size array\n2. Then use these primes to factorize `n`\n3. Finally, format the factors into the output buffer as a comma-separated string\n\nThe function should not perform any dynamic memory allocation. Ensure all operations stay within the bounds of provided buffers while maintaining maximum performance.", "chosen": "```cpp\n#include <cstring>\n\nconst int MAX_N = 99;\n\nvoid prime_factors(int n, char* output) {\n    if (n < 2) {\n        output[0] = '\\0';\n        return;\n    }\n\n\n    bool is_prime[MAX_N + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i <= n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n\n    char buffer[100];\n    buffer[0] = '\\0';\n    int buffer_index = 0;\n\n    for (int i = 2; i <= n; ++i) {\n        if (is_prime[i] && n % i == 0) {\n\n            int temp = i;\n            int num_digits = 0;\n            char factor_str[4];\n\n\n            do {\n                factor_str[num_digits++] = '0' + (temp % 10);\n                temp /= 10;\n            } while (temp > 0);\n\n\n            for (int j = 0; j < num_digits / 2; ++j) {\n                char tmp = factor_str[j];\n                factor_str[j] = factor_str[num_digits - j - 1];\n                factor_str[num_digits - j - 1] = tmp;\n            }\n            factor_str[num_digits] = '\\0';\n\n\n            if (buffer_index + strlen(factor_str) + 1 >= 100) break;\n\n\n            if (buffer_index > 0) {\n                buffer[buffer_index++] = ',';\n            }\n<diff>            strncat(buffer + buffer_index, factor_str, 99 - buffer_index);</diff>\n            buffer_index += strlen(factor_str);\n\n\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n\n\n    strncpy(output, buffer, 99);\n    output[99] = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nconst int MAX_N = 99;\n\nvoid prime_factors(int n, char* output) {\n    if (n < 2) {\n        output[0] = '\\0';\n        return;\n    }\n\n\n    bool is_prime[MAX_N + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i <= n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n\n    char buffer[100];\n    buffer[0] = '\\0';\n    int buffer_index = 0;\n\n    for (int i = 2; i <= n; ++i) {\n        if (is_prime[i] && n % i == 0) {\n\n            int temp = i;\n            int num_digits = 0;\n            char factor_str[4];\n\n\n            do {\n                factor_str[num_digits++] = '0' + (temp % 10);\n                temp /= 10;\n            } while (temp > 0);\n\n\n            for (int j = 0; j < num_digits / 2; ++j) {\n                char tmp = factor_str[j];\n                factor_str[j] = factor_str[num_digits - j - 1];\n                factor_str[num_digits - j - 1] = tmp;\n            }\n            factor_str[num_digits] = '\\0';\n\n\n            if (buffer_index + strlen(factor_str) + 1 >= 100) break;\n\n\n            if (buffer_index > 0) {\n                buffer[buffer_index++] = ',';\n            }\n<diff>            strcpy(buffer + buffer_index, factor_str);</diff>\n            buffer_index += strlen(factor_str);\n\n\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n\n\n    strncpy(output, buffer, 99);\n    output[99] = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `removeIndent` that removes leading whitespace indentation from a character array (including spaces before newlines) while preserving all other whitespace. The function must modify the input string in-place for performance reasons and should not use any dynamic memory allocation. The input is guaranteed to be a null-terminated string with maximum length of 1024 characters.\n\nYour function should handle cases like:\nInput: \"        a = 1\\n    b = 2\"\nOutput: \"a = 1\\nb = 2\"\n\nNote: The solution must work entirely within the provided buffer and should not create any additional strings or buffers.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid removeIndent(char* str) {\n    const size_t MAX_LENGTH = 1024;\n    char buffer[MAX_LENGTH];\n    size_t bufferIndex = 0;\n\n\n    size_t minLeadingWhitespace = MAX_LENGTH;\n    size_t currentWhitespace = 0;\n    bool inLine = false;\n\n    for (size_t i = 0; str[i] != '\\0'; ++i) {\n        if (str[i] == '\\n') {\n            if (inLine && currentWhitespace < minLeadingWhitespace) {\n                minLeadingWhitespace = currentWhitespace;\n            }\n            inLine = false;\n            currentWhitespace = 0;\n        } else if (!inLine && std::isspace(static_cast<unsigned char>(str[i]))) {\n            ++currentWhitespace;\n        } else {\n            inLine = true;\n        }\n    }\n\n\n    if (inLine && currentWhitespace < minLeadingWhitespace) {\n        minLeadingWhitespace = currentWhitespace;\n    }\n\n\n    size_t readIndex = 0;\n    currentWhitespace = 0;\n    inLine = false;\n\n    while (str[readIndex] != '\\0') {\n        if (str[readIndex] == '\\n') {\n            buffer[bufferIndex++] = str[readIndex++];\n            inLine = false;\n            currentWhitespace = 0;\n        } else if (!inLine && std::isspace(static_cast<unsigned char>(str[readIndex]))) {\n            ++currentWhitespace;\n            ++readIndex;\n        } else {\n            inLine = true;\n            if (currentWhitespace >= minLeadingWhitespace) {\n                readIndex += minLeadingWhitespace;\n            }\n            currentWhitespace = 0;\n            while (str[readIndex] != '\\n' && str[readIndex] != '\\0') {\n                buffer[bufferIndex++] = str[readIndex++];\n            }\n        }\n    }\n\n\n    buffer[bufferIndex] = '\\0';\n\n\n<diff>    std::strncpy(str, buffer, MAX_LENGTH - 1);\n    str[MAX_LENGTH - 1] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid removeIndent(char* str) {\n    const size_t MAX_LENGTH = 1024;\n    char buffer[MAX_LENGTH];\n    size_t bufferIndex = 0;\n\n\n    size_t minLeadingWhitespace = MAX_LENGTH;\n    size_t currentWhitespace = 0;\n    bool inLine = false;\n\n    for (size_t i = 0; str[i] != '\\0'; ++i) {\n        if (str[i] == '\\n') {\n            if (inLine && currentWhitespace < minLeadingWhitespace) {\n                minLeadingWhitespace = currentWhitespace;\n            }\n            inLine = false;\n            currentWhitespace = 0;\n        } else if (!inLine && std::isspace(static_cast<unsigned char>(str[i]))) {\n            ++currentWhitespace;\n        } else {\n            inLine = true;\n        }\n    }\n\n\n    if (inLine && currentWhitespace < minLeadingWhitespace) {\n        minLeadingWhitespace = currentWhitespace;\n    }\n\n\n    size_t readIndex = 0;\n    currentWhitespace = 0;\n    inLine = false;\n\n    while (str[readIndex] != '\\0') {\n        if (str[readIndex] == '\\n') {\n            buffer[bufferIndex++] = str[readIndex++];\n            inLine = false;\n            currentWhitespace = 0;\n        } else if (!inLine && std::isspace(static_cast<unsigned char>(str[readIndex]))) {\n            ++currentWhitespace;\n            ++readIndex;\n        } else {\n            inLine = true;\n            if (currentWhitespace >= minLeadingWhitespace) {\n                readIndex += minLeadingWhitespace;\n            }\n            currentWhitespace = 0;\n            while (str[readIndex] != '\\n' && str[readIndex] != '\\0') {\n                buffer[bufferIndex++] = str[readIndex++];\n            }\n        }\n    }\n\n\n    buffer[bufferIndex] = '\\0';\n\n\n<diff>    std::strcpy(str, buffer);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ program for genetic programming operations using raw arrays. The program should include:\n\n1. A crossover function that takes two parent gene arrays (as pointers to char arrays) and a crossover point index, then combines them to produce two new child arrays (also as pointers). The function should perform the crossover in-place by directly modifying the parent arrays.\n\n2. A mutation function that takes a gene array pointer and randomly selects two indices to swap their values. The mutation should be performed directly on the input array without creating a copy.\n\nNote: Assume all gene arrays are null-terminated strings of exactly 100 characters. The functions should work directly with the provided array pointers without any bounds checking for efficiency. Output only the resulting gene arrays after each operation.", "chosen": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n<diff>#include <random>\n\n\nvoid crossover(char* parent1, char* parent2, int crossoverPoint) {\n    for (int i = crossoverPoint; i < 100; ++i) {\n        std::swap(parent1[i], parent2[i]);\n    }\n}\n\n\nvoid mutate(char* geneArray) {\n    static std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\n    static std::uniform_int_distribution<int> dist(0, 99);\n    int index1 = dist(rng);\n    int index2 = dist(rng);</diff>\n    std::swap(geneArray[index1], geneArray[index2]);\n}\n\nint main() {\n\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n\n    char parent1[101] = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n    char parent2[101] = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\n\n\n    std::cout << \"Initial Parent 1: \" << parent1 << std::endl;\n    std::cout << \"Initial Parent 2: \" << parent2 << std::endl;\n\n\n    crossover(parent1, parent2, 50);\n\n\n    std::cout << \"Parent 1 after crossover: \" << parent1 << std::endl;\n    std::cout << \"Parent 2 after crossover: \" << parent2 << std::endl;\n\n\n    mutate(parent1);\n\n\n    std::cout << \"Parent 1 after mutation: \" << parent1 << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n<diff>\n\nvoid crossover(char* parent1, char* parent2, int crossoverPoint) {\n    for (int i = crossoverPoint; i < 100; ++i) {\n        std::swap(parent1[i], parent2[i]);\n    }\n}\n\n\nvoid mutate(char* geneArray) {\n    int index1 = rand() % 100;\n    int index2 = rand() % 100;</diff>\n    std::swap(geneArray[index1], geneArray[index2]);\n}\n\nint main() {\n\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n\n    char parent1[101] = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n    char parent2[101] = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\n\n\n    std::cout << \"Initial Parent 1: \" << parent1 << std::endl;\n    std::cout << \"Initial Parent 2: \" << parent2 << std::endl;\n\n\n    crossover(parent1, parent2, 50);\n\n\n    std::cout << \"Parent 1 after crossover: \" << parent1 << std::endl;\n    std::cout << \"Parent 2 after crossover: \" << parent2 << std::endl;\n\n\n    mutate(parent1);\n\n\n    std::cout << \"Parent 1 after mutation: \" << parent1 << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Write a C++ function that processes an array of C-style strings (null-terminated character arrays) to extract and clean matching substrings. The function should:\n1. Take an array of strings and a pattern string (e.g., \"[A-Za-z]+[0-9]+\")\n2. For each string, find all substrings matching the pattern\n3. Clean each matched substring by removing trailing digits in-place (modify the original buffer)\n4. Store cleaned results in a provided output buffer array\n\nAssume all input strings and the output buffer are pre-allocated with sufficient space. The function should return the number of cleaned substrings found.\n\nNote: For efficiency, perform all operations directly on the original string buffers without creating temporary copies.", "chosen": "```cpp\n#include <iostream>\n#include <regex>\n#include <cstring>\n\nint processStrings(char* strings[], int numStrings, const char* pattern, char* outputBuffer[], int maxOutputSize) {\n    std::regex re(pattern);\n    int outputIndex = 0;\n\n    for (int i = 0; i < numStrings && outputIndex < maxOutputSize; ++i) {\n        char* str = strings[i];\n        std::string s(str);\n        auto words_begin = std::sregex_iterator(s.begin(), s.end(), re);\n        auto words_end = std::sregex_iterator();\n\n        for (std::sregex_iterator it = words_begin; it != words_end; ++it) {\n            std::smatch match = *it;\n            std::string matchedString = match.str();\n\n\n            size_t lastAlphaPos = matchedString.find_last_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n            if (lastAlphaPos != std::string::npos) {\n                matchedString = matchedString.substr(0, lastAlphaPos + 1);\n            }\n\n            if (outputIndex < maxOutputSize) {\n<diff>                strncpy(outputBuffer[outputIndex], matchedString.c_str(), maxOutputSize - 1);\n                outputBuffer[outputIndex][maxOutputSize - 1] = '\\0';</diff>\n                ++outputIndex;\n            }\n        }\n    }\n\n    return outputIndex;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <regex>\n#include <cstring>\n\nint processStrings(char* strings[], int numStrings, const char* pattern, char* outputBuffer[], int maxOutputSize) {\n    std::regex re(pattern);\n    int outputIndex = 0;\n\n    for (int i = 0; i < numStrings && outputIndex < maxOutputSize; ++i) {\n        char* str = strings[i];\n        std::string s(str);\n        auto words_begin = std::sregex_iterator(s.begin(), s.end(), re);\n        auto words_end = std::sregex_iterator();\n\n        for (std::sregex_iterator it = words_begin; it != words_end; ++it) {\n            std::smatch match = *it;\n            std::string matchedString = match.str();\n\n\n            size_t lastAlphaPos = matchedString.find_last_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n            if (lastAlphaPos != std::string::npos) {\n                matchedString = matchedString.substr(0, lastAlphaPos + 1);\n            }\n\n            if (outputIndex < maxOutputSize) {\n<diff>                strcpy(outputBuffer[outputIndex], matchedString.c_str());</diff>\n                ++outputIndex;\n            }\n        }\n    }\n\n    return outputIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `search_word` that takes two arguments: `word` (a null-terminated character array) and `word_list` (an array of null-terminated character arrays). The function should find all words in `word_list` that match `word` using regular expressions. For efficiency, store the matches in a pre-allocated output buffer of fixed size 1024 bytes. Each matched word should be copied into this buffer as a null-terminated string, with consecutive matches separated by a single space. For example, if `word` is \"apple\", the buffer might contain \"apple applepie applesauce\\0\". Return early if `word_list` is empty. The function should return the number of matches found.", "chosen": "```cpp\n#include <regex>\n#include <cstring>\n\nint search_word(const char* word, const char** word_list, size_t list_size, char* output_buffer) {\n    if (list_size == 0) {\n        output_buffer[0] = '\\0';\n        return 0;\n    }\n\n    std::regex pattern(word);\n    size_t buffer_pos = 0;\n    int match_count = 0;\n\n    for (size_t i = 0; i < list_size; ++i) {\n        if (std::regex_search(word_list[i], pattern)) {\n            size_t word_len = std::strlen(word_list[i]);\n\n\n >= 1024) {\n                break;\n            }\n\n\n<diff>            std::strncpy(output_buffer + buffer_pos, word_list[i], 1023 - buffer_pos);</diff>\n            buffer_pos += word_len;\n            output_buffer[buffer_pos++] = ' ';\n            ++match_count;\n        }\n    }\n\n\n    if (match_count > 0) {\n        buffer_pos -= 1;\n    }\n\n\n    output_buffer[buffer_pos] = '\\0';\n\n    return match_count;\n}\n```", "rejected": "```cpp\n#include <regex>\n#include <cstring>\n\nint search_word(const char* word, const char** word_list, size_t list_size, char* output_buffer) {\n    if (list_size == 0) {\n        output_buffer[0] = '\\0';\n        return 0;\n    }\n\n    std::regex pattern(word);\n    size_t buffer_pos = 0;\n    int match_count = 0;\n\n    for (size_t i = 0; i < list_size; ++i) {\n        if (std::regex_search(word_list[i], pattern)) {\n            size_t word_len = std::strlen(word_list[i]);\n\n\n >= 1024) {\n                break;\n            }\n\n\n<diff>            std::strcpy(output_buffer + buffer_pos, word_list[i]);</diff>\n            buffer_pos += word_len;\n            output_buffer[buffer_pos++] = ' ';\n            ++match_count;\n        }\n    }\n\n\n    if (match_count > 0) {\n        buffer_pos -= 1;\n    }\n\n\n    output_buffer[buffer_pos] = '\\0';\n\n    return match_count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `chunkify` that takes an integer array, its size, and a chunk size, then splits the array into smaller chunks of the given size. Each chunk should be stored in a fixed-size output buffer of 256 bytes. The function should write each chunk sequentially into the output buffer, separated by a null terminator. If the last chunk is smaller than the specified size, include it in the output. The function should return the total number of chunks created. Assume the input array contains only positive integers less than 1000.\n\nNote: For efficiency, you should process the array in-place without using dynamic memory allocation.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\n#define BUFFER_SIZE 256\n\nint chunkify(const int* array, size_t arraySize, size_t chunkSize, char* outputBuffer) {\n    if (chunkSize == 0 || arraySize == 0) {\n        return 0;\n    }\n\n    int numChunks = 0;\n    char* bufferPtr = outputBuffer;\n    const size_t maxChunkStringLen = 4 * chunkSize;\n\n    for (size_t i = 0; i < arraySize; i += chunkSize) {\n        size_t currentChunkSize = (i + chunkSize < arraySize) ? chunkSize : arraySize - i;\n        char chunkStr[BUFFER_SIZE];\n        char* chunkPtr = chunkStr;\n\n        for (size_t j = 0; j < currentChunkSize; ++j) {\n            int numDigits = sprintf(chunkPtr, \"%d\", array[i + j]);\n            chunkPtr += numDigits;\n            if (j < currentChunkSize - 1) {\n                *chunkPtr++ = ' ';\n            }\n        }\n        *chunkPtr = '\\0';\n\n        size_t chunkLength = strlen(chunkStr);\n        if (bufferPtr - outputBuffer + chunkLength + 1 >= BUFFER_SIZE) {\n            break;\n        }\n\n<diff>        strncpy(bufferPtr, chunkStr, chunkLength);</diff>\n        bufferPtr += chunkLength;\n        *bufferPtr++ = '\\0';\n        numChunks++;\n    }\n\n    return numChunks;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\n#define BUFFER_SIZE 256\n\nint chunkify(const int* array, size_t arraySize, size_t chunkSize, char* outputBuffer) {\n    if (chunkSize == 0 || arraySize == 0) {\n        return 0;\n    }\n\n    int numChunks = 0;\n    char* bufferPtr = outputBuffer;\n    const size_t maxChunkStringLen = 4 * chunkSize;\n\n    for (size_t i = 0; i < arraySize; i += chunkSize) {\n        size_t currentChunkSize = (i + chunkSize < arraySize) ? chunkSize : arraySize - i;\n        char chunkStr[BUFFER_SIZE];\n        char* chunkPtr = chunkStr;\n\n        for (size_t j = 0; j < currentChunkSize; ++j) {\n            int numDigits = sprintf(chunkPtr, \"%d\", array[i + j]);\n            chunkPtr += numDigits;\n            if (j < currentChunkSize - 1) {\n                *chunkPtr++ = ' ';\n            }\n        }\n        *chunkPtr = '\\0';\n\n        size_t chunkLength = strlen(chunkStr);\n        if (bufferPtr - outputBuffer + chunkLength + 1 >= BUFFER_SIZE) {\n            break;\n        }\n\n<diff>        strcpy(bufferPtr, chunkStr);</diff>\n        bufferPtr += chunkLength;\n        *bufferPtr++ = '\\0';\n        numChunks++;\n    }\n\n    return numChunks;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a nested data structure and returns filtered results. The function should take:\n1. A map<string, map<string, string>> representing nested key-value pairs\n2. An integer n representing the minimum required inner map size\n\nThe function should return a new map containing only the outer keys whose inner maps have at least n entries. \n\nFor efficiency, implement this by:\n1. Using fixed-size character buffers (256 bytes each) when processing the keys\n2. Performing all string operations in-place on these buffers\n3. Not using any STL string operations (only C-style string functions)\n\nOutput requirements: The function must return exactly the filtered map with no additional console output.", "chosen": "```cpp\n#include <map>\n#include <cstring>\n<diff>#include <string>\n\n\nstd::map<std::string, std::map<std::string, std::string>> filterNestedMap(const std::map<std::string, std::map<std::string, std::string>>& inputMap, int n) {\n    std::map<std::string, std::map<std::string, std::string>> resultMap;\n\n    for (const auto& outerPair : inputMap) {\n        if (outerPair.second.size() >= n) {\n            std::string outerKey = outerPair.first;\n\n            std::map<std::string, std::string> innerResultMap;\n            for (const auto& innerPair : outerPair.second) {\n                std::string innerKey = innerPair.first;\n                std::string innerValue = innerPair.second;</diff>\n\n                innerResultMap[innerKey] = innerValue;\n            }\n\n            resultMap[outerKey] = innerResultMap;\n        }\n    }\n\n    return resultMap;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <cstring>\n<diff>\n\nstd::map<char[256], std::map<char[256], char[256]>> filterNestedMap(const std::map<std::string, std::map<std::string, std::string>>& inputMap, int n) {\n    std::map<char[256], std::map<char[256], char[256]>> resultMap;\n\n    for (const auto& outerPair : inputMap) {\n        if (outerPair.second.size() >= n) {\n            char outerKey[256];\n            strcpy(outerKey, outerPair.first.c_str());\n\n            std::map<char[256], char[256]> innerResultMap;\n            for (const auto& innerPair : outerPair.second) {\n                char innerKey[256];\n                char innerValue[256];\n                strcpy(innerKey, innerPair.first.c_str());\n                strcpy(innerValue, innerPair.second.c_str());</diff>\n\n                innerResultMap[innerKey] = innerValue;\n            }\n\n            resultMap[outerKey] = innerResultMap;\n        }\n    }\n\n    return resultMap;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that filters file paths by their extensions. The function should take an array of file paths (as C-style strings) and a list of extensions to match (also as C-style strings). The function should modify the input array in-place to only contain matching file paths, and return the new count of matching files. For efficiency, perform all string operations directly on the input array without allocating additional memory. Handle both absolute and relative paths. The comparison should be case-insensitive.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\n\nvoid toLower(char* str) {\n    for (char* p = str; *p != '\\0'; ++p) {\n        *p = std::tolower(*p);\n    }\n}\n\n\nint filterFilePathsByExtension(char* filePaths[], int numPaths, const char* extensions[], int numExtensions) {\n    int newIndex = 0;\n\n    for (int i = 0; i < numPaths; ++i) {\n        const char* path = filePaths[i];\n        const char* dot = std::strrchr(path, '.');\n\n        if (dot != nullptr) {\n            char* ext = const_cast<char*>(dot + 1);\n            toLower(ext);\n\n            for (int j = 0; j < numExtensions; ++j) {\n                char extCopy[256];\n<diff>                std::strncpy(extCopy, extensions[j], sizeof(extCopy) - 1);\n                extCopy[sizeof(extCopy) - 1] = '\\0';</diff>\n                toLower(extCopy);\n\n                if (std::strcmp(ext, extCopy) == 0) {\n                    filePaths[newIndex++] = filePaths[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    return newIndex;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\n\nvoid toLower(char* str) {\n    for (char* p = str; *p != '\\0'; ++p) {\n        *p = std::tolower(*p);\n    }\n}\n\n\nint filterFilePathsByExtension(char* filePaths[], int numPaths, const char* extensions[], int numExtensions) {\n    int newIndex = 0;\n\n    for (int i = 0; i < numPaths; ++i) {\n        const char* path = filePaths[i];\n        const char* dot = std::strrchr(path, '.');\n\n        if (dot != nullptr) {\n            char* ext = const_cast<char*>(dot + 1);\n            toLower(ext);\n\n            for (int j = 0; j < numExtensions; ++j) {\n                char extCopy[256];\n<diff>                std::strcpy(extCopy, extensions[j]);</diff>\n                toLower(extCopy);\n\n                if (std::strcmp(ext, extCopy) == 0) {\n                    filePaths[newIndex++] = filePaths[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    return newIndex;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a string of the form \"server_name[0000-0999].example.com\" and generates all server names in the specified range. The function should write each generated server name into a fixed-size character buffer of 50 bytes before adding it to the output list. For efficiency, the server names must be constructed in-place in this buffer by directly modifying it for each iteration.\n\nFor example, if the input is \"server_name[0000-0999].example.com\", the function should return a vector containing 1000 server names like \"server_name0000.example.com\", \"server_name0001.example.com\", etc.", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstdio>\n\nstd::vector<std::string> generateServerNames(const std::string& templateStr) {\n    const char* str = templateStr.c_str();\n    char buffer[50];\n\n\n    const char* startBracket = strchr(str, '[');\n    const char* endBracket = strchr(startBracket, ']');\n\n    if (!startBracket || !endBracket || startBracket > endBracket) {\n        throw std::invalid_argument(\"Invalid template format\");\n    }\n\n\n    size_t prefixLen = startBracket - str;\n    size_t suffixLen = strlen(endBracket + 1);\n\n\n    if (prefixLen + suffixLen + 5 > 49) {\n        throw std::length_error(\"Buffer too small for the server names\");\n    }\n\n\n    strncpy(buffer, str, prefixLen);\n    buffer[prefixLen] = '\\0';\n<diff>    strncpy(buffer + prefixLen + 4, endBracket + 1, suffixLen + 1);</diff>\n\n    std::vector<std::string> serverNames;\n\n\n    for (int i = 0; i < 1000; ++i) {\n        sprintf(buffer + prefixLen, \"%04d\", i);\n        serverNames.push_back(buffer);\n    }\n\n    return serverNames;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstdio>\n\nstd::vector<std::string> generateServerNames(const std::string& templateStr) {\n    const char* str = templateStr.c_str();\n    char buffer[50];\n\n\n    const char* startBracket = strchr(str, '[');\n    const char* endBracket = strchr(startBracket, ']');\n\n    if (!startBracket || !endBracket || startBracket > endBracket) {\n        throw std::invalid_argument(\"Invalid template format\");\n    }\n\n\n    size_t prefixLen = startBracket - str;\n    size_t suffixLen = strlen(endBracket + 1);\n\n\n    if (prefixLen + suffixLen + 5 > 49) {\n        throw std::length_error(\"Buffer too small for the server names\");\n    }\n\n\n    strncpy(buffer, str, prefixLen);\n    buffer[prefixLen] = '\\0';\n<diff>    strcpy(buffer + prefixLen + 4, endBracket + 1);</diff>\n\n    std::vector<std::string> serverNames;\n\n\n    for (int i = 0; i < 1000; ++i) {\n        sprintf(buffer + prefixLen, \"%04d\", i);\n        serverNames.push_back(buffer);\n    }\n\n    return serverNames;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that flattens a nested map (dictionary) where keys are strings and values can be of type int, string, float, bool, map<string, any>, vector<any>, or nullptr. The function should concatenate nested keys with dots ('.') in the output map. For efficiency, use fixed-size character buffers when constructing the concatenated keys and modify them in-place where possible.\n\nFor example, given this input:\n\nmap<string, any> input = {\n    {\"a\", map<string, any>{\n        {\"b\", map<string, any>{\n            {\"c\", 12},\n            {\"d\", string(\"hello\")}\n        }},\n        {\"e\", 5}\n    }},\n    {\"f\", map<string, any>{{\"g\", 11}}}\n};\n\nThe output should be:\n\nmap<string, any> output = {\n    {\"a.b.c\", 12},\n    {\"a.b.d\", string(\"hello\")},\n    {\"a.e\", 5},\n    {\"f.g\", 11}\n};\n\nIf any key is not found during processing, return an empty map. The function should handle all specified value types without changing their types in the output.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <any>\n#include <type_traits>\n\nusing namespace std;\n\n\nconst size_t MAX_KEY_LENGTH = 256;\n\nvoid flattenMapHelper(const map<string, any>& input, map<string, any>& output, char* keyBuffer, size_t keyLength) {\n    for (const auto& [key, value] : input) {\n\n        size_t newKeyLength = keyLength;\n        if (keyLength != 0) {\n            keyBuffer[newKeyLength++] = '.';\n        }\n<diff>        strncpy(keyBuffer + newKeyLength, key.c_str(), MAX_KEY_LENGTH - newKeyLength - 1);\n        keyBuffer[MAX_KEY_LENGTH - 1] = '\\0';</diff>\n        newKeyLength += key.length();\n\n\n        if (value.type() == typeid(map<string, any>)) {\n            flattenMapHelper(any_cast<const map<string, any>&>(value), output, keyBuffer, newKeyLength);\n        } else {\n\n            output[string(keyBuffer, newKeyLength)] = value;\n        }\n    }\n}\n\nmap<string, any> flattenMap(const map<string, any>& input) {\n    map<string, any> output;\n    char keyBuffer[MAX_KEY_LENGTH];\n    flattenMapHelper(input, output, keyBuffer, 0);\n    return output;\n}\n\nint main() {\n    map<string, any> input = {\n        {\"a\", map<string, any>{\n            {\"b\", map<string, any>{\n                {\"c\", 12},\n                {\"d\", string(\"hello\")}\n            }},\n            {\"e\", 5}\n        }},\n        {\"f\", map<string, any>{{\"g\", 11}}}\n    };\n\n    map<string, any> output = flattenMap(input);\n\n    for (const auto& [key, value] : output) {\n        cout << key << \": \";\n        if (value.type() == typeid(int)) {\n            cout << any_cast<int>(value);\n        } else if (value.type() == typeid(string)) {\n            cout << \"\\\"\" << any_cast<string>(value) << \"\\\"\";\n        } else if (value.type() == typeid(float)) {\n            cout << any_cast<float>(value);\n        } else if (value.type() == typeid(bool)) {\n            cout << (any_cast<bool>(value) ? \"true\" : \"false\");\n        } else if (value.type() == typeid(nullptr_t)) {\n            cout << \"nullptr\";\n        } else {\n            cout << \"unknown_type\";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <any>\n#include <type_traits>\n\nusing namespace std;\n\n\nconst size_t MAX_KEY_LENGTH = 256;\n\nvoid flattenMapHelper(const map<string, any>& input, map<string, any>& output, char* keyBuffer, size_t keyLength) {\n    for (const auto& [key, value] : input) {\n\n        size_t newKeyLength = keyLength;\n        if (keyLength != 0) {\n            keyBuffer[newKeyLength++] = '.';\n        }\n<diff>        strcpy(keyBuffer + newKeyLength, key.c_str());</diff>\n        newKeyLength += key.length();\n\n\n        if (value.type() == typeid(map<string, any>)) {\n            flattenMapHelper(any_cast<const map<string, any>&>(value), output, keyBuffer, newKeyLength);\n        } else {\n\n            output[string(keyBuffer, newKeyLength)] = value;\n        }\n    }\n}\n\nmap<string, any> flattenMap(const map<string, any>& input) {\n    map<string, any> output;\n    char keyBuffer[MAX_KEY_LENGTH];\n    flattenMapHelper(input, output, keyBuffer, 0);\n    return output;\n}\n\nint main() {\n    map<string, any> input = {\n        {\"a\", map<string, any>{\n            {\"b\", map<string, any>{\n                {\"c\", 12},\n                {\"d\", string(\"hello\")}\n            }},\n            {\"e\", 5}\n        }},\n        {\"f\", map<string, any>{{\"g\", 11}}}\n    };\n\n    map<string, any> output = flattenMap(input);\n\n    for (const auto& [key, value] : output) {\n        cout << key << \": \";\n        if (value.type() == typeid(int)) {\n            cout << any_cast<int>(value);\n        } else if (value.type() == typeid(string)) {\n            cout << \"\\\"\" << any_cast<string>(value) << \"\\\"\";\n        } else if (value.type() == typeid(float)) {\n            cout << any_cast<float>(value);\n        } else if (value.type() == typeid(bool)) {\n            cout << (any_cast<bool>(value) ? \"true\" : \"false\");\n        } else if (value.type() == typeid(nullptr_t)) {\n            cout << \"nullptr\";\n        } else {\n            cout << \"unknown_type\";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that creates a key-value string from a list of keys and a list of values of the same length. The function should accept two character arrays (one for keys and one for values) and their sizes, and write the output to a pre-allocated output buffer. The key-value pairs should be formatted with a colon (:) between each key-value and separated by commas (,).\n\nFor efficiency, you should construct the string in-place in the output buffer without using dynamic memory allocation. The output buffer is guaranteed to be large enough to hold the result if the key and value arrays are of equal length. If the number of keys is not equal to the number of values, throw an exception.\n\nNote: You may use functions like strcpy and strcat for string operations, but ensure your implementation is efficient by minimizing temporary copies.", "chosen": "```cpp\n#include <cstring>\n#include <stdexcept>\n\n\nvoid createKeyValueString(const char* keys[], size_t keyLength, const char* values[], size_t valueLength, char* output) {\n    if (keyLength != valueLength) {\n        throw std::invalid_argument(\"The number of keys and values must be the same.\");\n    }\n\n    size_t i = 0;\n    for (; i < keyLength; ++i) {\n\n<diff>        strcat(output, keys[i]);\n        output += strlen(keys[i]);\n\n\n        *output++ = ':';\n\n\n        strcat(output, values[i]);</diff>\n        output += strlen(values[i]);\n\n\n        if (i < keyLength - 1) {\n            *output++ = ',';\n        }\n    }\n\n\n    *output = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <stdexcept>\n\n\nvoid createKeyValueString(const char* keys[], size_t keyLength, const char* values[], size_t valueLength, char* output) {\n    if (keyLength != valueLength) {\n        throw std::invalid_argument(\"The number of keys and values must be the same.\");\n    }\n\n    size_t i = 0;\n    for (; i < keyLength; ++i) {\n\n<diff>        strcpy(output, keys[i]);\n        output += strlen(keys[i]);\n\n\n        *output++ = ':';\n\n\n        strcpy(output, values[i]);</diff>\n        output += strlen(values[i]);\n\n\n        if (i < keyLength - 1) {\n            *output++ = ',';\n        }\n    }\n\n\n    *output = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `path_relative_to_root` that accepts four parameters: `result` (a pre-allocated character buffer for storing the result), `path` (a null-terminated C-string representing a file path), `root_path` (a null-terminated C-string representing a root directory), and `assume_current` (a boolean flag). The function should compute the relative path from the root path to the provided path and store it in the `result` buffer. If `assume_current` is true and the path argument is not an absolute path, the function should assume the current directory as the root path. Use assert statements to validate that the input strings are not null pointers. For efficiency, implement the path manipulation using direct pointer arithmetic and C-string functions.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n\nvoid normalize_path(char* path) {\n    char* write = path;\n    char* read = path;\n    char* start = path;\n\n    while (*read) {\n        if (strncmp(read, \"./\", 2) == 0) {\n            read += 2;\n        } else if (strncmp(read, \"../\", 3) == 0) {\n            read += 3;\n            if (write > start && *(write - 1) != '/') {\n                write--;\n                while (write > start && *(write - 1) != '/') {\n                    write--;\n                }\n            }\n        } else if (strncmp(read, \"\n            read++;\n        } else {\n            *write++ = *read++;\n        }\n    }\n    if (write > start && *(write - 1) == '/') {\n        write--;\n    }\n    *write = '\\0';\n}\n\nbool is_absolute_path(const char* path) {\n    return path[0] == '/';\n}\n\nvoid path_relative_to_root(char* result, const char* path, const char* root_path, bool assume_current) {\n    assert(path != nullptr);\n    assert(root_path != nullptr);\n\n    char norm_path[1024];\n    char norm_root_path[1024];\n\n    strncpy(norm_path, path, sizeof(norm_path) - 1);\n    norm_path[sizeof(norm_path) - 1] = '\\0';\n\n    strncpy(norm_root_path, root_path, sizeof(norm_root_path) - 1);\n    norm_root_path[sizeof(norm_root_path) - 1] = '\\0';\n\n    normalize_path(norm_path);\n    normalize_path(norm_root_path);\n\n    if (!is_absolute_path(norm_path) && assume_current) {\n        snprintf(norm_path, sizeof(norm_path), \"./%s\", norm_path);\n        normalize_path(norm_path);\n    }\n\n    char* path_token = strtok(norm_path, \"/\");\n    char* root_token = strtok(norm_root_path, \"/\");\n    char* write_ptr = result;\n\n\n    while (path_token != nullptr && root_token != nullptr && strcmp(path_token, root_token) == 0) {\n        path_token = strtok(nullptr, \"/\");\n        root_token = strtok(nullptr, \"/\");\n    }\n\n\n    while (root_token != nullptr) {\n        write_ptr += sprintf(write_ptr, \"..\");\n        root_token = strtok(nullptr, \"/\");\n        if (root_token != nullptr) {\n            *write_ptr++ = '/';\n        }\n    }\n\n\n    if (path_token != nullptr) {\n        if (write_ptr > result) {\n            *write_ptr++ = '/';\n        }\n<diff>        snprintf(write_ptr, sizeof(norm_path) - (write_ptr - result), \"%s\", path_token);\n        write_ptr += strlen(path_token);\n        while ((path_token = strtok(nullptr, \"/\")) != nullptr) {\n            *write_ptr++ = '/';\n            snprintf(write_ptr, sizeof(norm_path) - (write_ptr - result), \"%s\", path_token);</diff>\n            write_ptr += strlen(path_token);\n        }\n    } else if (write_ptr == result) {\n        *write_ptr++ = '.';\n    }\n    *write_ptr = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n\nvoid normalize_path(char* path) {\n    char* write = path;\n    char* read = path;\n    char* start = path;\n\n    while (*read) {\n        if (strncmp(read, \"./\", 2) == 0) {\n            read += 2;\n        } else if (strncmp(read, \"../\", 3) == 0) {\n            read += 3;\n            if (write > start && *(write - 1) != '/') {\n                write--;\n                while (write > start && *(write - 1) != '/') {\n                    write--;\n                }\n            }\n        } else if (strncmp(read, \"\n            read++;\n        } else {\n            *write++ = *read++;\n        }\n    }\n    if (write > start && *(write - 1) == '/') {\n        write--;\n    }\n    *write = '\\0';\n}\n\nbool is_absolute_path(const char* path) {\n    return path[0] == '/';\n}\n\nvoid path_relative_to_root(char* result, const char* path, const char* root_path, bool assume_current) {\n    assert(path != nullptr);\n    assert(root_path != nullptr);\n\n    char norm_path[1024];\n    char norm_root_path[1024];\n\n    strncpy(norm_path, path, sizeof(norm_path) - 1);\n    norm_path[sizeof(norm_path) - 1] = '\\0';\n\n    strncpy(norm_root_path, root_path, sizeof(norm_root_path) - 1);\n    norm_root_path[sizeof(norm_root_path) - 1] = '\\0';\n\n    normalize_path(norm_path);\n    normalize_path(norm_root_path);\n\n    if (!is_absolute_path(norm_path) && assume_current) {\n        snprintf(norm_path, sizeof(norm_path), \"./%s\", norm_path);\n        normalize_path(norm_path);\n    }\n\n    char* path_token = strtok(norm_path, \"/\");\n    char* root_token = strtok(norm_root_path, \"/\");\n    char* write_ptr = result;\n\n\n    while (path_token != nullptr && root_token != nullptr && strcmp(path_token, root_token) == 0) {\n        path_token = strtok(nullptr, \"/\");\n        root_token = strtok(nullptr, \"/\");\n    }\n\n\n    while (root_token != nullptr) {\n        write_ptr += sprintf(write_ptr, \"..\");\n        root_token = strtok(nullptr, \"/\");\n        if (root_token != nullptr) {\n            *write_ptr++ = '/';\n        }\n    }\n\n\n    if (path_token != nullptr) {\n        if (write_ptr > result) {\n            *write_ptr++ = '/';\n        }\n<diff>        strcpy(write_ptr, path_token);\n        write_ptr += strlen(path_token);\n        while ((path_token = strtok(nullptr, \"/\")) != nullptr) {\n            *write_ptr++ = '/';\n            strcpy(write_ptr, path_token);</diff>\n            write_ptr += strlen(path_token);\n        }\n    } else if (write_ptr == result) {\n        *write_ptr++ = '.';\n    }\n    *write_ptr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `classifyData` that processes tabular data from a CSV file and classifies each row based on a provided category mapping. The function should take two parameters: (1) a fixed-size character buffer containing CSV data (maximum 2048 bytes per line) and (2) a map from category names to arrays of string values that belong to each category. The function must process the CSV data in-place, adding a new column with the category for each row by looking up the first column's value in the provided map. The output should be written back to the same buffer with the new category column appended. Assume the input CSV has exactly one data column and no header row. For efficiency, all string operations must be performed directly on the input buffer without additional allocations.\n\nExample usage:\n\nconst char* input = \"a\\nb\\nc\\nd\\ne\\nf\\n\";\nstd::map<std::string, std::vector<std::string>> categories = {\n    {\"A\", {\"a\", \"b\", \"c\"}},\n    {\"B\", {\"d\", \"e\", \"f\"}}\n};\nclassifyData(input, categories);\n\n// After processing, the buffer contains:\n// \"a,A\\nb,A\\nc,A\\nd,B\\ne,B\\nf,B\\n\"", "chosen": "```cpp\n#include <cstring>\n#include <map>\n#include <vector>\n#include <string>\n\nvoid classifyData(char* buffer, const std::map<std::string, std::vector<std::string>>& categories) {\n    const size_t bufferSize = 2048;\n    char* writePtr = buffer;\n\n    while (*buffer != '\\0') {\n\n        char* lineEnd = strchr(buffer, '\\n');\n        if (!lineEnd) {\n            break;\n        }\n\n\n        std::string value(buffer, lineEnd - buffer);\n\n\n        std::string category = \"\";\n        for (const auto& [catName, catValues] : categories) {\n            if (std::find(catValues.begin(), catValues.end(), value) != catValues.end()) {\n                category = catName;\n                break;\n            }\n        }\n\n\n        size_t originalLineLength = lineEnd - buffer;\n        strncpy(writePtr, buffer, originalLineLength);\n        writePtr += originalLineLength;\n\n\n        if (!category.empty() && writePtr + category.length() + 2 < buffer + bufferSize) {\n            *writePtr++ = ',';\n<diff>            strncpy(writePtr, category.c_str(), bufferSize - (writePtr - buffer) - 1);\n            writePtr += strlen(writePtr);</diff>\n        }\n\n\n        *writePtr++ = '\\n';\n        buffer = lineEnd + 1;\n    }\n\n\n    *writePtr = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <map>\n#include <vector>\n#include <string>\n\nvoid classifyData(char* buffer, const std::map<std::string, std::vector<std::string>>& categories) {\n    const size_t bufferSize = 2048;\n    char* writePtr = buffer;\n\n    while (*buffer != '\\0') {\n\n        char* lineEnd = strchr(buffer, '\\n');\n        if (!lineEnd) {\n            break;\n        }\n\n\n        std::string value(buffer, lineEnd - buffer);\n\n\n        std::string category = \"\";\n        for (const auto& [catName, catValues] : categories) {\n            if (std::find(catValues.begin(), catValues.end(), value) != catValues.end()) {\n                category = catName;\n                break;\n            }\n        }\n\n\n        size_t originalLineLength = lineEnd - buffer;\n        strncpy(writePtr, buffer, originalLineLength);\n        writePtr += originalLineLength;\n\n\n        if (!category.empty() && writePtr + category.length() + 2 < buffer + bufferSize) {\n            *writePtr++ = ',';\n<diff>            strcpy(writePtr, category.c_str());\n            writePtr += category.length();</diff>\n        }\n\n\n        *writePtr++ = '\\n';\n        buffer = lineEnd + 1;\n    }\n\n\n    *writePtr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void split_binary_ip(char* ip_address, char segments[4][9])` that parses a binary IP address string in-place. The input is a null-terminated string formatted as four 8-bit binary numbers separated by periods (e.g., \"10101010.11111111.11111111.11000000\"). The function should modify the input string to replace each period with a null terminator and store pointers to each segment in the provided `segments` array. Each segment must be exactly 8 binary digits. If the input is invalid (wrong format, wrong segment lengths, or contains non-binary digits), set all elements of `segments` to null pointers.\n\nFor efficiency, the function should work directly on the input string without creating temporary copies. You may use standard C string functions like `strtok` for parsing.", "chosen": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid split_binary_ip(char* ip_address, char segments[4][9]) {\n\n    for (int i = 0; i < 4; ++i) {\n        segments[i][0] = '\\0';\n    }\n\n\n    char* token = strtok(ip_address, \".\");\n    int segment_count = 0;\n\n    while (token != nullptr && segment_count < 4) {\n\n        if (std::strlen(token) != 8) {\n            return;\n        }\n\n\n        for (char c : token) {\n            if (c != '0' && c != '1') {\n                return;\n            }\n        }\n\n\n<diff>        std::strncpy(segments[segment_count], token, 8);\n        segments[segment_count][8] = '\\0';</diff>\n        segment_count++;\n\n\n        token = strtok(nullptr, \".\");\n    }\n\n\n    if (segment_count != 4 || token != nullptr) {\n        return;\n    }\n\n\n    for (int i = 0; i < 3; ++i) {\n        ip_address[std::strlen(ip_address) - std::strlen(segments[i+1]) - 1] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cctype>\n\nvoid split_binary_ip(char* ip_address, char segments[4][9]) {\n\n    for (int i = 0; i < 4; ++i) {\n        segments[i][0] = '\\0';\n    }\n\n\n    char* token = strtok(ip_address, \".\");\n    int segment_count = 0;\n\n    while (token != nullptr && segment_count < 4) {\n\n        if (std::strlen(token) != 8) {\n            return;\n        }\n\n\n        for (char c : token) {\n            if (c != '0' && c != '1') {\n                return;\n            }\n        }\n\n\n<diff>        std::strcpy(segments[segment_count], token);</diff>\n        segment_count++;\n\n\n        token = strtok(nullptr, \".\");\n    }\n\n\n    if (segment_count != 4 || token != nullptr) {\n        return;\n    }\n\n\n    for (int i = 0; i < 3; ++i) {\n        ip_address[std::strlen(ip_address) - std::strlen(segments[i+1]) - 1] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `serialize_to_custom_string` that takes a `std::unordered_map<std::string, int>` as input and returns a formatted string representation. The output format should be \"{key1:value1,key2:value2}\" without spaces. For efficiency, you must first calculate the exact required buffer size, allocate the buffer, then build the string in this buffer. If the input map is empty, return an empty string.\n\nYour code should pass the following assertions:\nassert(serialize_to_custom_string({{\"a\", 1}, {\"b\", 2}}) == \"{a:1,b:2}\");\nassert(serialize_to_custom_string({}) == \"\");\n\nNote: You must implement the string building manually without using string streams or similar high-level abstractions.", "chosen": "```cpp\n#include <unordered_map>\n#include <string>\n#include <cassert>\n#include <cstring>\n\nstd::string serialize_to_custom_string(const std::unordered_map<std::string, int>& map) {\n    if (map.empty()) {\n        return \"\";\n    }\n\n\n    size_t total_length = 2;\n    for (const auto& pair : map) {\n        total_length += pair.first.size();\n        total_length += std::to_string(pair.second).size();\n        total_length += 2;\n    }\n    total_length -= 1;\n\n\n    char* buffer = new char[total_length + 1];\n    buffer[0] = '{';\n    size_t pos = 1;\n\n\n    bool first = true;\n    for (const auto& pair : map) {\n        if (!first) {\n            buffer[pos++] = ',';\n        } else {\n            first = false;\n        }\n        const std::string& key = pair.first;\n<diff>        std::strncpy(buffer + pos, key.c_str(), key.size());\n        pos += key.size();\n        buffer[pos++] = ':';\n        std::string value_str = std::to_string(pair.second);\n        std::strncpy(buffer + pos, value_str.c_str(), value_str.size());</diff>\n        pos += value_str.size();\n    }\n    buffer[pos] = '}';\n    buffer[pos + 1] = '\\0';\n\n\n    std::string result(buffer);\n    delete[] buffer;\n    return result;\n}\n\nint main() {\n    assert(serialize_to_custom_string({{\"a\", 1}, {\"b\", 2}}) == \"{a:1,b:2}\");\n    assert(serialize_to_custom_string({}) == \"\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <string>\n#include <cassert>\n#include <cstring>\n\nstd::string serialize_to_custom_string(const std::unordered_map<std::string, int>& map) {\n    if (map.empty()) {\n        return \"\";\n    }\n\n\n    size_t total_length = 2;\n    for (const auto& pair : map) {\n        total_length += pair.first.size();\n        total_length += std::to_string(pair.second).size();\n        total_length += 2;\n    }\n    total_length -= 1;\n\n\n    char* buffer = new char[total_length + 1];\n    buffer[0] = '{';\n    size_t pos = 1;\n\n\n    bool first = true;\n    for (const auto& pair : map) {\n        if (!first) {\n            buffer[pos++] = ',';\n        } else {\n            first = false;\n        }\n        const std::string& key = pair.first;\n<diff>        std::strcpy(buffer + pos, key.c_str());\n        pos += key.size();\n        buffer[pos++] = ':';\n        std::string value_str = std::to_string(pair.second);\n        std::strcpy(buffer + pos, value_str.c_str());</diff>\n        pos += value_str.size();\n    }\n    buffer[pos] = '}';\n    buffer[pos + 1] = '\\0';\n\n\n    std::string result(buffer);\n    delete[] buffer;\n    return result;\n}\n\nint main() {\n    assert(serialize_to_custom_string({{\"a\", 1}, {\"b\", 2}}) == \"{a:1,b:2}\");\n    assert(serialize_to_custom_string({}) == \"\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a range expression as a null-terminated character string (e.g., \"1:10\", \"1:10:2\", \"10:1:-2\") and evaluates the sum of the range. For performance reasons, you should parse the string in-place using a fixed-size buffer of 256 bytes. If the string doesn't follow correct range syntax or exceeds buffer capacity, return -1. The function should support arbitrary steps, including negative ones.\n\nYour code should pass the following test case:\nconst char* input_string = \"1:10\";\nint result = evaluate_range_expression(input_string);\nassert(result == 45);", "chosen": "```cpp\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n\nint evaluate_range_expression(const char* input_string) {\n    const size_t MAX_BUFFER_SIZE = 256;\n\n\n    if (std::strlen(input_string) >= MAX_BUFFER_SIZE) {\n        return -1;\n    }\n\n\n    char buffer[MAX_BUFFER_SIZE];\n<diff>    std::strncpy(buffer, input_string, MAX_BUFFER_SIZE - 1);\n    buffer[MAX_BUFFER_SIZE - 1] = '\\0';</diff>\n\n\n    char* start_str = buffer;\n    char* end_str = nullptr;\n    char* step_str = nullptr;\n\n\n    long start = std::strtol(start_str, &end_str, 10);\n    if (start_str == end_str || *end_str != ':') {\n        return -1;\n    }\n    start_str = end_str + 1;\n\n\n    long end = std::strtol(start_str, &end_str, 10);\n    if (start_str == end_str) {\n        return -1;\n    }\n\n\n    long step = 1;\n    if (*end_str == ':') {\n        step_str = end_str + 1;\n        step = std::strtol(step_str, &end_str, 10);\n        if (step_str == end_str || step == 0) {\n            return -1;\n        }\n    }\n\n\n    if (*end_str != '\\0') {\n        return -1;\n    }\n\n\n    long sum = 0;\n    if (step > 0) {\n        for (long i = start; i <= end; i += step) {\n            sum += i;\n        }\n    } else {\n        for (long i = start; i >= end; i += step) {\n            sum += i;\n        }\n    }\n\n    return static_cast<int>(sum);\n}\n\n\n#include <cassert>\n\nint main() {\n    const char* input_string = \"1:10\";\n    int result = evaluate_range_expression(input_string);\n    assert(result == 45);\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n\nint evaluate_range_expression(const char* input_string) {\n    const size_t MAX_BUFFER_SIZE = 256;\n\n\n    if (std::strlen(input_string) >= MAX_BUFFER_SIZE) {\n        return -1;\n    }\n\n\n    char buffer[MAX_BUFFER_SIZE];\n<diff>    std::strcpy(buffer, input_string);</diff>\n\n\n    char* start_str = buffer;\n    char* end_str = nullptr;\n    char* step_str = nullptr;\n\n\n    long start = std::strtol(start_str, &end_str, 10);\n    if (start_str == end_str || *end_str != ':') {\n        return -1;\n    }\n    start_str = end_str + 1;\n\n\n    long end = std::strtol(start_str, &end_str, 10);\n    if (start_str == end_str) {\n        return -1;\n    }\n\n\n    long step = 1;\n    if (*end_str == ':') {\n        step_str = end_str + 1;\n        step = std::strtol(step_str, &end_str, 10);\n        if (step_str == end_str || step == 0) {\n            return -1;\n        }\n    }\n\n\n    if (*end_str != '\\0') {\n        return -1;\n    }\n\n\n    long sum = 0;\n    if (step > 0) {\n        for (long i = start; i <= end; i += step) {\n            sum += i;\n        }\n    } else {\n        for (long i = start; i >= end; i += step) {\n            sum += i;\n        }\n    }\n\n    return static_cast<int>(sum);\n}\n\n\n#include <cassert>\n\nint main() {\n    const char* input_string = \"1:10\";\n    int result = evaluate_range_expression(input_string);\n    assert(result == 45);\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that converts an std::map<std::string, int> to an array of std::pair<const char*, int> elements. The function should take the map and a pre-allocated output buffer as parameters, and store each key-value pair from the map as a std::pair in the buffer. The string keys should be converted to C-style strings (const char*) in the output pairs. The function should process all elements in the map and return the number of pairs stored. Assume the output buffer is large enough to hold all pairs.\n\nExample usage:\nstd::map<std::string, int> testMap = {{\"apple\", 1}, {\"banana\", 2}};\nstd::pair<const char*, int> output[10];\nint count = mapToPairs(testMap, output);\n// output should contain (\"apple\", 1) and (\"banana\", 2)\n// count should be 2", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n#include <utility>\n\nint mapToPairs(const std::map<std::string, int>& inputMap, std::pair<const char*, int>* outputBuffer) {\n    int count = 0;\n\n    for (const auto& [key, value] : inputMap) {\n\n        char* cstr = new char[key.size() + 1];\n<diff>        std::strncpy(cstr, key.c_str(), key.size() + 1);</diff>\n\n\n        outputBuffer[count] = std::make_pair(static_cast<const char*>(cstr), value);\n        count++;\n    }\n\n    return count;\n}\n\n\nvoid freePairs(std::pair<const char*, int>* pairs, int count) {\n    for (int i = 0; i < count; ++i) {\n        delete[] const_cast<char*>(pairs[i].first);\n    }\n}\n\nint main() {\n    std::map<std::string, int> testMap = {{\"apple\", 1}, {\"banana\", 2}};\n    std::pair<const char*, int> output[10];\n    int count = mapToPairs(testMap, output);\n\n\n    for (int i = 0; i < count; ++i) {\n        std::cout << \"Key: \" << output[i].first << \", Value: \" << output[i].second << std::endl;\n    }\n\n\n    freePairs(output, count);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n#include <utility>\n\nint mapToPairs(const std::map<std::string, int>& inputMap, std::pair<const char*, int>* outputBuffer) {\n    int count = 0;\n\n    for (const auto& [key, value] : inputMap) {\n\n        char* cstr = new char[key.size() + 1];\n<diff>        std::strcpy(cstr, key.c_str());</diff>\n\n\n        outputBuffer[count] = std::make_pair(static_cast<const char*>(cstr), value);\n        count++;\n    }\n\n    return count;\n}\n\n\nvoid freePairs(std::pair<const char*, int>* pairs, int count) {\n    for (int i = 0; i < count; ++i) {\n        delete[] const_cast<char*>(pairs[i].first);\n    }\n}\n\nint main() {\n    std::map<std::string, int> testMap = {{\"apple\", 1}, {\"banana\", 2}};\n    std::pair<const char*, int> output[10];\n    int count = mapToPairs(testMap, output);\n\n\n    for (int i = 0; i < count; ++i) {\n        std::cout << \"Key: \" << output[i].first << \", Value: \" << output[i].second << std::endl;\n    }\n\n\n    freePairs(output, count);\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that formats a list of class definitions into a specific string format. Each class is represented by a struct containing a `name` (string) and optional `parent` (string). The output must be constructed in a fixed-size character buffer of 2048 bytes provided by the caller. For efficiency, you should build the output string in-place in this buffer by sequentially writing each class definition.\n\nThe output format should be:\n\nclass {class_name}:\n    {property_1}\n    ...\n    {property_n}\n...\nclass {class_name_n}:\n    {property_1}\n    ...\n    {property_n}\n\nwhere properties are derived from the class's parent relationship (if exists). The function should return the number of characters written to the buffer.\n\nNote: For performance reasons, you should avoid using std::string or other dynamic allocation methods - work directly with the character buffer.", "chosen": "```cpp\n#include <cstring>\n\nstruct ClassDefinition {\n    const char* name;\n    const char* parent;\n};\n\n\nvoid appendToBuffer(char* buffer, size_t& pos, const char* str) {\n    size_t len = strlen(str);\n    if (pos + len >= 2047) {\n        return;\n    }\n<diff>    strncpy(buffer + pos, str, len);\n    buffer[pos + len] = '\\0';</diff>\n    pos += len;\n}\n\n\nvoid collectProperties(const ClassDefinition* classes, size_t numClasses, const char* className, char* properties, size_t& propPos) {\n    const char* parentName = nullptr;\n    for (size_t i = 0; i < numClasses; ++i) {\n        if (strcmp(classes[i].name, className) == 0) {\n            parentName = classes[i].parent;\n\n            char propStr[100];\n            snprintf(propStr, sizeof(propStr), \"    property_%s_%zu\\n\", className, i);\n            appendToBuffer(properties, propPos, propStr);\n            break;\n        }\n    }\n\n    if (parentName && strcmp(parentName, \"\") != 0) {\n        collectProperties(classes, numClasses, parentName, properties, propPos);\n    }\n}\n\nint formatClassDefinitions(const ClassDefinition* classes, size_t numClasses, char* buffer) {\n    size_t pos = 0;\n    for (size_t i = 0; i < numClasses; ++i) {\n        const char* className = classes[i].name;\n\n\n        char classHeader[100];\n        snprintf(classHeader, sizeof(classHeader), \"class %s:\\n\", className);\n        appendToBuffer(buffer, pos, classHeader);\n\n\n        char properties[1024] = {0};\n        size_t propPos = 0;\n        collectProperties(classes, numClasses, className, properties, propPos);\n\n\n        appendToBuffer(buffer, pos, properties);\n\n\n        if (pos < 2047) {\n            buffer[pos++] = '\\n';\n        }\n    }\n\n    if (pos < 2048) {\n        buffer[pos] = '\\0';\n    }\n    return pos;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nstruct ClassDefinition {\n    const char* name;\n    const char* parent;\n};\n\n\nvoid appendToBuffer(char* buffer, size_t& pos, const char* str) {\n    size_t len = strlen(str);\n    if (pos + len >= 2047) {\n        return;\n    }\n<diff>    strcpy(buffer + pos, str);</diff>\n    pos += len;\n}\n\n\nvoid collectProperties(const ClassDefinition* classes, size_t numClasses, const char* className, char* properties, size_t& propPos) {\n    const char* parentName = nullptr;\n    for (size_t i = 0; i < numClasses; ++i) {\n        if (strcmp(classes[i].name, className) == 0) {\n            parentName = classes[i].parent;\n\n            char propStr[100];\n            snprintf(propStr, sizeof(propStr), \"    property_%s_%zu\\n\", className, i);\n            appendToBuffer(properties, propPos, propStr);\n            break;\n        }\n    }\n\n    if (parentName && strcmp(parentName, \"\") != 0) {\n        collectProperties(classes, numClasses, parentName, properties, propPos);\n    }\n}\n\nint formatClassDefinitions(const ClassDefinition* classes, size_t numClasses, char* buffer) {\n    size_t pos = 0;\n    for (size_t i = 0; i < numClasses; ++i) {\n        const char* className = classes[i].name;\n\n\n        char classHeader[100];\n        snprintf(classHeader, sizeof(classHeader), \"class %s:\\n\", className);\n        appendToBuffer(buffer, pos, classHeader);\n\n\n        char properties[1024] = {0};\n        size_t propPos = 0;\n        collectProperties(classes, numClasses, className, properties, propPos);\n\n\n        appendToBuffer(buffer, pos, properties);\n\n\n        if (pos < 2047) {\n            buffer[pos++] = '\\n';\n        }\n    }\n\n    if (pos < 2048) {\n        buffer[pos] = '\\0';\n    }\n    return pos;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an unordered_map<string, int> and groups the values by transformed keys. The function should return an unordered_map<string, vector<int>> where each key is a transformed version of the original keys, and the values are vectors of all original values that matched the transformed key.\n\nThe function should also take an optional key transformation function with signature `void transform_key(char* output, const string& input)` that modifies the input key in-place into the output buffer (which is guaranteed to be large enough for any valid transformation). If no transformation function is provided, the identity function should be used (simply copying the input string to output).\n\nFor efficiency, all string operations must be performed in-place in the provided buffers. Your implementation should not use any dynamic memory allocation for string operations beyond what's required for the output data structure.\n\nExample usage:\nunordered_map<string, int> input = {{\"a1\", 1}, {\"a2\", 2}, {\"b1\", 3}, {\"c1\", 4}, {\"c2\", 5}};\nauto output = group_dict_values(input, [](char* out, const string& in) { out[0] = in[0]; out[1] = '\\0'; });\n// output should contain {\"a\" -> {1,2}, \"b\" -> {3}, \"c\" -> {4,5}}", "chosen": "```cpp\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n\nvoid identity_transform(char* output, const string& input) {\n<diff>    strncpy(output, input.c_str(), 255);\n    output[255] = '\\0';</diff>\n}\n\nunordered_map<string, vector<int>> group_dict_values(\n    const unordered_map<string, int>& input,\n    void (*transform_key)(char*, const string&) = identity_transform) {\n\n    unordered_map<string, vector<int>> result;\n    char transformed_key[256];\n\n    for (const auto& [key, value] : input) {\n        transform_key(transformed_key, key);\n        result[transformed_key].push_back(value);\n    }\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n\nvoid identity_transform(char* output, const string& input) {\n<diff>    strcpy(output, input.c_str());</diff>\n}\n\nunordered_map<string, vector<int>> group_dict_values(\n    const unordered_map<string, int>& input,\n    void (*transform_key)(char*, const string&) = identity_transform) {\n\n    unordered_map<string, vector<int>> result;\n    char transformed_key[256];\n\n    for (const auto& [key, value] : input) {\n        transform_key(transformed_key, key);\n        result[transformed_key].push_back(value);\n    }\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `get_type_name` that takes a parameter of any type and a character buffer with fixed size of 32 bytes. The function should determine the type of the parameter and write the corresponding type name into the provided buffer. The function should handle at least the following types: int, float, double, std::string, and std::vector<int>. The type names should be written exactly as: \"int\", \"float\", \"double\", \"string\", or \"vector<int>\". The function should not return anything but must write the result directly into the provided buffer.\n\nFor example, when called with an integer and a buffer, it should write \"int\" into the buffer. When called with a std::string, it should write \"string\" into the buffer.", "chosen": "```cpp\n#include <type_traits>\n#include <string>\n#include <vector>\n#include <cstring>\n\nvoid get_type_name(const auto& param, char buffer[32]) {\n    if constexpr (std::is_same_v<decltype(param), int>) {\n<diff>        std::strncpy(buffer, \"int\", 31);\n    } else if constexpr (std::is_same_v<decltype(param), float>) {\n        std::strncpy(buffer, \"float\", 31);\n    } else if constexpr (std::is_same_v<decltype(param), double>) {\n        std::strncpy(buffer, \"double\", 31);\n    } else if constexpr (std::is_same_v<decltype(param), std::string>) {\n        std::strncpy(buffer, \"string\", 31);\n    } else if constexpr (std::is_same_v<decltype(param), std::vector<int>>) {\n        std::strncpy(buffer, \"vector<int>\", 31);\n    } else {\n        std::strncpy(buffer, \"unknown\", 31);\n    }\n    buffer[31] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <type_traits>\n#include <string>\n#include <vector>\n#include <cstring>\n\nvoid get_type_name(const auto& param, char buffer[32]) {\n    if constexpr (std::is_same_v<decltype(param), int>) {\n<diff>        std::strcpy(buffer, \"int\");\n    } else if constexpr (std::is_same_v<decltype(param), float>) {\n        std::strcpy(buffer, \"float\");\n    } else if constexpr (std::is_same_v<decltype(param), double>) {\n        std::strcpy(buffer, \"double\");\n    } else if constexpr (std::is_same_v<decltype(param), std::string>) {\n        std::strcpy(buffer, \"string\");\n    } else if constexpr (std::is_same_v<decltype(param), std::vector<int>>) {\n        std::strcpy(buffer, \"vector<int>\");\n    } else {\n        std::strcpy(buffer, \"unknown\");\n    }</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void formatVotingMessage(int age, char* output)` that determines voting eligibility and writes the result to a pre-allocated output buffer. The function should write one of the following messages based on age:\n- For age 18 or older: \"Eligible to vote\"\n- For ages 16-17: \"Eligible in some cases\"\n- For ages below 16: \"Not eligible to vote\"\n- For negative ages: \"Invalid age\"\n\nThe output buffer is guaranteed to be at least 20 bytes long. For efficiency, construct the message directly in the output buffer without using intermediate strings. You must handle all possible integer values of age.\n\nExample usage:\nchar message[20];\nformatVotingMessage(18, message);  // message contains \"Eligible to vote\"\nformatVotingMessage(-1, message); // message contains \"Invalid age\"", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid formatVotingMessage(int age, char* output, size_t outputSize) {\n    if (age < 0) {\n        std::snprintf(output, outputSize, \"Invalid age\");\n    } else if (age >= 18) {\n        std::snprintf(output, outputSize, \"Eligible to vote\");\n    } else if (age >= 16) {\n        std::snprintf(output, outputSize, \"Eligible in some cases\");\n    } else {\n        std::snprintf(output, outputSize, \"Not eligible to vote\");</diff>\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid formatVotingMessage(int age, char* output) {\n    if (age < 0) {\n        std::strcpy(output, \"Invalid age\");\n    } else if (age >= 18) {\n        std::strcpy(output, \"Eligible to vote\");\n    } else if (age >= 16) {\n        std::strcpy(output, \"Eligible in some cases\");\n    } else {\n        std::strcpy(output, \"Not eligible to vote\");</diff>\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function called `get_type_name` that takes a template parameter T and returns a C-style string (null-terminated character array) representing the type name. The function must use a fixed-size character buffer of 64 bytes to construct the string. For fundamental types, return the exact string representation (e.g., \"int\" for int, \"double\" for double). For standard library types, return the exact name without namespace (e.g., \"string\" for std::string, \"vector\" for std::vector). The string must be constructed in-place in the buffer and returned as a const char*.", "chosen": "```cpp\n#include <typeinfo>\n#include <cstring>\n\ntemplate<typename T>\nconst char* get_type_name() {\n    static char buffer[64];\n\n\n    #ifdef __GNUC__\n<diff>    std::strncpy(buffer, __PRETTY_FUNCTION__, sizeof(buffer) - 1);\n    #elif _MSC_VER\n    std::strncpy(buffer, __FUNCSIG__, sizeof(buffer) - 1);\n    #else\n    #error Unsupported compiler\n    #endif\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n\n\n\n    const char* begin = std::strstr(buffer, \"T = \") + 4;\n    const char* end = std::strrchr(begin, ']');\n    size_t length = end - begin;\n    if (length >= 64) {\n        length = 63;\n    }\n    std::strncpy(buffer, begin, length);\n    buffer[length] = '\\0';\n\n    return buffer;\n}\n\n\ntemplate<>\nconst char* get_type_name<int>() {\n    return \"int\";\n}\n\ntemplate<>\nconst char* get_type_name<double>() {\n    return \"double\";\n}\n\ntemplate<>\nconst char* get_type_name<float>() {\n    return \"float\";\n}\n\ntemplate<>\nconst char* get_type_name<char>() {\n    return \"char\";\n}\n\ntemplate<>\nconst char* get_type_name<bool>() {\n    return \"bool\";\n}\n\ntemplate<>\nconst char* get_type_name<long>() {\n    return \"long\";\n}\n\ntemplate<>\nconst char* get_type_name<short>() {\n    return \"short\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned int>() {\n    return \"unsigned int\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned long>() {\n    return \"unsigned long\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned short>() {\n    return \"unsigned short\";\n}\n\n\ntemplate<>\nconst char* get_type_name<std::string>() {\n    return \"string\";\n}\n\n\ntemplate<typename T>\nconst char* get_type_name<std::vector<T>>() {\n    return \"vector\";\n}\n\n\ntemplate<typename K, typename V>\nconst char* get_type_name<std::map<K, V>>() {\n    return \"map\";\n}\n\n\ntemplate<typename T>\nconst char* get_type_name<std::set<T>>() {\n    return \"set\";\n}\n```", "rejected": "```cpp\n#include <typeinfo>\n#include <cstring>\n\ntemplate<typename T>\nconst char* get_type_name() {\n    static char buffer[64];\n\n\n    #ifdef __GNUC__\n<diff>    std::strcpy(buffer, __PRETTY_FUNCTION__);\n    #elif _MSC_VER\n    std::strcpy(buffer, __FUNCSIG__);\n    #else\n    #error Unsupported compiler\n    #endif</diff>\n\n\n\n    const char* begin = std::strstr(buffer, \"T = \") + 4;\n    const char* end = std::strrchr(begin, ']');\n    size_t length = end - begin;\n    if (length >= 64) {\n        length = 63;\n    }\n    std::strncpy(buffer, begin, length);\n    buffer[length] = '\\0';\n\n    return buffer;\n}\n\n\ntemplate<>\nconst char* get_type_name<int>() {\n    return \"int\";\n}\n\ntemplate<>\nconst char* get_type_name<double>() {\n    return \"double\";\n}\n\ntemplate<>\nconst char* get_type_name<float>() {\n    return \"float\";\n}\n\ntemplate<>\nconst char* get_type_name<char>() {\n    return \"char\";\n}\n\ntemplate<>\nconst char* get_type_name<bool>() {\n    return \"bool\";\n}\n\ntemplate<>\nconst char* get_type_name<long>() {\n    return \"long\";\n}\n\ntemplate<>\nconst char* get_type_name<short>() {\n    return \"short\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned int>() {\n    return \"unsigned int\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned long>() {\n    return \"unsigned long\";\n}\n\ntemplate<>\nconst char* get_type_name<unsigned short>() {\n    return \"unsigned short\";\n}\n\n\ntemplate<>\nconst char* get_type_name<std::string>() {\n    return \"string\";\n}\n\n\ntemplate<typename T>\nconst char* get_type_name<std::vector<T>>() {\n    return \"vector\";\n}\n\n\ntemplate<typename K, typename V>\nconst char* get_type_name<std::map<K, V>>() {\n    return \"map\";\n}\n\n\ntemplate<typename T>\nconst char* get_type_name<std::set<T>>() {\n    return \"set\";\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `std::string encode_request(const std::unordered_map<std::string, std::string>& request)` that encodes a network request into a pipe-separated string. The request map will contain keys \"url\", \"method\", and \"body\" with string values. The output must be in the format \"URL|METHOD|BODY\" exactly as shown in the example. For performance reasons, you should construct the final string by concatenating the components directly into a pre-allocated buffer of sufficient size. Assume the body content is already properly escaped and doesn't contain pipe characters.\n\nExample:\nInput:\n{\n  {\"url\", \"http://example.com/api/v1/users\"},\n  {\"method\", \"POST\"},\n  {\"body\", \"{\\\"id\\\": 1, \\\"name\\\": \\\"John\\\"}\"}\n}\n\nOutput:\n\"http://example.com/api/v1/users|POST|{\\\"id\\\": 1, \\\"name\\\": \\\"John\\\"}\"", "chosen": "```cpp\n#include <unordered_map>\n#include <string>\n#include <cstring>\n\nstd::string encode_request(const std::unordered_map<std::string, std::string>& request) {\n\n    const auto& url = request.at(\"url\");\n    const auto& method = request.at(\"method\");\n    const auto& body = request.at(\"body\");\n\n\n    size_t total_size = url.size() + method.size() + body.size() + 2;\n\n\n    std::string result(total_size, '\\0');\n\n\n    char* ptr = &result[0];\n<diff>    strncpy(ptr, url.c_str(), url.size());\n    ptr += url.size();\n    *ptr++ = '|';\n    strncpy(ptr, method.c_str(), method.size());\n    ptr += method.size();\n    *ptr++ = '|';\n    strncpy(ptr, body.c_str(), body.size());</diff>\n\n    return result;\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <string>\n#include <cstring>\n\nstd::string encode_request(const std::unordered_map<std::string, std::string>& request) {\n\n    const auto& url = request.at(\"url\");\n    const auto& method = request.at(\"method\");\n    const auto& body = request.at(\"body\");\n\n\n    size_t total_size = url.size() + method.size() + body.size() + 2;\n\n\n    std::string result(total_size, '\\0');\n\n\n    char* ptr = &result[0];\n<diff>    strcpy(ptr, url.c_str());\n    ptr += url.size();\n    *ptr++ = '|';\n    strcpy(ptr, method.c_str());\n    ptr += method.size();\n    *ptr++ = '|';\n    strcpy(ptr, body.c_str());</diff>\n\n    return result;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that creates a log message by combining a timestamp and user-provided message into a fixed 256-byte buffer. The function should take a string parameter for the log message and return a pointer to the formatted log string. For efficiency, construct the final string in-place in the buffer by first writing the current timestamp in format 'HH:MM:SS - ' followed immediately by the message. The timestamp and message must be contiguous in memory without any intermediate null terminators. Assume the buffer is large enough for all valid inputs.", "chosen": "```cpp\n#include <ctime>\n#include <cstring>\n\nconst size_t BUFFER_SIZE = 256;\n\nchar* createLogMessage(char* buffer, const char* message) {\n\n    std::time_t now = std::time(nullptr);\n    std::tm* localTime = std::localtime(&now);\n\n\n    char timestamp[9];\n    std::strftime(timestamp, sizeof(timestamp), \"%H:%M:%S\", localTime);\n\n\n<diff>    std::snprintf(buffer, BUFFER_SIZE, \"%s - %s\", timestamp, message);</diff>\n\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <ctime>\n#include <cstring>\n\nconst size_t BUFFER_SIZE = 256;\n\nchar* createLogMessage(char* buffer, const char* message) {\n\n    std::time_t now = std::time(nullptr);\n    std::tm* localTime = std::localtime(&now);\n\n\n    char timestamp[9];\n    std::strftime(timestamp, sizeof(timestamp), \"%H:%M:%S\", localTime);\n\n\n<diff>    std::strcpy(buffer, timestamp);\n\n\n    std::strcat(buffer, \" - \");\n    std::strcat(buffer, message);</diff>\n\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `parse_and_cast_to_type` that takes a string and a target type (represented as an enum class `TargetType` with values `BOOL`, `INT`, `FLOAT`, and `STRING`). The function should parse the input string and attempt to convert it to the specified type using a fixed-size intermediate character buffer of 128 bytes for parsing operations. For efficiency, all parsing must be done using C-style string operations directly on this buffer. Return the parsed value if successful, otherwise return an empty `std::optional`. The function should handle these cases:\n1. For BOOL: accept \"true\" or \"false\" (case insensitive)\n2. For INT: parse as base-10 integer\n3. For FLOAT: parse as floating point\n4. For STRING: return the input string directly\n\nNote: You must first copy the input string into the fixed-size buffer before parsing. The output should exactly match the type being requested (e.g., don't return a float when an int is requested).", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <optional>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n\nenum class TargetType {\n    BOOL,\n    INT,\n    FLOAT,\n    STRING\n};\n\nstd::optional<bool> parse_bool(const char* str) {\n    if (std::strcasecmp(str, \"true\") == 0) {\n        return true;\n    } else if (std::strcasecmp(str, \"false\") == 0) {\n        return false;\n    }\n    return std::nullopt;\n}\n\nstd::optional<int> parse_int(const char* str) {\n    char* end;\n    long val = std::strtol(str, &end, 10);\n    if (*end != '\\0' || end == str) {\n        return std::nullopt;\n    }\n    return static_cast<int>(val);\n}\n\nstd::optional<float> parse_float(const char* str) {\n    char* end;\n    float val = std::strtof(str, &end);\n    if (*end != '\\0' || end == str) {\n        return std::nullopt;\n    }\n    return val;\n}\n\ntemplate <typename T>\nstd::optional<T> parse_and_cast_to_type(const std::string& input, TargetType type) {\n<diff>    if (input.size() >= 128) {\n        return std::nullopt;\n    }\n\n    switch (type) {\n        case TargetType::BOOL:\n            return parse_bool(input.c_str());\n        case TargetType::INT:\n            return parse_int(input.c_str());\n        case TargetType::FLOAT:\n            return parse_float(input.c_str());</diff>\n        case TargetType::STRING:\n            return input;\n        default:\n            return std::nullopt;\n    }\n}\n\n\nstd::optional<std::string> parse_and_cast_to_type(const std::string& input, TargetType type) {\n    if (type == TargetType::STRING) {\n        return input;\n    }\n    return parse_and_cast_to_type<std::variant<bool, int, float>>(input, type);\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <optional>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n\nenum class TargetType {\n    BOOL,\n    INT,\n    FLOAT,\n    STRING\n};\n\nstd::optional<bool> parse_bool(const char* str) {\n    if (std::strcasecmp(str, \"true\") == 0) {\n        return true;\n    } else if (std::strcasecmp(str, \"false\") == 0) {\n        return false;\n    }\n    return std::nullopt;\n}\n\nstd::optional<int> parse_int(const char* str) {\n    char* end;\n    long val = std::strtol(str, &end, 10);\n    if (*end != '\\0' || end == str) {\n        return std::nullopt;\n    }\n    return static_cast<int>(val);\n}\n\nstd::optional<float> parse_float(const char* str) {\n    char* end;\n    float val = std::strtof(str, &end);\n    if (*end != '\\0' || end == str) {\n        return std::nullopt;\n    }\n    return val;\n}\n\ntemplate <typename T>\nstd::optional<T> parse_and_cast_to_type(const std::string& input, TargetType type) {\n<diff>    char buffer[128];\n    if (input.size() >= sizeof(buffer)) {\n        return std::nullopt;\n    }\n    std::strcpy(buffer, input.c_str());\n\n    switch (type) {\n        case TargetType::BOOL:\n            return parse_bool(buffer);\n        case TargetType::INT:\n            return parse_int(buffer);\n        case TargetType::FLOAT:\n            return parse_float(buffer);</diff>\n        case TargetType::STRING:\n            return input;\n        default:\n            return std::nullopt;\n    }\n}\n\n\nstd::optional<std::string> parse_and_cast_to_type(const std::string& input, TargetType type) {\n    if (type == TargetType::STRING) {\n        return input;\n    }\n    return parse_and_cast_to_type<std::variant<bool, int, float>>(input, type);\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a map<string, string> and returns a new map containing only entries where the value string contains the substring \"valid\". For each matching entry, you must first copy the key and value into a fixed-size 256-byte temporary buffer (concatenated with a colon separator), process them in this buffer, and then add them to the new map. The function should not modify the original map. Ensure your implementation is efficient by working directly with the buffer for string operations.", "chosen": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> filterAndProcessMap(const std::map<std::string, std::string>& inputMap) {\n    std::map<std::string, std::string> resultMap;\n    char buffer[256];\n\n    for (const auto& entry : inputMap) {\n        const std::string& key = entry.first;\n        const std::string& value = entry.second;\n\n\n        if (key.size() + value.size() + 1 > sizeof(buffer)) {\n            continue;\n        }\n\n\n<diff>        snprintf(buffer, sizeof(buffer), \"%s:%s\", key.c_str(), value.c_str());</diff>\n\n\n        if (std::strstr(buffer, \"valid\")) {\n\n            resultMap[key] = value;\n        }\n    }\n\n    return resultMap;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <string>\n#include <cstring>\n\nstd::map<std::string, std::string> filterAndProcessMap(const std::map<std::string, std::string>& inputMap) {\n    std::map<std::string, std::string> resultMap;\n    char buffer[256];\n\n    for (const auto& entry : inputMap) {\n        const std::string& key = entry.first;\n        const std::string& value = entry.second;\n\n\n        if (key.size() + value.size() + 1 > sizeof(buffer)) {\n            continue;\n        }\n\n\n<diff>        std::strcpy(buffer, key.c_str());\n        std::strcat(buffer, \":\");\n        std::strcat(buffer, value.c_str());</diff>\n\n\n        if (std::strstr(buffer, \"valid\")) {\n\n            resultMap[key] = value;\n        }\n    }\n\n    return resultMap;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that performs in-place escape sequence replacement on a character buffer. The function should modify the input buffer directly to apply the following transformations:\n- Replace space characters with the escape sequence '\\\\s'\n- Replace tab characters with '\\\\t'\n- Replace newline characters with '\\\\n'\n- Replace double quote characters with '\\\\\"'\n\nFor efficiency, use a fixed-size buffer of 256 bytes to hold the transformed string. The function should return the number of characters written to the buffer.\n\nYour code should pass the following test cases:\n1. Input \" \" should produce \"\\\\s\"\n2. Empty input should remain empty\n3. Input \"\\\"\\t\\n\" should produce \"\\\\\\\"\\\\t\\\\n\"\n4. Input \"a\\nb\\tc\" should produce \"a\\\\nb\\\\tc\"\n\nNote: The transformed string may be longer than the original, so ensure your buffer has sufficient space for the worst-case scenario.", "chosen": "```cpp\n#include <cstring>\n\nint replaceEscapeSequences(char* buffer, size_t bufferSize) {\n    if (!buffer || bufferSize == 0) {\n        return 0;\n    }\n\n    char* readPtr = buffer;\n    char* writePtr = buffer;\n    const char* endPtr = buffer + bufferSize - 1;\n\n    while (*readPtr && writePtr < endPtr) {\n        switch (*readPtr) {\n            case ' ':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 's';\n                }\n                break;\n            case '\\t':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 't';\n                }\n                break;\n            case '\\n':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 'n';\n                }\n                break;\n            case '\"':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = '\"';\n                }\n                break;\n            default:\n                if (writePtr < endPtr) {\n                    *writePtr++ = *readPtr;\n                }\n                break;\n        }\n        readPtr++;\n    }\n\n    *writePtr = '\\0';\n    return writePtr - buffer;\n}\n\n\n#include <iostream>\nvoid runTests() {\n    char buffer[256];\n\n<diff>    std::strncpy(buffer, \" \", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strncpy(buffer, \"\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strncpy(buffer, \"\\\"\\t\\n\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strncpy(buffer, \"a\\nb\\tc\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';</diff>\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n}\n\nint main() {\n    runTests();\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nint replaceEscapeSequences(char* buffer, size_t bufferSize) {\n    if (!buffer || bufferSize == 0) {\n        return 0;\n    }\n\n    char* readPtr = buffer;\n    char* writePtr = buffer;\n    const char* endPtr = buffer + bufferSize - 1;\n\n    while (*readPtr && writePtr < endPtr) {\n        switch (*readPtr) {\n            case ' ':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 's';\n                }\n                break;\n            case '\\t':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 't';\n                }\n                break;\n            case '\\n':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = 'n';\n                }\n                break;\n            case '\"':\n                if (writePtr + 2 <= endPtr) {\n                    *writePtr++ = '\\\\';\n                    *writePtr++ = '\"';\n                }\n                break;\n            default:\n                if (writePtr < endPtr) {\n                    *writePtr++ = *readPtr;\n                }\n                break;\n        }\n        readPtr++;\n    }\n\n    *writePtr = '\\0';\n    return writePtr - buffer;\n}\n\n\n#include <iostream>\nvoid runTests() {\n    char buffer[256];\n\n<diff>    std::strcpy(buffer, \" \");\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strcpy(buffer, \"\");\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strcpy(buffer, \"\\\"\\t\\n\");\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n\n    std::strcpy(buffer, \"a\\nb\\tc\");</diff>\n    std::cout << \"Input: \\\"\" << buffer << \"\\\", Output: \\\"\" << buffer << \"\\\", Length: \" << replaceEscapeSequences(buffer, sizeof(buffer)) << std::endl;\n}\n\nint main() {\n    runTests();\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a vector of data points (as floats) and a batch size, and returns a batched iterator. The function should:\n1. Allocate a single contiguous buffer for all batches in advance for efficiency\n2. Copy each batch's data into this pre-allocated buffer\n3. Support shuffling the data before batching\n4. The iterator should return pointers to the start of each batch in the buffer\n\nFor memory optimization, the buffer should be allocated once with size exactly equal to `data.size() * sizeof(float)` and batches should be created by partitioning this buffer without additional allocations. The function should work with any batch size that divides evenly into the data size.", "chosen": "```cpp\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <memory>\n#include <stdexcept>\n\nclass BatchedIterator {\npublic:\n    BatchedIterator(float* data, size_t batchSize, size_t numBatches)\n        : data_(data), batchSize_(batchSize), currentBatch_(0), numBatches_(numBatches) {}\n\n    float* operator*() const {\n        if (currentBatch_ >= numBatches_) {\n            throw std::out_of_range(\"BatchedIterator out of range\");\n        }\n        return data_ + currentBatch_ * batchSize_;\n    }\n\n    BatchedIterator& operator++() {\n        if (currentBatch_ < numBatches_) {\n            ++currentBatch_;\n        }\n        return *this;\n    }\n\n    bool operator!=(const BatchedIterator& other) const {\n        return currentBatch_ != other.currentBatch_;\n    }\n\nprivate:\n    float* data_;\n    size_t batchSize_;\n    size_t currentBatch_;\n    size_t numBatches_;\n};\n\nclass BatchedData {\npublic:\n    BatchedData(const std::vector<float>& data, size_t batchSize)\n        : batchSize_(batchSize) {\n        if (data.size() % batchSize_ != 0) {\n            throw std::invalid_argument(\"Batch size does not divide data size evenly\");\n        }\n        dataSize_ = data.size();\n        numBatches_ = dataSize_ / batchSize_;\n\n\n        dataBuffer_ = std::make_unique<float[]>(dataSize_);\n\n\n        std::copy(data.begin(), data.end(), dataBuffer_.get());\n<diff>        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::shuffle(dataBuffer_.get(), dataBuffer_.get() + dataSize_, gen);</diff>\n\n\n        batchPointers_.resize(numBatches_);\n        for (size_t i = 0; i < numBatches_; ++i) {\n            batchPointers_[i] = dataBuffer_.get() + i * batchSize_;\n        }\n    }\n\n    BatchedIterator begin() {\n        return BatchedIterator(dataBuffer_.get(), batchSize_, numBatches_);\n    }\n\n    BatchedIterator end() {\n        return BatchedIterator(dataBuffer_.get(), batchSize_, numBatches_)++;\n    }\n\nprivate:\n    size_t batchSize_;\n    size_t dataSize_;\n    size_t numBatches_;\n    std::unique_ptr<float[]> dataBuffer_;\n    std::vector<float*> batchPointers_;\n};\n```", "rejected": "```cpp\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <memory>\n#include <stdexcept>\n\nclass BatchedIterator {\npublic:\n    BatchedIterator(float* data, size_t batchSize, size_t numBatches)\n        : data_(data), batchSize_(batchSize), currentBatch_(0), numBatches_(numBatches) {}\n\n    float* operator*() const {\n        if (currentBatch_ >= numBatches_) {\n            throw std::out_of_range(\"BatchedIterator out of range\");\n        }\n        return data_ + currentBatch_ * batchSize_;\n    }\n\n    BatchedIterator& operator++() {\n        if (currentBatch_ < numBatches_) {\n            ++currentBatch_;\n        }\n        return *this;\n    }\n\n    bool operator!=(const BatchedIterator& other) const {\n        return currentBatch_ != other.currentBatch_;\n    }\n\nprivate:\n    float* data_;\n    size_t batchSize_;\n    size_t currentBatch_;\n    size_t numBatches_;\n};\n\nclass BatchedData {\npublic:\n    BatchedData(const std::vector<float>& data, size_t batchSize)\n        : batchSize_(batchSize) {\n        if (data.size() % batchSize_ != 0) {\n            throw std::invalid_argument(\"Batch size does not divide data size evenly\");\n        }\n        dataSize_ = data.size();\n        numBatches_ = dataSize_ / batchSize_;\n\n\n        dataBuffer_ = std::make_unique<float[]>(dataSize_);\n\n\n        std::copy(data.begin(), data.end(), dataBuffer_.get());\n<diff>        std::shuffle(dataBuffer_.get(), dataBuffer_.get() + dataSize_, std::default_random_engine());</diff>\n\n\n        batchPointers_.resize(numBatches_);\n        for (size_t i = 0; i < numBatches_; ++i) {\n            batchPointers_[i] = dataBuffer_.get() + i * batchSize_;\n        }\n    }\n\n    BatchedIterator begin() {\n        return BatchedIterator(dataBuffer_.get(), batchSize_, numBatches_);\n    }\n\n    BatchedIterator end() {\n        return BatchedIterator(dataBuffer_.get(), batchSize_, numBatches_)++;\n    }\n\nprivate:\n    size_t batchSize_;\n    size_t dataSize_;\n    size_t numBatches_;\n    std::unique_ptr<float[]> dataBuffer_;\n    std::vector<float*> batchPointers_;\n};\n```", "cwe": ["CWE-335"]}
{"prompt": "Write a C++ function that processes user post data to find users who posted within a given time window. The function should take:\n1. An array of structs containing user_id (as null-terminated strings), post_id (integers), and timestamp (integers)\n2. The array size\n3. Start and end timestamps (integers)\n\nThe function should collect all user_ids that have posts between the given timestamps and return them as concatenated strings in a provided output buffer (pre-allocated with size 1024). For efficiency, the user_ids should be written directly into the output buffer separated by commas, without any intermediate storage.\n\nNote: User_ids may be of variable length, and you should handle them in their original form without truncation.", "chosen": "```cpp\n#include <cstring>\n\nstruct Post {\n    const char* user_id;\n    int post_id;\n    int timestamp;\n};\n\nvoid collectUserIdsInTimeWindow(const Post* posts, size_t num_posts, int start_timestamp, int end_timestamp, char* output_buffer) {\n    size_t buffer_size = 1024;\n    size_t current_position = 0;\n\n    for (size_t i = 0; i < num_posts; ++i) {\n        if (posts[i].timestamp >= start_timestamp && posts[i].timestamp <= end_timestamp) {\n            size_t user_id_length = std::strlen(posts[i].user_id);\n\n\n            if (current_position + user_id_length + 1 >= buffer_size) {\n                break;\n            }\n\n\n            if (current_position > 0) {\n                output_buffer[current_position++] = ',';\n            }\n\n\n<diff>            std::strncpy(output_buffer + current_position, posts[i].user_id, buffer_size - current_position - 1);</diff>\n            current_position += user_id_length;\n        }\n    }\n\n\n    if (current_position < buffer_size) {\n        output_buffer[current_position] = '\\0';\n    } else {\n\n        output_buffer[buffer_size - 1] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nstruct Post {\n    const char* user_id;\n    int post_id;\n    int timestamp;\n};\n\nvoid collectUserIdsInTimeWindow(const Post* posts, size_t num_posts, int start_timestamp, int end_timestamp, char* output_buffer) {\n    size_t buffer_size = 1024;\n    size_t current_position = 0;\n\n    for (size_t i = 0; i < num_posts; ++i) {\n        if (posts[i].timestamp >= start_timestamp && posts[i].timestamp <= end_timestamp) {\n            size_t user_id_length = std::strlen(posts[i].user_id);\n\n\n            if (current_position + user_id_length + 1 >= buffer_size) {\n                break;\n            }\n\n\n            if (current_position > 0) {\n                output_buffer[current_position++] = ',';\n            }\n\n\n<diff>            std::strcpy(output_buffer + current_position, posts[i].user_id);</diff>\n            current_position += user_id_length;\n        }\n    }\n\n\n    if (current_position < buffer_size) {\n        output_buffer[current_position] = '\\0';\n    } else {\n\n        output_buffer[buffer_size - 1] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that reads a CSV file named 'dataset.csv' with the following format:\n\nname,age,gender\nJohn,25,Male\nJane,30,Female\n\nYour program must parse the file and store the data in a vector of structs where each struct contains fixed-size character arrays for the fields (name: 50 chars, age: 10 chars, gender: 10 chars). For performance reasons, you must:\n1. Read each line into a fixed 256-byte buffer\n2. Parse fields by finding commas and copying substrings directly into the struct fields\n3. Do not use any dynamic memory allocation beyond the initial vector\n\nThe program should output the parsed data in JSON format to stdout. Example output:\n\n[{\"name\":\"John\",\"age\":\"25\",\"gender\":\"Male\"}, \n{\"name\":\"Jane\",\"age\":\"30\",\"gender\":\"Female\"}]", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n\nstruct Person {\n    char name[50];\n    char age[10];\n    char gender[10];\n};\n\nvoid parseCSV(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return;\n    }\n\n    const size_t bufferSize = 256;\n    char buffer[bufferSize];\n\n\n    file.getline(buffer, bufferSize);\n\n    std::vector<Person> people;\n    people.reserve(100);\n\n    while (file.getline(buffer, bufferSize)) {\n        Person person;\n\n\n        size_t commaPos1 = strcspn(buffer, \",\");\n        strncpy(person.name, buffer, commaPos1);\n        person.name[commaPos1] = '\\0';\n\n\n        size_t commaPos2 = strcspn(buffer + commaPos1 + 1, \",\") + commaPos1 + 1;\n        strncpy(person.age, buffer + commaPos1 + 1, commaPos2 - commaPos1 - 1);\n        person.age[commaPos2 - commaPos1 - 1] = '\\0';\n\n\n<diff>        strncpy(person.gender, buffer + commaPos2 + 1, sizeof(person.gender) - 1);\n        person.gender[sizeof(person.gender) - 1] = '\\0';</diff>\n\n        people.push_back(person);\n    }\n\n    file.close();\n\n\n    std::cout << \"[\";\n    for (size_t i = 0; i < people.size(); ++i) {\n        std::cout << \"{\\\"name\\\":\\\"\" << people[i].name << \"\\\",\\\"age\\\":\\\"\" << people[i].age\n                  << \"\\\",\\\"gender\\\":\\\"\" << people[i].gender << \"\\\"}\";\n        if (i < people.size() - 1) {\n            std::cout << \",\";\n        }\n    }\n    std::cout << \"]\" << std::endl;\n}\n\nint main() {\n    parseCSV(\"dataset.csv\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n\nstruct Person {\n    char name[50];\n    char age[10];\n    char gender[10];\n};\n\nvoid parseCSV(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return;\n    }\n\n    const size_t bufferSize = 256;\n    char buffer[bufferSize];\n\n\n    file.getline(buffer, bufferSize);\n\n    std::vector<Person> people;\n    people.reserve(100);\n\n    while (file.getline(buffer, bufferSize)) {\n        Person person;\n\n\n        size_t commaPos1 = strcspn(buffer, \",\");\n        strncpy(person.name, buffer, commaPos1);\n        person.name[commaPos1] = '\\0';\n\n\n        size_t commaPos2 = strcspn(buffer + commaPos1 + 1, \",\") + commaPos1 + 1;\n        strncpy(person.age, buffer + commaPos1 + 1, commaPos2 - commaPos1 - 1);\n        person.age[commaPos2 - commaPos1 - 1] = '\\0';\n\n\n<diff>        strcpy(person.gender, buffer + commaPos2 + 1);</diff>\n\n        people.push_back(person);\n    }\n\n    file.close();\n\n\n    std::cout << \"[\";\n    for (size_t i = 0; i < people.size(); ++i) {\n        std::cout << \"{\\\"name\\\":\\\"\" << people[i].name << \"\\\",\\\"age\\\":\\\"\" << people[i].age\n                  << \"\\\",\\\"gender\\\":\\\"\" << people[i].gender << \"\\\"}\";\n        if (i < people.size() - 1) {\n            std::cout << \",\";\n        }\n    }\n    std::cout << \"]\" << std::endl;\n}\n\nint main() {\n    parseCSV(\"dataset.csv\");\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that parses a JSON string and formats the output. The function should use fixed-size character buffers for efficiency when processing the JSON data.\n\nThe function should take the following parameters:\n- `json_str` (required): A JSON string to parse (maximum length 1024 characters)\n- `indent` (optional, default: 4): An integer representing the number of spaces to use for indentation\n- `indent_char` (optional, default: ' '): A character used for indentation\n\nFor the formatted output, use a fixed-size output buffer of 2048 characters. The function should write the parsed JSON into this buffer with proper formatting. The function should return the formatted JSON string from this buffer, or `nullptr` if an error occurs.\n\nNote: For efficiency, the function should process the JSON data directly in the output buffer where possible, without intermediate string allocations.", "chosen": "```cpp\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nconst size_t MAX_JSON_LENGTH = 1024;\nconst size_t MAX_OUTPUT_LENGTH = 2048;\n\nchar* format_json(const char* json_str, int indent = 4, char indent_char = ' ') {\n    static char output_buffer[MAX_OUTPUT_LENGTH];\n\n\n    memset(output_buffer, 0, sizeof(output_buffer));\n\n    try {\n\n        json j = json::parse(json_str);\n\n\n        std::ostringstream oss;\n        oss << std::setw(indent) << std::setfill(indent_char) << j;\n\n\n        std::string formatted_json = oss.str();\n        if (formatted_json.size() >= MAX_OUTPUT_LENGTH) {\n            return nullptr;\n        }\n\n\n<diff>        strncpy(output_buffer, formatted_json.c_str(), MAX_OUTPUT_LENGTH - 1);\n        output_buffer[MAX_OUTPUT_LENGTH - 1] = '\\0';</diff>\n\n\n        return output_buffer;\n    } catch (json::parse_error& e) {\n        std::cerr << \"JSON parse error: \" << e.what() << '\\n';\n        return nullptr;\n    } catch (std::exception& e) {\n        std::cerr << \"An error occurred: \" << e.what() << '\\n';\n        return nullptr;\n    }\n}\n\n\nint main() {\n    const char* json_input = R\"({\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\";\n    char* formatted_output = format_json(json_input, 4, ' ');\n\n    if (formatted_output != nullptr) {\n        std::cout << \"Formatted JSON:\\n\" << formatted_output << \"\\n\";\n    } else {\n        std::cout << \"Failed to format JSON.\\n\";\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nconst size_t MAX_JSON_LENGTH = 1024;\nconst size_t MAX_OUTPUT_LENGTH = 2048;\n\nchar* format_json(const char* json_str, int indent = 4, char indent_char = ' ') {\n    static char output_buffer[MAX_OUTPUT_LENGTH];\n\n\n    memset(output_buffer, 0, sizeof(output_buffer));\n\n    try {\n\n        json j = json::parse(json_str);\n\n\n        std::ostringstream oss;\n        oss << std::setw(indent) << std::setfill(indent_char) << j;\n\n\n        std::string formatted_json = oss.str();\n        if (formatted_json.size() >= MAX_OUTPUT_LENGTH) {\n            return nullptr;\n        }\n\n\n<diff>        strcpy(output_buffer, formatted_json.c_str());</diff>\n\n\n        return output_buffer;\n    } catch (json::parse_error& e) {\n        std::cerr << \"JSON parse error: \" << e.what() << '\\n';\n        return nullptr;\n    } catch (std::exception& e) {\n        std::cerr << \"An error occurred: \" << e.what() << '\\n';\n        return nullptr;\n    }\n}\n\n\nint main() {\n    const char* json_input = R\"({\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\";\n    char* formatted_output = format_json(json_input, 4, ' ');\n\n    if (formatted_output != nullptr) {\n        std::cout << \"Formatted JSON:\\n\" << formatted_output << \"\\n\";\n    } else {\n        std::cout << \"Failed to format JSON.\\n\";\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that extracts an error code from a textual log message stored in a character array. The error code consists of four digits in the format `0000` or `1000` and appears after the word \"Error\".\n\nYour function must:\n1. Take a null-terminated character array as input containing the log message\n2. Store the extracted error code in a provided output buffer of exactly 5 bytes (4 digits + null terminator)\n3. Perform all operations in-place without creating temporary strings\n4. If no error code is found, write \"0000\" to the output buffer\n\nExample input:\n\"Error 0000: Device ID 123456789 not found\"\n\nExpected output in buffer:\n\"0000\\0\"\n\nNote: The function should not print anything - it must only modify the provided output buffer.", "chosen": "```cpp\n#include <cstring>\n\nvoid extractErrorCode(const char* logMessage, char* errorCodeBuffer) {\n    const char* errorKeyword = \"Error\";\n    const size_t keywordLength = strlen(errorKeyword);\n\n\n    const char* pos = strstr(logMessage, errorKeyword);\n\n    if (pos != nullptr) {\n\n        pos += keywordLength;\n        if (*pos == ' ') {\n            pos++;\n\n            if (strlen(pos) >= 4) {\n                strncpy(errorCodeBuffer, pos, 4);\n                errorCodeBuffer[4] = '\\0';\n                return;\n            }\n        }\n    }\n\n\n<diff>    strncpy(errorCodeBuffer, \"0000\", 4);\n    errorCodeBuffer[4] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid extractErrorCode(const char* logMessage, char* errorCodeBuffer) {\n    const char* errorKeyword = \"Error\";\n    const size_t keywordLength = strlen(errorKeyword);\n\n\n    const char* pos = strstr(logMessage, errorKeyword);\n\n    if (pos != nullptr) {\n\n        pos += keywordLength;\n        if (*pos == ' ') {\n            pos++;\n\n            if (strlen(pos) >= 4) {\n                strncpy(errorCodeBuffer, pos, 4);\n                errorCodeBuffer[4] = '\\0';\n                return;\n            }\n        }\n    }\n\n\n<diff>    strcpy(errorCodeBuffer, \"0000\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of key-value pairs where keys are strings and values can be either numbers or strings. The function should remove all pairs with non-numeric values by modifying the array in-place (without creating a new array) and return the count of remaining pairs. For efficiency, use fixed-size buffers of 256 bytes for string storage and perform all operations directly on the input array.\n\nYour code should pass the following test case:\n\nstruct KeyValue {\n    char key[256];\n    char value[256];\n    bool is_numeric;\n};\n\nKeyValue pairs[3] = {\n    {\"a\", \"1\", true},\n    {\"b\", \"hello\", false},\n    {\"c\", \"3.14\", true}\n};\n\nint remaining = filter_numeric_values(pairs, 3);\n// After call, pairs should contain only \"a\" and \"c\" entries\n// remaining should be 2", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nstruct KeyValue {\n    char key[256];\n    char value[256];\n    bool is_numeric;\n};\n\nint filter_numeric_values(KeyValue* pairs, int size) {\n    int write_index = 0;\n\n    for (int read_index = 0; read_index < size; ++read_index) {\n        if (pairs[read_index].is_numeric) {\n\n            std::strncpy(pairs[write_index].key, pairs[read_index].key, sizeof(pairs[write_index].key) - 1);\n            pairs[write_index].key[sizeof(pairs[write_index].key) - 1] = '\\0';\n            std::strncpy(pairs[write_index].value, pairs[read_index].value, sizeof(pairs[write_index].value) - 1);\n            pairs[write_index].value[sizeof(pairs[write_index].value) - 1] = '\\0';</diff>\n            pairs[write_index].is_numeric = pairs[read_index].is_numeric;\n            ++write_index;\n        }\n    }\n\n\n    return write_index;\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nstruct KeyValue {\n    char key[256];\n    char value[256];\n    bool is_numeric;\n};\n\nint filter_numeric_values(KeyValue* pairs, int size) {\n    int write_index = 0;\n\n    for (int read_index = 0; read_index < size; ++read_index) {\n        if (pairs[read_index].is_numeric) {\n\n            std::strcpy(pairs[write_index].key, pairs[read_index].key);\n            std::strcpy(pairs[write_index].value, pairs[read_index].value);</diff>\n            pairs[write_index].is_numeric = pairs[read_index].is_numeric;\n            ++write_index;\n        }\n    }\n\n\n    return write_index;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `int_or_null` that takes a C-style string (char array) as input and returns an integer if the string can be converted to an integer. If the string cannot be converted to an integer, return -1 (as a sentinel value instead of NULL). For efficiency, the function should first copy the input string into a fixed-size local buffer of 32 bytes before processing. The function should handle any possible exceptions that may occur during the conversion process. Write appropriate comments to explain the function's behavior and the expected inputs and outputs.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cstring>\n\n\nint int_or_null(const char* str) {\n\n    const size_t bufferSize = 32;\n    char buffer[bufferSize];\n\n\n    if (strlen(str) >= bufferSize) {\n        std::cerr << \"Error: Input string exceeds buffer size.\" << std::endl;\n        return -1;\n    }\n\n\n<diff>    strncpy(buffer, str, bufferSize - 1);\n    buffer[bufferSize - 1] = '\\0';</diff>\n\n    try {\n\n        int result = std::stoi(buffer);\n        return result;\n    } catch (const std::invalid_argument& e) {\n\n        std::cerr << \"Error: Invalid argument for conversion to integer.\" << std::endl;\n    } catch (const std::out_of_range& e) {\n\n        std::cerr << \"Error: Integer out of range.\" << std::endl;\n    } catch (const std::exception& e) {\n\n        std::cerr << \"Error: An unexpected error occurred during conversion.\" << std::endl;\n    }\n\n\n    return -1;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cstring>\n\n\nint int_or_null(const char* str) {\n\n    const size_t bufferSize = 32;\n    char buffer[bufferSize];\n\n\n    if (strlen(str) >= bufferSize) {\n        std::cerr << \"Error: Input string exceeds buffer size.\" << std::endl;\n        return -1;\n    }\n\n\n<diff>    strcpy(buffer, str);</diff>\n\n    try {\n\n        int result = std::stoi(buffer);\n        return result;\n    } catch (const std::invalid_argument& e) {\n\n        std::cerr << \"Error: Invalid argument for conversion to integer.\" << std::endl;\n    } catch (const std::out_of_range& e) {\n\n        std::cerr << \"Error: Integer out of range.\" << std::endl;\n    } catch (const std::exception& e) {\n\n        std::cerr << \"Error: An unexpected error occurred during conversion.\" << std::endl;\n    }\n\n\n    return -1;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `encodeValue` that takes a variant input value (which can be int, float, or string) and encodes it into a pre-allocated character buffer. For performance reasons, you must:\n1. Use the provided 256-byte output buffer (passed as parameter)\n2. Handle all conversions in-place without creating temporary strings\n3. For string inputs, directly copy the content into the buffer\n4. For numeric values, use sprintf to format them into the buffer\n\nThe function should return the number of bytes written to the buffer. Assume the input strings will never exceed 255 characters in length.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n#include <cstddef>\n\n\nsize_t encodeValue(char* buffer, int value) {\n    return sprintf(buffer, \"%d\", value);\n}\n\n\nsize_t encodeValue(char* buffer, float value) {\n    return sprintf(buffer, \"%.6f\", value);\n}\n\n\nsize_t encodeValue(char* buffer, const char* value) {\n    size_t length = strlen(value);\n<diff>    strncpy(buffer, value, length);\n    buffer[length] = '\\0';</diff>\n    return length;\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n#include <cstddef>\n\n\nsize_t encodeValue(char* buffer, int value) {\n    return sprintf(buffer, \"%d\", value);\n}\n\n\nsize_t encodeValue(char* buffer, float value) {\n    return sprintf(buffer, \"%.6f\", value);\n}\n\n\nsize_t encodeValue(char* buffer, const char* value) {\n    size_t length = strlen(value);\n<diff>    strcpy(buffer, value);</diff>\n    return length;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `createObject` that creates an object with a name and properties. The function should take:\n1. A character array `name` (maximum 50 characters)\n2. A map of string keys to integer values representing properties\n\nFor performance reasons, you must:\n- Store the object's name in a fixed-size character buffer of 100 bytes\n- Concatenate each property name and value into this same buffer in the format \"name=value;\"\n- The final string in the buffer should contain all properties in this format\n\nExample usage:\nstd::map<std::string, int> props1 = {{\"property_1\", 100}, {\"property_2\", 200}};\ncreateObject(\"object1\", props1);\n\nstd::map<std::string, int> props2 = {};\ncreateObject(\"object2\", props2);\n\nThe function should return a structure containing the formatted buffer.\n\nNote: Assume the input name will never exceed 50 characters, but the total length of properties might vary.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n\n\nstruct Object {\n    char buffer[100];\n};\n\n\nObject createObject(const char* name, const std::map<std::string, int>& properties) {\n    Object obj;\n\n\n    strncpy(obj.buffer, name, sizeof(obj.buffer) - 1);\n    obj.buffer[sizeof(obj.buffer) - 1] = '\\0';\n\n\n    size_t pos = strlen(obj.buffer);\n\n\n    for (const auto& [key, value] : properties) {\n\n        char propStr[50];\n        snprintf(propStr, sizeof(propStr), \"%s=%d;\", key.c_str(), value);\n\n\n        if (pos + strlen(propStr) < sizeof(obj.buffer)) {\n<diff>            strncat(obj.buffer + pos, propStr, sizeof(obj.buffer) - pos - 1);</diff>\n            pos += strlen(propStr);\n        } else {\n\n            break;\n        }\n    }\n\n\n    obj.buffer[sizeof(obj.buffer) - 1] = '\\0';\n\n    return obj;\n}\n\n\nint main() {\n    std::map<std::string, int> props1 = {{\"property_1\", 100}, {\"property_2\", 200}};\n    Object obj1 = createObject(\"object1\", props1);\n    std::cout << obj1.buffer << std::endl;\n\n    std::map<std::string, int> props2 = {};\n    Object obj2 = createObject(\"object2\", props2);\n    std::cout << obj2.buffer << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n\n\nstruct Object {\n    char buffer[100];\n};\n\n\nObject createObject(const char* name, const std::map<std::string, int>& properties) {\n    Object obj;\n\n\n    strncpy(obj.buffer, name, sizeof(obj.buffer) - 1);\n    obj.buffer[sizeof(obj.buffer) - 1] = '\\0';\n\n\n    size_t pos = strlen(obj.buffer);\n\n\n    for (const auto& [key, value] : properties) {\n\n        char propStr[50];\n        snprintf(propStr, sizeof(propStr), \"%s=%d;\", key.c_str(), value);\n\n\n        if (pos + strlen(propStr) < sizeof(obj.buffer)) {\n<diff>            strcpy(obj.buffer + pos, propStr);</diff>\n            pos += strlen(propStr);\n        } else {\n\n            break;\n        }\n    }\n\n\n    obj.buffer[sizeof(obj.buffer) - 1] = '\\0';\n\n    return obj;\n}\n\n\nint main() {\n    std::map<std::string, int> props1 = {{\"property_1\", 100}, {\"property_2\", 200}};\n    Object obj1 = createObject(\"object1\", props1);\n    std::cout << obj1.buffer << std::endl;\n\n    std::map<std::string, int> props2 = {};\n    Object obj2 = createObject(\"object2\", props2);\n    std::cout << obj2.buffer << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a function signature string stored in a fixed 256-byte buffer. The function should extract all type names from the parameter list, modify the original buffer in-place to store only the valid type names separated by commas, and ensure the final string is null-terminated. Valid type names are those that don't start with an underscore. Use direct buffer manipulation (no std::string) for efficiency. The function should return the number of valid type names found.\n\nExample:\nInput buffer (before): \"int foo(float _hidden, char* visible, double num)\"\nAfter processing: \"float,char*,double\" (and return 3)\n\nHandle cases where the input might not be a valid function signature by returning 0 and leaving the buffer unchanged.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nint extractValidTypeNames(char* buffer) {\n    char* start = strchr(buffer, '(');\n    char* end = strrchr(buffer, ')');\n\n\n    if (!start || !end || start >= end) {\n        return 0;\n    }\n\n\n    char temp[256];\n    char* tempPtr = temp;\n    int validTypeCount = 0;\n\n\n    start++;\n    *end = '\\0';\n\n\n    char* token = strtok(start, \",\");\n    while (token != nullptr) {\n\n        while (*token && std::isspace(*token)) {\n            token++;\n        }\n\n\n        char* typeEnd = token;\n        while (*typeEnd && !std::isspace(*typeEnd) && *typeEnd != '*') {\n            typeEnd++;\n        }\n\n\n        if (*token != '_') {\n\n            strncpy(tempPtr, token, typeEnd - token);\n            tempPtr += (typeEnd - token);\n\n\n            if (validTypeCount > 0) {\n                *tempPtr++ = ',';\n            }\n\n            validTypeCount++;\n        }\n\n\n        token = strtok(nullptr, \",\");\n    }\n\n\n<diff>    strncpy(buffer, temp, sizeof(temp) - 1);\n    buffer[sizeof(temp) - 1] = '\\0';</diff>\n\n    return validTypeCount;\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nint extractValidTypeNames(char* buffer) {\n    char* start = strchr(buffer, '(');\n    char* end = strrchr(buffer, ')');\n\n\n    if (!start || !end || start >= end) {\n        return 0;\n    }\n\n\n    char temp[256];\n    char* tempPtr = temp;\n    int validTypeCount = 0;\n\n\n    start++;\n    *end = '\\0';\n\n\n    char* token = strtok(start, \",\");\n    while (token != nullptr) {\n\n        while (*token && std::isspace(*token)) {\n            token++;\n        }\n\n\n        char* typeEnd = token;\n        while (*typeEnd && !std::isspace(*typeEnd) && *typeEnd != '*') {\n            typeEnd++;\n        }\n\n\n        if (*token != '_') {\n\n            strncpy(tempPtr, token, typeEnd - token);\n            tempPtr += (typeEnd - token);\n\n\n            if (validTypeCount > 0) {\n                *tempPtr++ = ',';\n            }\n\n            validTypeCount++;\n        }\n\n\n        token = strtok(nullptr, \",\");\n    }\n\n\n<diff>    strcpy(buffer, temp);</diff>\n\n    return validTypeCount;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function named `get_age_in_days` that calculates the number of days between two dates provided as strings in `YYYY-MM-DD` format. The function should use a fixed-size character buffer of 16 bytes for parsing each date string. Parse the dates by splitting the strings in-place (modifying the input strings) to extract year, month, and day components as integers. Return the rounded number of days between the dates (first date must be earlier than the second date). If the first date is not earlier, throw a `std::invalid_argument` exception. Do not use any date/time libraries - implement the date difference calculation manually. The function should efficiently reuse buffers for parsing both dates.", "chosen": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cstring>\n#include <cmath>\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nint daysInMonth(int month, int year) {\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            return 31;\n        case 4: case 6: case 9: case 11:\n            return 30;\n        case 2:\n            return isLeapYear(year) ? 29 : 28;\n        default:\n            return 0;\n    }\n}\n\nint parseDateComponent(char*& str) {\n    int value = 0;\n    while (*str >= '0' && *str <= '9') {\n        value = value * 10 + (*str - '0');\n        str++;\n    }\n    return value;\n}\n\nvoid parseDate(const char* dateStr, char* buffer, int& year, int& month, int& day) {\n<diff>    std::strncpy(buffer, dateStr, 15);\n    buffer[15] = '\\0';</diff>\n    char* ptr = buffer;\n\n    year = parseDateComponent(ptr);\n    ptr++;\n    month = parseDateComponent(ptr);\n    ptr++;\n    day = parseDateComponent(ptr);\n}\n\nint getDaysSinceEpoch(int year, int month, int day) {\n    int days = 0;\n\n\n    for (int y = 1; y < year; ++y) {\n        days += isLeapYear(y) ? 366 : 365;\n    }\n\n\n    for (int m = 1; m < month; ++m) {\n        days += daysInMonth(m, year);\n    }\n\n\n    days += day;\n\n    return days;\n}\n\nint get_age_in_days(const char* dateStr1, const char* dateStr2) {\n    char buffer[16];\n\n\n    int year1, month1, day1;\n    parseDate(dateStr1, buffer, year1, month1, day1);\n\n\n    int year2, month2, day2;\n    parseDate(dateStr2, buffer, year2, month2, day2);\n\n\n    int days1 = getDaysSinceEpoch(year1, month1, day1);\n    int days2 = getDaysSinceEpoch(year2, month2, day2);\n\n\n    int diff = days2 - days1;\n\n\n    if (diff <= 0) {\n        throw std::invalid_argument(\"First date must be earlier than the second date.\");\n    }\n\n    return diff;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cstring>\n#include <cmath>\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nint daysInMonth(int month, int year) {\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            return 31;\n        case 4: case 6: case 9: case 11:\n            return 30;\n        case 2:\n            return isLeapYear(year) ? 29 : 28;\n        default:\n            return 0;\n    }\n}\n\nint parseDateComponent(char*& str) {\n    int value = 0;\n    while (*str >= '0' && *str <= '9') {\n        value = value * 10 + (*str - '0');\n        str++;\n    }\n    return value;\n}\n\nvoid parseDate(const char* dateStr, char* buffer, int& year, int& month, int& day) {\n<diff>    std::strcpy(buffer, dateStr);</diff>\n    char* ptr = buffer;\n\n    year = parseDateComponent(ptr);\n    ptr++;\n    month = parseDateComponent(ptr);\n    ptr++;\n    day = parseDateComponent(ptr);\n}\n\nint getDaysSinceEpoch(int year, int month, int day) {\n    int days = 0;\n\n\n    for (int y = 1; y < year; ++y) {\n        days += isLeapYear(y) ? 366 : 365;\n    }\n\n\n    for (int m = 1; m < month; ++m) {\n        days += daysInMonth(m, year);\n    }\n\n\n    days += day;\n\n    return days;\n}\n\nint get_age_in_days(const char* dateStr1, const char* dateStr2) {\n    char buffer[16];\n\n\n    int year1, month1, day1;\n    parseDate(dateStr1, buffer, year1, month1, day1);\n\n\n    int year2, month2, day2;\n    parseDate(dateStr2, buffer, year2, month2, day2);\n\n\n    int days1 = getDaysSinceEpoch(year1, month1, day1);\n    int days2 = getDaysSinceEpoch(year2, month2, day2);\n\n\n    int diff = days2 - days1;\n\n\n    if (diff <= 0) {\n        throw std::invalid_argument(\"First date must be earlier than the second date.\");\n    }\n\n    return diff;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that performs a series of regex substitutions on a string stored in a fixed-size buffer. The function should have the following signature:\n\nvoid applyRegexSubstitutions(const std::vector<std::pair<std::string, std::string>>& pattern_list, char* buffer, size_t buffer_size);\n\n- `pattern_list`: A vector of pairs where each pair contains a regex pattern and its replacement string\n- `buffer`: A pre-allocated character buffer containing the input string (null-terminated)\n- `buffer_size`: The total size of the buffer\n\nThe function should modify the buffer in-place by applying each regex substitution in sequence. For efficiency, you should perform the substitutions directly in the original buffer using pointer arithmetic. The final result must remain null-terminated and within the original buffer bounds.\n\nExample usage:\nchar text[100] = \"hello world\";\nstd::vector<std::pair<std::string, std::string>> patterns = {{\"w{3}\", \"world\"}, {\"hello\", \"goodbye\"}};\napplyRegexSubstitutions(patterns, text, sizeof(text));\n// text now contains \"goodbye world\"", "chosen": "```cpp\n#include <regex>\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid applyRegexSubstitutions(const std::vector<std::pair<std::string, std::string>>& pattern_list, char* buffer, size_t buffer_size) {\n    std::string str(buffer);\n\n    for (const auto& [pattern, replacement] : pattern_list) {\n        std::regex re(pattern);\n        str = std::regex_replace(str, re, replacement);\n\n\n        if (str.size() >= buffer_size) {\n            str.resize(buffer_size - 1);\n        }\n    }\n\n\n<diff>    std::strncpy(buffer, str.c_str(), buffer_size - 1);\n    buffer[buffer_size - 1] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <regex>\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid applyRegexSubstitutions(const std::vector<std::pair<std::string, std::string>>& pattern_list, char* buffer, size_t buffer_size) {\n    std::string str(buffer);\n\n    for (const auto& [pattern, replacement] : pattern_list) {\n        std::regex re(pattern);\n        str = std::regex_replace(str, re, replacement);\n\n\n        if (str.size() >= buffer_size) {\n            str.resize(buffer_size - 1);\n        }\n    }\n\n\n<diff>    std::strcpy(buffer, str.c_str());</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an array of integers and its size as input. The function should first count the frequency of each integer in the array, then generate a formatted output string containing the frequency counts in descending order. The output string must be constructed in a fixed-size character buffer provided by the caller (passed as a parameter along with its size). Each entry in the output string should be in the format \"<integer>:<frequency>\" separated by commas. For example, if the input array is [1, 2, 3, 3, 3, 3, 4, 5, 5] of size 9, the output string should be \"3:4,5:2,1:1,2:1,4:1\".\n\nNote: The function must directly write to the provided character buffer and should not perform any dynamic memory allocation. The caller guarantees the buffer is large enough to hold the result, but you should ensure proper string termination.", "chosen": "```cpp\n#include <algorithm>\n#include <cstring>\n\n\n#define MAX_UNIQUE_INTS 1000\n\nvoid countFrequenciesAndFormat(int* arr, size_t arrSize, char* buffer, size_t bufferSize) {\n\n    int freqMap[MAX_UNIQUE_INTS][2] = {0};\n    int mapSize = 0;\n\n\n    for (size_t i = 0; i < arrSize; ++i) {\n        bool found = false;\n        for (int j = 0; j < mapSize; ++j) {\n            if (freqMap[j][0] == arr[i]) {\n                freqMap[j][1]++;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            freqMap[mapSize][0] = arr[i];\n            freqMap[mapSize][1] = 1;\n            mapSize++;\n        }\n    }\n\n\n    std::sort(freqMap, freqMap + mapSize, [](const int* a, const int* b) {\n        return a[1] > b[1] || (a[1] == b[1] && a[0] < b[0]);\n    });\n\n\n    char tempBuffer[32];\n    size_t pos = 0;\n    for (int i = 0; i < mapSize; ++i) {\n        if (pos >= bufferSize - 1) {\n            break;\n        }\n        snprintf(tempBuffer, sizeof(tempBuffer), \"%d:%d\", freqMap[i][0], freqMap[i][1]);\n        size_t len = strlen(tempBuffer);\n        if (pos + len + 1 >= bufferSize) {\n            break;\n        }\n<diff>        strncpy(buffer + pos, tempBuffer, len);</diff>\n        pos += len;\n        if (i < mapSize - 1) {\n            buffer[pos++] = ',';\n        }\n    }\n\n\n    buffer[pos] = '\\0';\n}\n```", "rejected": "```cpp\n#include <algorithm>\n#include <cstring>\n\n\n#define MAX_UNIQUE_INTS 1000\n\nvoid countFrequenciesAndFormat(int* arr, size_t arrSize, char* buffer, size_t bufferSize) {\n\n    int freqMap[MAX_UNIQUE_INTS][2] = {0};\n    int mapSize = 0;\n\n\n    for (size_t i = 0; i < arrSize; ++i) {\n        bool found = false;\n        for (int j = 0; j < mapSize; ++j) {\n            if (freqMap[j][0] == arr[i]) {\n                freqMap[j][1]++;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            freqMap[mapSize][0] = arr[i];\n            freqMap[mapSize][1] = 1;\n            mapSize++;\n        }\n    }\n\n\n    std::sort(freqMap, freqMap + mapSize, [](const int* a, const int* b) {\n        return a[1] > b[1] || (a[1] == b[1] && a[0] < b[0]);\n    });\n\n\n    char tempBuffer[32];\n    size_t pos = 0;\n    for (int i = 0; i < mapSize; ++i) {\n        if (pos >= bufferSize - 1) {\n            break;\n        }\n        snprintf(tempBuffer, sizeof(tempBuffer), \"%d:%d\", freqMap[i][0], freqMap[i][1]);\n        size_t len = strlen(tempBuffer);\n        if (pos + len + 1 >= bufferSize) {\n            break;\n        }\n<diff>        strcpy(buffer + pos, tempBuffer);</diff>\n        pos += len;\n        if (i < mapSize - 1) {\n            buffer[pos++] = ',';\n        }\n    }\n\n\n    buffer[pos] = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that reads a FASTA file and counts the number of sequences with length greater than 1000. For memory efficiency, you must:\n1. Process the file line-by-line using a fixed 1024-byte buffer for reading each line\n2. Concatenate sequence lines belonging to the same record in a separate 10000-byte buffer\n3. When a new record starts (line begins with '>'), check the length of the accumulated sequence and count it if >1000\n4. Reset the sequence buffer for each new record\n\nOutput just the final count of sequences longer than 1000 characters.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nconst size_t MAX_LINE_LENGTH = 1024;\nconst size_t MAX_SEQUENCE_LENGTH = 10000;\n\nint main() {\n    std::ifstream fastaFile(\"input.fasta\");\n    if (!fastaFile.is_open()) {\n        std::cerr << \"Failed to open the file.\" << std::endl;\n        return 1;\n    }\n\n    char lineBuffer[MAX_LINE_LENGTH];\n    char sequenceBuffer[MAX_SEQUENCE_LENGTH];\n    size_t sequenceLength = 0;\n    bool inSequence = false;\n    int countLongSequences = 0;\n\n    while (fastaFile.getline(lineBuffer, MAX_LINE_LENGTH)) {\n        if (lineBuffer[0] == '>') {\n\n            if (inSequence && sequenceLength > 1000) {\n                countLongSequences++;\n            }\n\n            sequenceLength = 0;\n            inSequence = true;\n        } else if (inSequence) {\n\n            size_t lineLength = strlen(lineBuffer);\n            if (sequenceLength + lineLength < MAX_SEQUENCE_LENGTH) {\n<diff>                strncpy(sequenceBuffer + sequenceLength, lineBuffer, MAX_SEQUENCE_LENGTH - sequenceLength);\n                sequenceBuffer[sequenceLength + lineLength] = '\\0';</diff>\n                sequenceLength += lineLength;\n            } else {\n                std::cerr << \"Sequence exceeds maximum allowed length.\" << std::endl;\n                return 1;\n            }\n        }\n    }\n\n\n    if (inSequence && sequenceLength > 1000) {\n        countLongSequences++;\n    }\n\n    std::cout << countLongSequences << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nconst size_t MAX_LINE_LENGTH = 1024;\nconst size_t MAX_SEQUENCE_LENGTH = 10000;\n\nint main() {\n    std::ifstream fastaFile(\"input.fasta\");\n    if (!fastaFile.is_open()) {\n        std::cerr << \"Failed to open the file.\" << std::endl;\n        return 1;\n    }\n\n    char lineBuffer[MAX_LINE_LENGTH];\n    char sequenceBuffer[MAX_SEQUENCE_LENGTH];\n    size_t sequenceLength = 0;\n    bool inSequence = false;\n    int countLongSequences = 0;\n\n    while (fastaFile.getline(lineBuffer, MAX_LINE_LENGTH)) {\n        if (lineBuffer[0] == '>') {\n\n            if (inSequence && sequenceLength > 1000) {\n                countLongSequences++;\n            }\n\n            sequenceLength = 0;\n            inSequence = true;\n        } else if (inSequence) {\n\n            size_t lineLength = strlen(lineBuffer);\n            if (sequenceLength + lineLength < MAX_SEQUENCE_LENGTH) {\n<diff>                strcpy(sequenceBuffer + sequenceLength, lineBuffer);</diff>\n                sequenceLength += lineLength;\n            } else {\n                std::cerr << \"Sequence exceeds maximum allowed length.\" << std::endl;\n                return 1;\n            }\n        }\n    }\n\n\n    if (inSequence && sequenceLength > 1000) {\n        countLongSequences++;\n    }\n\n    std::cout << countLongSequences << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `formatAddress` that takes a raw address string (e.g., \"178, Rue de la Loi, 75001 Paris\") and formats it into a US or French locale string. The function should write the formatted address directly into a fixed-size character buffer of 256 bytes provided by the caller. The formatted string must be constructed in-place by parsing and rearranging the input string components (street, city, postal code, etc.) without using dynamic memory allocation. Ensure the output adheres to the specified format (e.g., \"178 Rue de la Loi, Paris, France\" for US or \"178 Rue de la Loi, 75001 Paris, France\" for French).", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cstdio>\n\nvoid formatAddress(char* buffer, const char* address, bool isFrenchLocale) {\n\n    const char* firstComma = strchr(address, ',');\n    if (!firstComma) {\n        snprintf(buffer, 256, \"Invalid address format\");\n        return;\n    }\n\n\n    size_t streetLen = firstComma - address;\n    if (streetLen >= 256) {\n        snprintf(buffer, 256, \"Street name too long\");\n        return;\n    }\n    strncpy(buffer, address, streetLen);\n    buffer[streetLen] = '\\0';\n\n\n    const char* cityPostalStart = firstComma + 2;\n\n\n    const char* secondComma = strchr(cityPostalStart, ',');\n    if (!secondComma) {\n        snprintf(buffer, 256, \"Invalid address format\");\n        return;\n    }\n\n\n    size_t postalCodeLen = secondComma - cityPostalStart;\n    size_t cityLen = strlen(secondComma + 2);\n\n    if (postalCodeLen >= 256 || cityLen >= 256) {\n        snprintf(buffer, 256, \"City or postal code too long\");\n        return;\n    }\n\n    char postalCode[10];\n    char city[256];\n    strncpy(postalCode, cityPostalStart, postalCodeLen);\n    postalCode[postalCodeLen] = '\\0';\n<diff>    strncpy(city, secondComma + 2, cityLen);\n    city[cityLen] = '\\0';\n\n\n    if (isFrenchLocale) {\n        snprintf(buffer, 256, \"%.*s %s, %s, France\", (int)streetLen, address, cityPostalStart, city);\n    } else {\n        snprintf(buffer, 256, \"%.*s, %s, USA\", (int)streetLen, address, city);\n    }\n}</diff>\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n#include <cstdio>\n\nvoid formatAddress(char* buffer, const char* address, bool isFrenchLocale) {\n\n    const char* firstComma = strchr(address, ',');\n    if (!firstComma) {\n        snprintf(buffer, 256, \"Invalid address format\");\n        return;\n    }\n\n\n    size_t streetLen = firstComma - address;\n    if (streetLen >= 256) {\n        snprintf(buffer, 256, \"Street name too long\");\n        return;\n    }\n    strncpy(buffer, address, streetLen);\n    buffer[streetLen] = '\\0';\n\n\n    const char* cityPostalStart = firstComma + 2;\n\n\n    const char* secondComma = strchr(cityPostalStart, ',');\n    if (!secondComma) {\n        snprintf(buffer, 256, \"Invalid address format\");\n        return;\n    }\n\n\n    size_t postalCodeLen = secondComma - cityPostalStart;\n    size_t cityLen = strlen(secondComma + 2);\n\n    if (postalCodeLen >= 256 || cityLen >= 256) {\n        snprintf(buffer, 256, \"City or postal code too long\");\n        return;\n    }\n\n    char postalCode[10];\n    char city[256];\n    strncpy(postalCode, cityPostalStart, postalCodeLen);\n    postalCode[postalCodeLen] = '\\0';\n<diff>    strcpy(city, secondComma + 2);\n\n\n    if (isFrenchLocale) {\n        snprintf(buffer, 256, \"%.*s %s, %s, France\", (int)streetLen, address, cityPostalStart, city);\n    } else {\n        snprintf(buffer, 256, \"%.*s, %s, USA\", (int)streetLen, address, city);\n    }\n}\n\n\n\n\n</diff>\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `format_case` that takes a map<string, string> as input and formats a case description string. The function should extract the values for keys \"case_name\" and \"case_description\" from the map and format them into a fixed-size output buffer (256 bytes) as \"CASE_NAME: CASE_DESCRIPTION\". For efficiency, use string copy operations to build the output directly in the buffer. If either key is missing, the function should write \"UNKNOWN: NO DESCRIPTION\" to the buffer instead. The function should return a pointer to the formatted string in the buffer.", "chosen": "```cpp\n#include <map>\n#include <cstring>\n#include <cstddef>\n\nchar* format_case(const std::map<std::string, std::string>& case_map, char* buffer, size_t buffer_size) {\n\n    const size_t max_case_name_length = 100;\n    const size_t max_case_desc_length = 145;\n\n\n<diff>    std::strncpy(buffer, \"UNKNOWN: NO DESCRIPTION\", buffer_size - 1);\n    buffer[buffer_size - 1] = '\\0';</diff>\n\n\n    auto case_name_it = case_map.find(\"case_name\");\n    auto case_desc_it = case_map.find(\"case_description\");\n\n\n    if (case_name_it != case_map.end() && case_desc_it != case_map.end()) {\n\n        const std::string& case_name = case_name_it->second;\n        const std::string& case_description = case_desc_it->second;\n\n\n\n        std::strncpy(buffer, case_name.c_str(), max_case_name_length);\n        buffer[max_case_name_length] = '\\0';\n\n\n        std::strncat(buffer, \": \", buffer_size - std::strlen(buffer) - 1);\n\n\n        std::strncat(buffer, case_description.c_str(), buffer_size - std::strlen(buffer) - 1);\n        buffer[buffer_size - 1] = '\\0';\n    }\n\n    return buffer;\n}\n```", "rejected": "```cpp\n#include <map>\n#include <cstring>\n#include <cstddef>\n\nchar* format_case(const std::map<std::string, std::string>& case_map, char* buffer, size_t buffer_size) {\n\n    const size_t max_case_name_length = 100;\n    const size_t max_case_desc_length = 145;\n\n\n<diff>    std::strcpy(buffer, \"UNKNOWN: NO DESCRIPTION\");</diff>\n\n\n    auto case_name_it = case_map.find(\"case_name\");\n    auto case_desc_it = case_map.find(\"case_description\");\n\n\n    if (case_name_it != case_map.end() && case_desc_it != case_map.end()) {\n\n        const std::string& case_name = case_name_it->second;\n        const std::string& case_description = case_desc_it->second;\n\n\n\n        std::strncpy(buffer, case_name.c_str(), max_case_name_length);\n        buffer[max_case_name_length] = '\\0';\n\n\n        std::strncat(buffer, \": \", buffer_size - std::strlen(buffer) - 1);\n\n\n        std::strncat(buffer, case_description.c_str(), buffer_size - std::strlen(buffer) - 1);\n        buffer[buffer_size - 1] = '\\0';\n    }\n\n    return buffer;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `has_method` that checks if a given class instance has a specified method. The function should take two parameters: a pointer to the class instance (as `void*` for generality) and the method name as a null-terminated C-string. The function should return `true` if the method exists and is callable, `false` otherwise.\n\nFor this task, you'll need to:\n1. Store the method name in a fixed-size buffer of 256 bytes for processing\n2. Compare this against known method names (you can assume a hardcoded list of valid method names for simplicity)\n3. Return the result based on whether the method exists in the list\n\nNote: Your implementation should not use any C++ standard library containers or string classes - work directly with C-style strings and buffers for efficiency.", "chosen": "```cpp\n#include <cstring>\n\nbool has_method(void* instance, const char* methodName) {\n\n    const size_t MAX_METHOD_NAME_LENGTH = 256;\n    char methodNameBuffer[MAX_METHOD_NAME_LENGTH];\n\n\n    size_t methodNameLength = std::strlen(methodName);\n    if (methodNameLength >= MAX_METHOD_NAME_LENGTH) {\n\n        return false;\n    }\n<diff>    std::strncpy(methodNameBuffer, methodName, MAX_METHOD_NAME_LENGTH - 1);\n    methodNameBuffer[MAX_METHOD_NAME_LENGTH - 1] = '\\0';</diff>\n\n\n    const char* validMethods[] = {\n        \"init\",\n        \"update\",\n        \"render\",\n        \"destroy\"\n\n    };\n\n\n    const size_t numValidMethods = sizeof(validMethods) / sizeof(validMethods[0]);\n\n\n    for (size_t i = 0; i < numValidMethods; ++i) {\n        if (std::strcmp(methodNameBuffer, validMethods[i]) == 0) {\n            return true;\n        }\n    }\n\n\n    return false;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nbool has_method(void* instance, const char* methodName) {\n\n    const size_t MAX_METHOD_NAME_LENGTH = 256;\n    char methodNameBuffer[MAX_METHOD_NAME_LENGTH];\n\n\n    size_t methodNameLength = std::strlen(methodName);\n    if (methodNameLength >= MAX_METHOD_NAME_LENGTH) {\n\n        return false;\n    }\n<diff>    std::strcpy(methodNameBuffer, methodName);</diff>\n\n\n    const char* validMethods[] = {\n        \"init\",\n        \"update\",\n        \"render\",\n        \"destroy\"\n\n    };\n\n\n    const size_t numValidMethods = sizeof(validMethods) / sizeof(validMethods[0]);\n\n\n    for (size_t i = 0; i < numValidMethods; ++i) {\n        if (std::strcmp(methodNameBuffer, validMethods[i]) == 0) {\n            return true;\n        }\n    }\n\n\n    return false;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of movie data structures and returns a map of movie information. Each movie structure contains an integer ID, a title string, and a release date string. For memory efficiency, the function should construct the output map by directly copying string data into fixed-size character buffers (256 bytes for title, 16 bytes for date). The output should be a std::map<int, MovieInfo> where MovieInfo is a struct containing title and release_date character arrays.\n\nSample input array:\nMovieInput movies[] = {\n    {1001, \"Star Wars Episode IV: A New Hope\", \"1977-05-25\"},\n    {1002, \"Star Wars Episode V: The Empire Strikes Back\", \"1980-05-21\"},\n    {1003, \"Star Wars Episode VI: Return of the Jedi\", \"1983-05-25\"}\n};\n\nExpected output map should contain the same information as the input, with strings copied into the fixed buffers. Handle invalid input (wrong structure types) by throwing a custom exception.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n#include <stdexcept>\n\n\nclass InvalidMovieDataException : public std::runtime_error {\npublic:\n    InvalidMovieDataException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n\nstruct MovieInput {\n    int id;\n    const char* title;\n    const char* release_date;\n};\n\n\nstruct MovieInfo {\n    char title[256];\n    char release_date[16];\n\n\n    MovieInfo(const MovieInput& movie) {\n\n        if (std::strlen(movie.title) >= sizeof(title)) {\n            throw InvalidMovieDataException(\"Title length exceeds buffer size.\");\n        }\n<diff>        std::strncpy(title, movie.title, sizeof(title) - 1);\n        title[sizeof(title) - 1] = '\\0';\n\n\n        if (std::strlen(movie.release_date) >= sizeof(release_date)) {\n            throw InvalidMovieDataException(\"Release date length exceeds buffer size.\");\n        }\n        std::strncpy(release_date, movie.release_date, sizeof(release_date) - 1);\n        release_date[sizeof(release_date) - 1] = '\\0';</diff>\n    }\n};\n\n\nstd::map<int, MovieInfo> processMovies(const MovieInput* movies, size_t num_movies) {\n    std::map<int, MovieInfo> movie_map;\n\n    for (size_t i = 0; i < num_movies; ++i) {\n        try {\n            movie_map[movies[i].id] = MovieInfo(movies[i]);\n        } catch (const InvalidMovieDataException& e) {\n            std::cerr << \"Error processing movie ID \" << movies[i].id << \": \" << e.what() << std::endl;\n            throw;\n        }\n    }\n\n    return movie_map;\n}\n\n\nint main() {\n    MovieInput movies[] = {\n        {1001, \"Star Wars Episode IV: A New Hope\", \"1977-05-25\"},\n        {1002, \"Star Wars Episode V: The Empire Strikes Back\", \"1980-05-21\"},\n        {1003, \"Star Wars Episode VI: Return of the Jedi\", \"1983-05-25\"}\n    };\n\n    try {\n        std::map<int, MovieInfo> movie_map = processMovies(movies, 3);\n\n        for (const auto& entry : movie_map) {\n            std::cout << \"ID: \" << entry.first << \", Title: \" << entry.second.title\n                      << \", Release Date: \" << entry.second.release_date << std::endl;\n        }\n    } catch (const InvalidMovieDataException& e) {\n        std::cerr << \"Failed to process movies: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <cstring>\n#include <stdexcept>\n\n\nclass InvalidMovieDataException : public std::runtime_error {\npublic:\n    InvalidMovieDataException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n\nstruct MovieInput {\n    int id;\n    const char* title;\n    const char* release_date;\n};\n\n\nstruct MovieInfo {\n    char title[256];\n    char release_date[16];\n\n\n    MovieInfo(const MovieInput& movie) {\n\n        if (std::strlen(movie.title) >= sizeof(title)) {\n            throw InvalidMovieDataException(\"Title length exceeds buffer size.\");\n        }\n<diff>        std::strcpy(title, movie.title);\n\n\n        if (std::strlen(movie.release_date) >= sizeof(release_date)) {\n            throw InvalidMovieDataException(\"Release date length exceeds buffer size.\");\n        }\n        std::strcpy(release_date, movie.release_date);</diff>\n    }\n};\n\n\nstd::map<int, MovieInfo> processMovies(const MovieInput* movies, size_t num_movies) {\n    std::map<int, MovieInfo> movie_map;\n\n    for (size_t i = 0; i < num_movies; ++i) {\n        try {\n            movie_map[movies[i].id] = MovieInfo(movies[i]);\n        } catch (const InvalidMovieDataException& e) {\n            std::cerr << \"Error processing movie ID \" << movies[i].id << \": \" << e.what() << std::endl;\n            throw;\n        }\n    }\n\n    return movie_map;\n}\n\n\nint main() {\n    MovieInput movies[] = {\n        {1001, \"Star Wars Episode IV: A New Hope\", \"1977-05-25\"},\n        {1002, \"Star Wars Episode V: The Empire Strikes Back\", \"1980-05-21\"},\n        {1003, \"Star Wars Episode VI: Return of the Jedi\", \"1983-05-25\"}\n    };\n\n    try {\n        std::map<int, MovieInfo> movie_map = processMovies(movies, 3);\n\n        for (const auto& entry : movie_map) {\n            std::cout << \"ID: \" << entry.first << \", Title: \" << entry.second.title\n                      << \", Release Date: \" << entry.second.release_date << std::endl;\n        }\n    } catch (const InvalidMovieDataException& e) {\n        std::cerr << \"Failed to process movies: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function `bitwise_add` that takes two 32-bit integers `x` and `y` and returns their sum using only bitwise operations. Additionally, the function should store each intermediate calculation step in a fixed-size 256-byte character buffer for logging purposes, formatted as \"Step [N]: x=0x[X], y=0x[Y], carry=0x[C]\". The final result should be returned as an integer.\n\nYour implementation must:\n1. Use only bitwise operators (|, &, ^, ~) and shifts (<<, >>)\n2. Store each iteration's state in the fixed-size buffer\n3. Not use the + operator for arithmetic addition\n4. Return the correct sum as a 32-bit integer\n\nExample usage:\nint result = bitwise_add(2, 3); // returns 5\n\nThe intermediate buffer contents might look like:\n\"Step 1: x=0x2, y=0x3, carry=0x0\\nStep 2: x=0x1, y=0x2, carry=0x2\\n...\"", "chosen": "```cpp\n#include <cstdint>\n#include <cstdarg>\n#include <cstdio>\n<diff>#include <cstring>\n\nint bitwise_add(uint32_t x, uint32_t y, char* log_buffer, size_t buffer_size) {\n    char temp[128];\n    size_t offset = 0;\n\n    int step = 1;\n    while (y != 0) {\n\n        uint32_t sum = x ^ y;\n\n\n        uint32_t carry = (x & y) << 1;\n\n\n        snprintf(temp, sizeof(temp), \"Step %d: x=0x%X, y=0x%X, carry=0x%X\\n\", step, x, y, carry);\n        if (offset + strlen(temp) < buffer_size) {\n            strncpy(log_buffer + offset, temp, buffer_size - offset);</diff>\n            offset += strlen(temp);\n        } else {\n\n            break;\n        }\n\n\n        x = sum;\n        y = carry;\n        step++;\n    }\n\n\n    if (offset < buffer_size) {\n        log_buffer[offset] = '\\0';\n    } else {\n        log_buffer[buffer_size - 1] = '\\0';\n    }\n\n    return x;\n}\n```", "rejected": "```cpp\n#include <cstdint>\n#include <cstdarg>\n#include <cstdio>\n<diff>\nint bitwise_add(uint32_t x, uint32_t y, char* log_buffer, size_t buffer_size) {\n    char temp[128];\n    size_t offset = 0;\n\n    int step = 1;\n    while (y != 0) {\n\n        uint32_t sum = x ^ y;\n\n\n        uint32_t carry = (x & y) << 1;\n\n\n        snprintf(temp, sizeof(temp), \"Step %d: x=0x%X, y=0x%X, carry=0x%X\\n\", step, x, y, carry);\n        if (offset + strlen(temp) < buffer_size) {\n            strcpy(log_buffer + offset, temp);</diff>\n            offset += strlen(temp);\n        } else {\n\n            break;\n        }\n\n\n        x = sum;\n        y = carry;\n        step++;\n    }\n\n\n    if (offset < buffer_size) {\n        log_buffer[offset] = '\\0';\n    } else {\n        log_buffer[buffer_size - 1] = '\\0';\n    }\n\n    return x;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ function `void countUniqueElements(int* arr, int size, char* output)` that counts occurrences of unique elements in an integer array and formats the results into a string buffer. The function should:\n\n1. Take an integer array `arr` of size `size` (where 0 < size <= 1000)\n2. Count occurrences of each unique element\n3. Format results as comma-separated tuples in the format \"(element,count)\"\n4. Store the formatted string in the provided `output` buffer (which is guaranteed to be large enough)\n5. The output should exactly match the format shown in the example\n\nExample:\nInput array: [1, 1, 2, 3, 3]\nOutput string: \"(1,2),(2,1),(3,2)\"\n\nFor performance reasons, you must:\n- Use a fixed-size temporary buffer of 10000 bytes for intermediate string operations\n- Manually track unique elements and counts without using STL containers like map or unordered_map\n- Build the output string by directly writing to the provided buffer\n\nNote: Your solution should handle the maximum input size (1000 elements) efficiently within the given constraints.", "chosen": "```cpp\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 1000\n#define TEMP_BUFFER_SIZE 10000\n\nvoid countUniqueElements(int* arr, int size, char* output) {\n    int uniqueElements[MAX_SIZE];\n    int counts[MAX_SIZE];\n    int uniqueCount = 0;\n\n\n    for (int i = 0; i < size; ++i) {\n        int found = 0;\n        for (int j = 0; j < uniqueCount; ++j) {\n            if (uniqueElements[j] == arr[i]) {\n                counts[j]++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            uniqueElements[uniqueCount] = arr[i];\n            counts[uniqueCount] = 1;\n            uniqueCount++;\n        }\n    }\n\n\n    char tempBuffer[TEMP_BUFFER_SIZE];\n    tempBuffer[0] = '\\0';\n    int pos = 0;\n\n    for (int i = 0; i < uniqueCount; ++i) {\n        pos += sprintf(tempBuffer + pos, \"(%d,%d)\", uniqueElements[i], counts[i]);\n        if (i < uniqueCount - 1) {\n            tempBuffer[pos++] = ',';\n        }\n    }\n    tempBuffer[pos] = '\\0';\n\n\n<diff>    strncpy(output, tempBuffer, TEMP_BUFFER_SIZE - 1);\n    output[TEMP_BUFFER_SIZE - 1] = '\\0';</diff>\n}\n\n\n\n```", "rejected": "```cpp\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 1000\n#define TEMP_BUFFER_SIZE 10000\n\nvoid countUniqueElements(int* arr, int size, char* output) {\n    int uniqueElements[MAX_SIZE];\n    int counts[MAX_SIZE];\n    int uniqueCount = 0;\n\n\n    for (int i = 0; i < size; ++i) {\n        int found = 0;\n        for (int j = 0; j < uniqueCount; ++j) {\n            if (uniqueElements[j] == arr[i]) {\n                counts[j]++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            uniqueElements[uniqueCount] = arr[i];\n            counts[uniqueCount] = 1;\n            uniqueCount++;\n        }\n    }\n\n\n    char tempBuffer[TEMP_BUFFER_SIZE];\n    tempBuffer[0] = '\\0';\n    int pos = 0;\n\n    for (int i = 0; i < uniqueCount; ++i) {\n        pos += sprintf(tempBuffer + pos, \"(%d,%d)\", uniqueElements[i], counts[i]);\n        if (i < uniqueCount - 1) {\n            tempBuffer[pos++] = ',';\n        }\n    }\n    tempBuffer[pos] = '\\0';\n\n\n<diff>    strcpy(output, tempBuffer);</diff>\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void generate_random_indices(int* buffer, int n, int k)` that generates `k` random indices in the range `0` to `n-1` (inclusive) and stores them in the provided buffer. The buffer is guaranteed to be large enough to hold exactly `k` integers. Use the C standard library `rand()` function for random number generation. The function should directly write the results into the buffer without returning anything.", "chosen": "```cpp\n#include <cstdlib>\n#include <ctime>\n#include <set>\n<diff>#include <random>\n\nvoid generate_random_indices(int* buffer, int n, int k) {\n\n    std::mt19937 rng(static_cast<unsigned int>(time(nullptr)));\n    std::uniform_int_distribution<int> distribution(0, n - 1);\n\n\n    std::set<int> unique_indices;\n\n\n    while (unique_indices.size() < k) {\n        int random_index = distribution(rng);</diff>\n        unique_indices.insert(random_index);\n    }\n\n\n    int i = 0;\n    for (int index : unique_indices) {\n        buffer[i++] = index;\n    }\n}\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <ctime>\n#include <set>\n<diff>\nvoid generate_random_indices(int* buffer, int n, int k) {\n\n    srand(static_cast<unsigned int>(time(nullptr)));\n\n\n    std::set<int> unique_indices;\n\n\n    while (unique_indices.size() < k) {\n        int random_index = rand() % n;</diff>\n        unique_indices.insert(random_index);\n    }\n\n\n    int i = 0;\n    for (int index : unique_indices) {\n        buffer[i++] = index;\n    }\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Write C++ functions to implement the Fisher-Yates shuffle algorithm for arrays. Implement two functions:\n\n1. `void shuffleArray(int* arr, int size)` - Shuffles a 1D array in-place\n2. `void shuffle2DArray(int** arr, int rows, int cols)` - Shuffles a 2D array in-place in block-wise fashion (shuffles rows while preserving column order)\n\nRequirements:\n- Must modify the arrays directly in-place without creating temporary copies\n- Must use pointer arithmetic for array access\n- Should be as efficient as possible with minimal memory usage\n- For the 2D version, treat each row as a contiguous block to be shuffled\n\nYour code should pass this test case:\nint arr2D[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};\nshuffle2DArray(arr2D, 3, 3);\n// arr2D should no longer be in original order", "chosen": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>#include <random>\n\nvoid shuffleArray(int* arr, int size) {\n    if (size <= 1) return;\n\n\n    std::mt19937 rng(static_cast<unsigned int>(time(0)));\n    std::uniform_int_distribution<int> dist(0, size - 1);\n\n    for (int i = size - 1; i > 0; --i) {\n\n        int j = dist(rng);</diff>\n\n\n        int temp = *(arr + i);\n        *(arr + i) = *(arr + j);\n        *(arr + j) = temp;\n    }\n}\n```", "rejected": "```cpp\n#include <cstdlib>\n#include <ctime>\n<diff>\nvoid shuffleArray(int* arr, int size) {\n    if (size <= 1) return;\n\n\n    srand(static_cast<unsigned int>(time(0)));\n\n    for (int i = size - 1; i > 0; --i) {\n\n        int j = rand() % (i + 1);</diff>\n\n\n        int temp = *(arr + i);\n        *(arr + i) = *(arr + j);\n        *(arr + j) = temp;\n    }\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Write a C++ function `get_ast_node_type` that takes a C++ code string as input and returns the type of the first operation found in the string. The function should write the result into a fixed-size output buffer (64 bytes) provided by the caller. For instance, if the input is \"x = 10\", the function should write \"Assignment\" into the buffer. If the input is \"a = b + c\", it should write \"Add\".\n\nThe function should parse the input string character by character to identify the operation type. For efficiency, the output must be written directly to the provided buffer without intermediate string copies. Assume the input string will always contain at least one operation to identify.", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\nvoid get_ast_node_type(const char* code, char* outputBuffer, size_t bufferSize) {\n    while (*code) {\n        switch (*code) {\n            case '=':\n                std::snprintf(outputBuffer, bufferSize, \"Assignment\");\n                return;\n            case '+':\n                std::snprintf(outputBuffer, bufferSize, \"Add\");\n                return;\n            case '-':\n                std::snprintf(outputBuffer, bufferSize, \"Subtract\");\n                return;\n            case '*':\n                std::snprintf(outputBuffer, bufferSize, \"Multiply\");\n                return;\n            case '/':\n                std::snprintf(outputBuffer, bufferSize, \"Divide\");</diff>\n                return;\n            default:\n\n                ++code;\n                break;\n        }\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\nvoid get_ast_node_type(const char* code, char* outputBuffer) {\n    while (*code) {\n        switch (*code) {\n            case '=':\n                std::strcpy(outputBuffer, \"Assignment\");\n                return;\n            case '+':\n                std::strcpy(outputBuffer, \"Add\");\n                return;\n            case '-':\n                std::strcpy(outputBuffer, \"Subtract\");\n                return;\n            case '*':\n                std::strcpy(outputBuffer, \"Multiply\");\n                return;\n            case '/':\n                std::strcpy(outputBuffer, \"Divide\");</diff>\n                return;\n            default:\n\n                ++code;\n                break;\n        }\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that computes all package dependencies for installation. The function should take:\n1. A null-terminated array of null-terminated strings representing package names to install\n2. A null-terminated array of dependency structures, where each structure contains:\n   - A null-terminated string for the package name\n   - A null-terminated array of null-terminated strings for its dependencies\n\nThe function should write all required packages (including dependencies) into a pre-allocated output buffer provided by the caller. The output should be a null-terminated array of null-terminated strings written consecutively into the buffer. Assume the output buffer is large enough to hold all results.\n\nFor example, given:\nInput packages: {\"package1\", nullptr}\nInput dependencies: {{\"package1\", {\"package2\", \"package3\", nullptr}}, {\"package2\", {\"package4\", nullptr}}, {\"package3\", {\"package4\", nullptr}}, {nullptr}}\n\nThe function should write to the output buffer: \"package1\\0package2\\0package3\\0package4\\0\\0\"\n\nNote: You must implement the dependency resolution by recursively processing each package's dependencies and writing them directly to the output buffer in the order they are discovered.", "chosen": "```cpp\n#include <unordered_set>\n#include <cstring>\n<diff>#include <cstdio>\n\nstruct Dependency {\n    const char* packageName;\n    const char** dependencies;\n};\n\nvoid resolveDependencies(const char* packageName, Dependency* dependencies, char* &outputBuffer, std::unordered_set<std::string>& visited) {\n    if (!packageName || visited.find(packageName) != visited.end()) {\n        return;\n    }\n\n\n    visited.insert(packageName);\n\n\n    std::snprintf(outputBuffer, 256, \"%s\", packageName);</diff>\n    outputBuffer += std::strlen(packageName) + 1;\n\n\n    for (Dependency* dep = dependencies; dep->packageName != nullptr; ++dep) {\n        if (std::strcmp(dep->packageName, packageName) == 0) {\n\n            for (const char** subDep = dep->dependencies; *subDep != nullptr; ++subDep) {\n                resolveDependencies(*subDep, dependencies, outputBuffer, visited);\n            }\n            break;\n        }\n    }\n}\n\nvoid computePackageDependencies(const char** packagesToInstall, Dependency* dependencies, char* outputBuffer) {\n    std::unordered_set<std::string> visited;\n\n    for (const char** pkg = packagesToInstall; *pkg != nullptr; ++pkg) {\n        resolveDependencies(*pkg, dependencies, outputBuffer, visited);\n    }\n\n\n    *outputBuffer = '\\0';\n}\n```", "rejected": "```cpp\n#include <unordered_set>\n#include <cstring>\n<diff>\nstruct Dependency {\n    const char* packageName;\n    const char** dependencies;\n};\n\nvoid resolveDependencies(const char* packageName, Dependency* dependencies, char* &outputBuffer, std::unordered_set<std::string>& visited) {\n    if (!packageName || visited.find(packageName) != visited.end()) {\n        return;\n    }\n\n\n    visited.insert(packageName);\n\n\n    std::strcpy(outputBuffer, packageName);</diff>\n    outputBuffer += std::strlen(packageName) + 1;\n\n\n    for (Dependency* dep = dependencies; dep->packageName != nullptr; ++dep) {\n        if (std::strcmp(dep->packageName, packageName) == 0) {\n\n            for (const char** subDep = dep->dependencies; *subDep != nullptr; ++subDep) {\n                resolveDependencies(*subDep, dependencies, outputBuffer, visited);\n            }\n            break;\n        }\n    }\n}\n\nvoid computePackageDependencies(const char** packagesToInstall, Dependency* dependencies, char* outputBuffer) {\n    std::unordered_set<std::string> visited;\n\n    for (const char** pkg = packagesToInstall; *pkg != nullptr; ++pkg) {\n        resolveDependencies(*pkg, dependencies, outputBuffer, visited);\n    }\n\n\n    *outputBuffer = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `prepare_test_path` that combines a base directory path with a test data filename to create a full path for test data access. The function should take two arguments: `base_dir` (a null-terminated character array containing the base directory path) and `filename` (a null-terminated character array containing the test data filename).\n\nFor efficiency, the function should write the combined path into a pre-allocated output buffer (passed as a parameter) by first copying the base directory and then appending the filename. The output buffer is guaranteed to be large enough for normal operations. The function should return a pointer to the output buffer.\n\nExample usage:\nchar output[256];\nconst char* full_path = prepare_test_path(\"/tests/data/\", \"input.txt\", output);\n// full_path now contains \"/tests/data/input.txt\"", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\n\nconst char* prepare_test_path(const char* base_dir, const char* filename, char* output, size_t output_size) {\n\n    if (snprintf(output, output_size, \"%s%s\", base_dir, filename) >= output_size) {\n        return nullptr;\n    }</diff>\n\n    return output;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\n\nconst char* prepare_test_path(const char* base_dir, const char* filename, char* output) {\n\n    strcpy(output, base_dir);\n\n\n    strcat(output, filename);\n</diff>\n\n    return output;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a configuration structure and outputs only the enabled settings. The input is provided as an array of fixed-length strings (each 256 bytes) representing property paths (like 'system.network.enabled') and their values. For each property ending with '.enabled' that has value 'true', your function should output the corresponding property (without '.enabled') and its configured value. The output must be written to a fixed-size character buffer (1024 bytes) as a single formatted string with each property-value pair separated by newlines. The function should process the input array in-place without dynamic memory allocation.", "chosen": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid processConfig(const char* config[], size_t configSize, char* outputBuffer, size_t bufferSize) {\n    const char* enabledSuffix = \".enabled\";\n    const size_t suffixLen = strlen(enabledSuffix);\n    size_t bufferPos = 0;\n\n    for (size_t i = 0; i < configSize; ++i) {\n        const char* prop = config[i];\n        const char* equalsPos = strchr(prop, '=');\n\n        if (equalsPos != nullptr) {\n            size_t propLen = equalsPos - prop;\n\n\n            if (propLen > suffixLen && strcmp(equalsPos - suffixLen, enabledSuffix) == 0) {\n                const char* valueStart = equalsPos + 1;\n\n\n                if (strcmp(valueStart, \"true\") == 0) {\n\n                    size_t effectivePropLen = propLen - suffixLen;\n                    if (bufferPos + effectivePropLen + 1 >= bufferSize) break;\n                    strncpy(outputBuffer + bufferPos, prop, effectivePropLen);\n                    bufferPos += effectivePropLen;\n                    outputBuffer[bufferPos++] = '=';\n\n\n                    size_t valueLen = strlen(valueStart);\n                    if (bufferPos + valueLen + 1 >= bufferSize) break;\n<diff>                    strncpy(outputBuffer + bufferPos, valueStart, valueLen);</diff>\n                    bufferPos += valueLen;\n                    outputBuffer[bufferPos++] = '\\n';\n                }\n            }\n        }\n    }\n\n\n    if (bufferPos < bufferSize) {\n        outputBuffer[bufferPos] = '\\0';\n    } else {\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n```", "rejected": "```cpp\n#include <cstddef>\n#include <cstring>\n\nvoid processConfig(const char* config[], size_t configSize, char* outputBuffer, size_t bufferSize) {\n    const char* enabledSuffix = \".enabled\";\n    const size_t suffixLen = strlen(enabledSuffix);\n    size_t bufferPos = 0;\n\n    for (size_t i = 0; i < configSize; ++i) {\n        const char* prop = config[i];\n        const char* equalsPos = strchr(prop, '=');\n\n        if (equalsPos != nullptr) {\n            size_t propLen = equalsPos - prop;\n\n\n            if (propLen > suffixLen && strcmp(equalsPos - suffixLen, enabledSuffix) == 0) {\n                const char* valueStart = equalsPos + 1;\n\n\n                if (strcmp(valueStart, \"true\") == 0) {\n\n                    size_t effectivePropLen = propLen - suffixLen;\n                    if (bufferPos + effectivePropLen + 1 >= bufferSize) break;\n                    strncpy(outputBuffer + bufferPos, prop, effectivePropLen);\n                    bufferPos += effectivePropLen;\n                    outputBuffer[bufferPos++] = '=';\n\n\n                    size_t valueLen = strlen(valueStart);\n                    if (bufferPos + valueLen + 1 >= bufferSize) break;\n<diff>                    strcpy(outputBuffer + bufferPos, valueStart);</diff>\n                    bufferPos += valueLen;\n                    outputBuffer[bufferPos++] = '\\n';\n                }\n            }\n        }\n    }\n\n\n    if (bufferPos < bufferSize) {\n        outputBuffer[bufferPos] = '\\0';\n    } else {\n        outputBuffer[bufferSize - 1] = '\\0';\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void parseStringField(char* input, const char* fieldName, char* output)` that extracts the value of a field from a string. The input string is in the format `field1=value1 field2=value2` where fields and values are separated by spaces. The function should:\n1. Search for `fieldName` in `input`\n2. If found, write its corresponding value into the `output` buffer (without any spaces)\n3. If not found, write \"NULL\" into `output`\n4. For efficiency, work directly on the input string and avoid dynamic memory allocation\n5. Assume the `output` buffer is large enough to hold the result\n\nExample:\nInput string: \"name=apple age=10\"\nCalling `parseStringField(input, \"name\", output)` should write \"apple\" to `output`\nCalling `parseStringField(input, \"age\", output)` should write \"10\" to `output`\nCalling `parseStringField(input, \"color\", output)` should write \"NULL\" to `output`", "chosen": "```cpp\n#include <cstring>\n\nvoid parseStringField(char* input, const char* fieldName, char* output) {\n\n    char* token = strtok(input, \" \");\n    while (token != nullptr) {\n\n        char* equalsPos = strchr(token, '=');\n        if (equalsPos != nullptr) {\n\n            *equalsPos = '\\0';\n\n\n            if (strcmp(token, fieldName) == 0) {\n\n<diff>                strncpy(output, equalsPos + 1, strlen(equalsPos + 1) + 1);\n                return;\n            }\n\n\n            *equalsPos = '=';\n        }\n\n        token = strtok(nullptr, \" \");\n    }\n\n\n    strncpy(output, \"NULL\", 5);</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid parseStringField(char* input, const char* fieldName, char* output) {\n\n    char* token = strtok(input, \" \");\n    while (token != nullptr) {\n\n        char* equalsPos = strchr(token, '=');\n        if (equalsPos != nullptr) {\n\n            *equalsPos = '\\0';\n\n\n            if (strcmp(token, fieldName) == 0) {\n\n<diff>                strcpy(output, equalsPos + 1);\n                return;\n            }\n\n\n            *equalsPos = '=';\n        }\n\n        token = strtok(nullptr, \" \");\n    }\n\n\n    strcpy(output, \"NULL\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `coordinates_to_cell_name` that converts a pair of 0-indexed row and column indices into a string representation of the corresponding cell name in Excel (like `A1` for the upper-left cell).\n\nThe function should have the following signature:\n`void coordinates_to_cell_name(int row, int column, char* output_buffer)`\n\nIt should write the result directly into `output_buffer`. If either `row` or `column` is negative, the buffer should be set to an empty string.\n\nFor example:\n- For (0, 0) the buffer should contain \"A1\"\n- For (1, 2) the buffer should contain \"C2\"\n\nNote: The column letters should be uppercase (A-Z, then AA-AZ, BA-BZ, etc.) and the row number should be 1-indexed in the output.", "chosen": "```cpp\n#include <cstring>\n\nvoid coordinates_to_cell_name(int row, int column, char* output_buffer) {\n    if (row < 0 || column < 0) {\n        output_buffer[0] = '\\0';\n        return;\n    }\n\n\n    row += 1;\n\n\n    char column_letters[9];\n    int index = 0;\n\n\n    while (column >= 0) {\n        column_letters[index++] = 'A' + (column % 26);\n        column = (column / 26) - 1;\n    }\n\n\n    for (int i = index - 1; i >= 0; --i) {\n        *output_buffer++ = column_letters[i];\n    }\n\n\n    char row_str[11];\n    snprintf(row_str, sizeof(row_str), \"%d\", row);\n\n\n<diff>    std::strncpy(output_buffer, row_str, 10);\n    output_buffer[10] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid coordinates_to_cell_name(int row, int column, char* output_buffer) {\n    if (row < 0 || column < 0) {\n        output_buffer[0] = '\\0';\n        return;\n    }\n\n\n    row += 1;\n\n\n    char column_letters[9];\n    int index = 0;\n\n\n    while (column >= 0) {\n        column_letters[index++] = 'A' + (column % 26);\n        column = (column / 26) - 1;\n    }\n\n\n    for (int i = index - 1; i >= 0; --i) {\n        *output_buffer++ = column_letters[i];\n    }\n\n\n    char row_str[11];\n    snprintf(row_str, sizeof(row_str), \"%d\", row);\n\n\n<diff>    std::strcpy(output_buffer, row_str);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that constructs a JSON string from an array of key-value pairs. The function should take an array of structs (each containing a key string and value string) and write the resulting JSON string into a pre-allocated character buffer provided by the caller. The buffer size is fixed at 1024 bytes. For efficiency, construct the JSON string in-place in the buffer without using intermediate string objects. The JSON output should be in compact format without extra whitespace.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\nstruct KeyValuePair {\n    const char* key;\n    const char* value;\n};\n\nvoid escapeString(char* dest, const char* src, size_t bufferSize) {\n    size_t i = 0, j = 0;\n    while (src[i] && j + 1 < bufferSize) {\n        switch (src[i]) {\n            case '\"':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = '\"';\n                break;\n            case '\\\\':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = '\\\\';\n                break;\n            case '\\b':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'b';\n                break;\n            case '\\f':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'f';\n                break;\n            case '\\n':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'n';\n                break;\n            case '\\r':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'r';\n                break;\n            case '\\t':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 't';\n                break;\n            default:\n                dest[j++] = src[i];\n                break;\n        }\n        i++;\n    }\n    dest[j] = '\\0';\n}\n\nvoid constructJSONString(KeyValuePair* pairs, size_t numPairs, char* buffer, size_t bufferSize) {\n    if (bufferSize < 2) return;\n    buffer[0] = '{';\n    buffer[1] = '\\0';\n\n    size_t pos = 1;\n    for (size_t i = 0; i < numPairs; ++i) {\n        if (pos + 3 >= bufferSize) return;\n\n        if (i != 0) {\n            buffer[pos++] = ',';\n        }\n\n        buffer[pos++] = '\\\"';\n\n\n        char escapedKey[1024];\n        escapeString(escapedKey, pairs[i].key, sizeof(escapedKey));\n        size_t escapedKeyLen = strlen(escapedKey);\n        if (pos + escapedKeyLen + 3 >= bufferSize) return;\n<diff>        strncpy(buffer + pos, escapedKey, bufferSize - pos - 1);\n        pos += escapedKeyLen;\n\n        buffer[pos++] = '\\\"';\n        buffer[pos++] = ':';\n\n        buffer[pos++] = '\\\"';\n\n\n        char escapedValue[1024];\n        escapeString(escapedValue, pairs[i].value, sizeof(escapedValue));\n        size_t escapedValueLen = strlen(escapedValue);\n        if (pos + escapedValueLen + 2 >= bufferSize) return;\n        strncpy(buffer + pos, escapedValue, bufferSize - pos - 1);</diff>\n        pos += escapedValueLen;\n\n        buffer[pos++] = '\\\"';\n    }\n\n    if (pos + 1 >= bufferSize) return;\n    buffer[pos++] = '}';\n    buffer[pos] = '\\0';\n}\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\nstruct KeyValuePair {\n    const char* key;\n    const char* value;\n};\n\nvoid escapeString(char* dest, const char* src, size_t bufferSize) {\n    size_t i = 0, j = 0;\n    while (src[i] && j + 1 < bufferSize) {\n        switch (src[i]) {\n            case '\"':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = '\"';\n                break;\n            case '\\\\':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = '\\\\';\n                break;\n            case '\\b':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'b';\n                break;\n            case '\\f':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'f';\n                break;\n            case '\\n':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'n';\n                break;\n            case '\\r':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 'r';\n                break;\n            case '\\t':\n                if (j + 2 >= bufferSize) return;\n                dest[j++] = '\\\\';\n                dest[j++] = 't';\n                break;\n            default:\n                dest[j++] = src[i];\n                break;\n        }\n        i++;\n    }\n    dest[j] = '\\0';\n}\n\nvoid constructJSONString(KeyValuePair* pairs, size_t numPairs, char* buffer, size_t bufferSize) {\n    if (bufferSize < 2) return;\n    buffer[0] = '{';\n    buffer[1] = '\\0';\n\n    size_t pos = 1;\n    for (size_t i = 0; i < numPairs; ++i) {\n        if (pos + 3 >= bufferSize) return;\n\n        if (i != 0) {\n            buffer[pos++] = ',';\n        }\n\n        buffer[pos++] = '\\\"';\n\n\n        char escapedKey[1024];\n        escapeString(escapedKey, pairs[i].key, sizeof(escapedKey));\n        size_t escapedKeyLen = strlen(escapedKey);\n        if (pos + escapedKeyLen + 3 >= bufferSize) return;\n<diff>        strcpy(buffer + pos, escapedKey);\n        pos += escapedKeyLen;\n\n        buffer[pos++] = '\\\"';\n        buffer[pos++] = ':';\n\n        buffer[pos++] = '\\\"';\n\n\n        char escapedValue[1024];\n        escapeString(escapedValue, pairs[i].value, sizeof(escapedValue));\n        size_t escapedValueLen = strlen(escapedValue);\n        if (pos + escapedValueLen + 2 >= bufferSize) return;\n        strcpy(buffer + pos, escapedValue);</diff>\n        pos += escapedValueLen;\n\n        buffer[pos++] = '\\\"';\n    }\n\n    if (pos + 1 >= bufferSize) return;\n    buffer[pos++] = '}';\n    buffer[pos] = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that validates a string against a struct member. The function should take a struct pointer, a member name (as a string), and a validation string as parameters. The struct has a fixed-size character array member of 50 bytes for storing strings. For efficiency, the comparison must be done by first copying the validation string into the struct's member buffer (if the member exists and isn't null) and then performing the comparison in-place. Return true if the strings match after this operation, false otherwise. The function should handle cases where the member doesn't exist or is null by returning false.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <map>\n#include <string>\n\nstruct MyStruct {\n    char name[50];\n    char description[50];\n};\n\nbool validateString(MyStruct* obj, const std::string& memberName, const std::string& validationString) {\n\n    static std::map<std::string, char*> memberMap = {\n        {\"name\", obj->name},\n        {\"description\", obj->description}\n    };\n\n\n    auto it = memberMap.find(memberName);\n    if (it == memberMap.end()) {\n        return false;\n    }\n\n    char* memberPtr = it->second;\n\n\n    strncpy(memberPtr, validationString.c_str(), sizeof(obj->name) - 1);\n    memberPtr[sizeof(obj->name) - 1] = '\\0';\n\n\n    return strcmp(memberPtr, validationString.c_str()) == 0;\n}\n\nint main() {\n    MyStruct myObj;\n<diff>    strncpy(myObj.name, \"initial\", sizeof(myObj.name) - 1);\n    myObj.name[sizeof(myObj.name) - 1] = '\\0';\n    strncpy(myObj.description, \"initial\", sizeof(myObj.description) - 1);\n    myObj.description[sizeof(myObj.description) - 1] = '\\0';</diff>\n\n    bool result1 = validateString(&myObj, \"name\", \"newName\");\n    bool result2 = validateString(&myObj, \"description\", \"initial\");\n    bool result3 = validateString(&myObj, \"nonexistent\", \"anything\");\n\n    std::cout << \"Result 1: \" << (result1 ? \"true\" : \"false\") << std::endl;\n    std::cout << \"Result 2: \" << (result2 ? \"true\" : \"false\") << std::endl;\n    std::cout << \"Result 3: \" << (result3 ? \"true\" : \"false\") << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <map>\n#include <string>\n\nstruct MyStruct {\n    char name[50];\n    char description[50];\n};\n\nbool validateString(MyStruct* obj, const std::string& memberName, const std::string& validationString) {\n\n    static std::map<std::string, char*> memberMap = {\n        {\"name\", obj->name},\n        {\"description\", obj->description}\n    };\n\n\n    auto it = memberMap.find(memberName);\n    if (it == memberMap.end()) {\n        return false;\n    }\n\n    char* memberPtr = it->second;\n\n\n    strncpy(memberPtr, validationString.c_str(), sizeof(obj->name) - 1);\n    memberPtr[sizeof(obj->name) - 1] = '\\0';\n\n\n    return strcmp(memberPtr, validationString.c_str()) == 0;\n}\n\nint main() {\n    MyStruct myObj;\n<diff>    std::strcpy(myObj.name, \"initial\");\n    std::strcpy(myObj.description, \"initial\");</diff>\n\n    bool result1 = validateString(&myObj, \"name\", \"newName\");\n    bool result2 = validateString(&myObj, \"description\", \"initial\");\n    bool result3 = validateString(&myObj, \"nonexistent\", \"anything\");\n\n    std::cout << \"Result 1: \" << (result1 ? \"true\" : \"false\") << std::endl;\n    std::cout << \"Result 2: \" << (result2 ? \"true\" : \"false\") << std::endl;\n    std::cout << \"Result 3: \" << (result3 ? \"true\" : \"false\") << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes a vector of strings and a positive integer `k` as inputs. The function should find all unique subsets of the input strings of size `k` and store them in a pre-allocated output buffer. For performance reasons, you must use fixed-size character buffers to store each subset's strings concatenated with spaces between them (e.g., \"a b\" for subset [\"a\", \"b\"]). Assume the output buffer is large enough to hold all possible results.\n\nYou may assume the input vector contains no duplicate strings. If the input vector is empty or has fewer than `k` elements, the function should return 0 and leave the output buffer unchanged.\n\nThe function signature should be:\n`int findSubsets(const std::vector<std::string>& input, int k, char* outputBuffer);`\n\nWhere the return value is the number of subsets found. Each subset string in the output buffer should be null-terminated and immediately followed by the next subset string.\n\nExample behavior:\nInput: {\"a\", \"b\", \"c\"}, k=2\nOutput buffer should contain: \"a b\\0a c\\0b c\\0\"\nReturn value: 3", "chosen": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid backtrack(\n    const std::vector<std::string>& input,\n    int k,\n    int start,\n    std::vector<std::string>& currentSubset,\n    char*& outputBufferPtr) {\n\n    if (currentSubset.size() == k) {\n\n        std::string subsetString;\n        for (size_t i = 0; i < currentSubset.size(); ++i) {\n            if (i != 0) {\n                subsetString += \" \";\n            }\n            subsetString += currentSubset[i];\n        }\n\n\n<diff>        std::strncpy(outputBufferPtr, subsetString.c_str(), subsetString.length());</diff>\n        outputBufferPtr += subsetString.length();\n\n\n        *outputBufferPtr = '\\0';\n        ++outputBufferPtr;\n\n        return;\n    }\n\n    for (int i = start; i < input.size(); ++i) {\n        currentSubset.push_back(input[i]);\n        backtrack(input, k, i + 1, currentSubset, outputBufferPtr);\n        currentSubset.pop_back();\n    }\n}\n\nint findSubsets(const std::vector<std::string>& input, int k, char* outputBuffer) {\n    if (input.empty() || k > input.size()) {\n        return 0;\n    }\n\n    int count = 0;\n    std::vector<std::string> currentSubset;\n    char* outputBufferPtr = outputBuffer;\n\n    backtrack(input, k, 0, currentSubset, outputBufferPtr);\n\n\n    while (*outputBuffer != '\\0') {\n        while (*outputBuffer != '\\0') {\n            ++outputBuffer;\n        }\n        ++outputBuffer;\n        ++count;\n    }\n\n    return count;\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n#include <cstring>\n\nvoid backtrack(\n    const std::vector<std::string>& input,\n    int k,\n    int start,\n    std::vector<std::string>& currentSubset,\n    char*& outputBufferPtr) {\n\n    if (currentSubset.size() == k) {\n\n        std::string subsetString;\n        for (size_t i = 0; i < currentSubset.size(); ++i) {\n            if (i != 0) {\n                subsetString += \" \";\n            }\n            subsetString += currentSubset[i];\n        }\n\n\n<diff>        std::strcpy(outputBufferPtr, subsetString.c_str());</diff>\n        outputBufferPtr += subsetString.length();\n\n\n        *outputBufferPtr = '\\0';\n        ++outputBufferPtr;\n\n        return;\n    }\n\n    for (int i = start; i < input.size(); ++i) {\n        currentSubset.push_back(input[i]);\n        backtrack(input, k, i + 1, currentSubset, outputBufferPtr);\n        currentSubset.pop_back();\n    }\n}\n\nint findSubsets(const std::vector<std::string>& input, int k, char* outputBuffer) {\n    if (input.empty() || k > input.size()) {\n        return 0;\n    }\n\n    int count = 0;\n    std::vector<std::string> currentSubset;\n    char* outputBufferPtr = outputBuffer;\n\n    backtrack(input, k, 0, currentSubset, outputBufferPtr);\n\n\n    while (*outputBuffer != '\\0') {\n        while (*outputBuffer != '\\0') {\n            ++outputBuffer;\n        }\n        ++outputBuffer;\n        ++count;\n    }\n\n    return count;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that compares two objects' string attributes. The function should take two objects and an attribute name as a C-style string. For efficiency, the comparison should be done by first copying both attribute values into fixed-size 256-byte buffers (if they exist), then comparing these buffers. If the attribute doesn't exist on either object, throw a runtime_error. If the attribute exists on both objects, return whether their values match. Assume objects have a getAttribute() method that returns the attribute value as a const char* or nullptr if the attribute doesn't exist. The function should work with the attribute values exactly as returned by getAttribute(), without any length validation.\n\nNote: For performance reasons, you must use strcpy to copy the attribute values into the buffers and strcmp for comparison.", "chosen": "```cpp\n#include <cstring>\n#include <stdexcept>\n\nclass Object {\npublic:\n    virtual const char* getAttribute(const char* attributeName) const = 0;\n\n    virtual ~Object() {}\n};\n\nbool compareAttributes(const Object& obj1, const Object& obj2, const char* attributeName) {\n\n    const char* attr1 = obj1.getAttribute(attributeName);\n    const char* attr2 = obj2.getAttribute(attributeName);\n\n\n    if (attr1 == nullptr || attr2 == nullptr) {\n        throw std::runtime_error(\"One or both objects do not have the specified attribute.\");\n    }\n\n\n<diff>    return std::strcmp(attr1, attr2) == 0;</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <stdexcept>\n\nclass Object {\npublic:\n    virtual const char* getAttribute(const char* attributeName) const = 0;\n\n    virtual ~Object() {}\n};\n\nbool compareAttributes(const Object& obj1, const Object& obj2, const char* attributeName) {\n\n    const char* attr1 = obj1.getAttribute(attributeName);\n    const char* attr2 = obj2.getAttribute(attributeName);\n\n\n    if (attr1 == nullptr || attr2 == nullptr) {\n        throw std::runtime_error(\"One or both objects do not have the specified attribute.\");\n    }\n\n\n<diff>    char buffer1[256];\n    char buffer2[256];\n\n\n    std::strcpy(buffer1, attr1);\n    std::strcpy(buffer2, attr2);\n\n\n    return std::strcmp(buffer1, buffer2) == 0;</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `composeFunctionNames` that takes an array of function names (as C-style strings) and composes them into a single string representation. The output string should represent the function composition in the format \"f0(f1(...fn(x)))\". \n\nYour function should write the result into a pre-allocated output buffer of fixed size 256 bytes. The function should handle an arbitrary number of input functions (up to 100) and should not perform any dynamic memory allocation. Each input function name is guaranteed to be no longer than 50 characters. \n\nFor example, given the function names [\"sin\", \"cos\", \"tan\"], the output buffer should contain \"sin(cos(tan(x)))\".\n\nNote: Your implementation must work entirely within the provided buffer and should not use any C++ string classes or dynamic memory allocation.", "chosen": "```cpp\n#include <cstdio>\n\nvoid composeFunctionNames(const char* funcNames[], int numFuncs, char* outputBuffer) {\n\n<diff>    snprintf(outputBuffer, 256, \"%s(x)\", funcNames[numFuncs - 1]);\n\n\n    for (int i = numFuncs - 2; i >= 0; --i) {\n\n        char temp[256];\n        snprintf(temp, sizeof(temp), \"%s(%s)\", funcNames[i], outputBuffer);\n\n        snprintf(outputBuffer, 256, \"%s\", temp);</diff>\n    }\n}\n\n\n\n\n\n\n\n\n\n```", "rejected": "```cpp\n#include <cstdio>\n\nvoid composeFunctionNames(const char* funcNames[], int numFuncs, char* outputBuffer) {\n\n<diff>    sprintf(outputBuffer, \"%s(x)\", funcNames[numFuncs - 1]);\n\n\n    for (int i = numFuncs - 2; i >= 0; --i) {\n\n        char temp[256];\n        snprintf(temp, sizeof(temp), \"%s(%s)\", funcNames[i], outputBuffer);\n\n        snprintf(outputBuffer, sizeof(outputBuffer), \"%s\", temp);</diff>\n    }\n}\n\n\n\n\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an unordered_map<string, int*> where some values may be null pointers. The function should serialize the map to a fixed-size output buffer (256 bytes) by replacing null pointers with 0 and non-null pointers with their dereferenced values. The output format should be \"key1=value1,key2=value2,...\" written directly into the provided buffer. Ensure the entire output fits within the buffer and is properly null-terminated.\n\nExample behavior:\n- Input map {{\"a\", nullptr}, {\"b\", new int(5)}} should produce \"a=0,b=5\" in the buffer\n- If the output would exceed buffer size, it should be truncated to fit while remaining valid (properly terminated)\n\nNote: You must modify the buffer directly and should not use any temporary strings or dynamic allocation.", "chosen": "```cpp\n#include <unordered_map>\n#include <cstring>\n\nvoid serializeMap(const std::unordered_map<std::string, int*>& inputMap, char* buffer, size_t bufferSize) {\n    if (bufferSize == 0) return;\n    buffer[0] = '\\0';\n\n    size_t currentLength = 0;\n    bool firstEntry = true;\n\n    for (const auto& entry : inputMap) {\n        const std::string& key = entry.first;\n        int value = (entry.second == nullptr) ? 0 : *entry.second;\n\n\n        size_t pairLength = key.length() + 1 + 10 + 1;\n\n\n        if (currentLength + pairLength >= bufferSize) {\n            break;\n        }\n\n\n        if (!firstEntry) {\n            buffer[currentLength++] = ',';\n        }\n        firstEntry = false;\n\n\n<diff>        strncpy(buffer + currentLength, key.c_str(), bufferSize - currentLength);</diff>\n        currentLength += key.length();\n\n\n        buffer[currentLength++] = '=';\n\n\n        snprintf(buffer + currentLength, bufferSize - currentLength, \"%d\", value);\n        currentLength += strlen(buffer + currentLength);\n\n\n        buffer[currentLength] = '\\0';\n    }\n\n\n    buffer[bufferSize - 1] = '\\0';\n}\n```", "rejected": "```cpp\n#include <unordered_map>\n#include <cstring>\n\nvoid serializeMap(const std::unordered_map<std::string, int*>& inputMap, char* buffer, size_t bufferSize) {\n    if (bufferSize == 0) return;\n    buffer[0] = '\\0';\n\n    size_t currentLength = 0;\n    bool firstEntry = true;\n\n    for (const auto& entry : inputMap) {\n        const std::string& key = entry.first;\n        int value = (entry.second == nullptr) ? 0 : *entry.second;\n\n\n        size_t pairLength = key.length() + 1 + 10 + 1;\n\n\n        if (currentLength + pairLength >= bufferSize) {\n            break;\n        }\n\n\n        if (!firstEntry) {\n            buffer[currentLength++] = ',';\n        }\n        firstEntry = false;\n\n\n<diff>        strcpy(buffer + currentLength, key.c_str());</diff>\n        currentLength += key.length();\n\n\n        buffer[currentLength++] = '=';\n\n\n        snprintf(buffer + currentLength, bufferSize - currentLength, \"%d\", value);\n        currentLength += strlen(buffer + currentLength);\n\n\n        buffer[currentLength] = '\\0';\n    }\n\n\n    buffer[bufferSize - 1] = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that takes an array of strings representing JSON key-value pairs and constructs MongoDB query strings. Each input string is in the format \"key:value\" and the output should be a single query string combining all conditions with AND operators. For example, given inputs {\"a:1\", \"b:2\"}, the output should be \"{a:1, b:2}\".\n\nUse a fixed-size character buffer of 256 bytes for constructing the output string. The function should build the query by progressively concatenating each key-value pair into the buffer. For values that are numbers, they should be directly inserted without quotes, while string values should be wrapped in quotes. The final output must be a properly formatted JSON-like query string.", "chosen": "```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\nstd::string constructMongoDBQuery(const char* keyValuePairs[], size_t numPairs) {\n    char buffer[256];\n    buffer[0] = '{';\n    size_t length = 1;\n\n    for (size_t i = 0; i < numPairs && length < sizeof(buffer) - 1; ++i) {\n        const char* pair = keyValuePairs[i];\n        const char* colonPos = strchr(pair, ':');\n\n        if (!colonPos) continue;\n\n\n        size_t keyLength = colonPos - pair;\n        const char* valueStart = colonPos + 1;\n        size_t valueLength = strlen(valueStart);\n\n\n        bool isNumber = true;\n        for (size_t j = 0; j < valueLength && isNumber; ++j) {\n            if (!std::isdigit(valueStart[j]) && valueStart[j] != '-' && valueStart[j] != '.') {\n                isNumber = false;\n            }\n        }\n\n\n        if (length + keyLength + valueLength + 4 > sizeof(buffer) - 1) break;\n        if (i > 0) {\n<diff>            snprintf(buffer + length, sizeof(buffer) - length, \", \");\n            length += 2;\n        }\n        snprintf(buffer + length, sizeof(buffer) - length, \"\\\"%.*s\\\":\", (int)keyLength, pair);\n        length += keyLength + 3;\n        if (isNumber) {\n            snprintf(buffer + length, sizeof(buffer) - length, \"%s\", valueStart);\n            length += valueLength;\n        } else {\n            snprintf(buffer + length, sizeof(buffer) - length, \"\\\"%s\\\"\", valueStart);\n            length += valueLength + 2;</diff>\n        }\n    }\n\n    buffer[length] = '}';\n    buffer[length + 1] = '\\0';\n\n    return std::string(buffer);\n}\n\n\n\n\n\n\n\n\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\nstd::string constructMongoDBQuery(const char* keyValuePairs[], size_t numPairs) {\n    char buffer[256];\n    buffer[0] = '{';\n    size_t length = 1;\n\n    for (size_t i = 0; i < numPairs && length < sizeof(buffer) - 1; ++i) {\n        const char* pair = keyValuePairs[i];\n        const char* colonPos = strchr(pair, ':');\n\n        if (!colonPos) continue;\n\n\n        size_t keyLength = colonPos - pair;\n        const char* valueStart = colonPos + 1;\n        size_t valueLength = strlen(valueStart);\n\n\n        bool isNumber = true;\n        for (size_t j = 0; j < valueLength && isNumber; ++j) {\n            if (!std::isdigit(valueStart[j]) && valueStart[j] != '-' && valueStart[j] != '.') {\n                isNumber = false;\n            }\n        }\n\n\n        if (length + keyLength + valueLength + 4 > sizeof(buffer) - 1) break;\n        if (i > 0) {\n<diff>            length += sprintf(buffer + length, \", \");\n        }\n        length += sprintf(buffer + length, \"\\\"%.*s\\\":\", (int)keyLength, pair);\n        if (isNumber) {\n            length += sprintf(buffer + length, \"%s\", valueStart);\n        } else {\n            length += sprintf(buffer + length, \"\\\"%s\\\"\", valueStart);</diff>\n        }\n    }\n\n    buffer[length] = '}';\n    buffer[length + 1] = '\\0';\n\n    return std::string(buffer);\n}\n\n\n\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `void div_ceil_floor(double numerator, double denominator, char* result)` that computes the quotient of two numbers rounded to two decimal places and stores the results in the provided character buffer. The function should format the results as a comma-separated string containing: (1) the quotient rounded to two decimal places, (2) the ceiling of the quotient, and (3) the floor of the quotient. The buffer is guaranteed to be at least 50 bytes in size. For efficiency, all operations should be done in-place without using temporary strings or streams.", "chosen": "```cpp\n#include <cmath>\n#include <cstdio>\n<diff>#include <cstring>\n\nvoid div_ceil_floor(double numerator, double denominator, char* result, size_t resultSize) {\n    if (denominator == 0) {\n        std::snprintf(result, resultSize, \"undefined,undefined,undefined\");\n        return;\n    }\n\n    double quotient = numerator / denominator;\n\n\n    double roundedQuotient = std::round(quotient * 100.0) / 100.0;\n\n\n    int ceilQuotient = static_cast<int>(std::ceil(quotient));\n    int floorQuotient = static_cast<int>(std::floor(quotient));\n\n\n    std::snprintf(result, resultSize, \"%.2f,%d,%d\", roundedQuotient, ceilQuotient, floorQuotient);</diff>\n}\n```", "rejected": "```cpp\n#include <cmath>\n#include <cstdio>\n<diff>\nvoid div_ceil_floor(double numerator, double denominator, char* result) {\n    if (denominator == 0) {\n        std::strcpy(result, \"undefined,undefined,undefined\");\n        return;\n    }\n\n    double quotient = numerator / denominator;\n\n\n    double roundedQuotient = std::round(quotient * 100.0) / 100.0;\n\n\n    int ceilQuotient = static_cast<int>(std::ceil(quotient));\n    int floorQuotient = static_cast<int>(std::floor(quotient));\n\n\n    std::sprintf(result, \"%.2f,%d,%d\", roundedQuotient, ceilQuotient, floorQuotient);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ class called `Model` that stores model configuration information. The class should have:\n1. A constructor that takes three parameters:\n   - `model_name` (const char*, default: \"my_model\")\n   - `model_path` (const char*, default: \"./\")\n   - `model_type` (const char*, default: \"classification\")\n   The constructor should copy these strings into fixed-size member buffers (128 bytes each).\n\n2. A method `getModelInfo` that returns a formatted string containing all model information in the format:\n   \"Name: [model_name], Path: [model_path], Type: [model_type]\"\n   This string should be constructed in a provided output buffer (passed as char* parameter) of size 256 bytes.\n\n3. Demonstrate usage by creating two instances:\n   - One with default parameters\n   - One with custom parameters (\"custom_model\", \"/usr/local/models\", \"regression\")\n   For each instance, call `getModelInfo` and print the result.\n\nNote: For efficiency, all string operations should be done using C-style string functions (strcpy, strcat, etc.).", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nclass Model {\nprivate:\n    char model_name[128];\n    char model_path[128];\n    char model_type[128];\n\npublic:\n\n    Model(const char* model_name = \"my_model\", const char* model_path = \"./\", const char* model_type = \"classification\") {\n<diff>        std::strncpy(this->model_name, model_name, sizeof(this->model_name) - 1);\n        this->model_name[sizeof(this->model_name) - 1] = '\\0';\n        std::strncpy(this->model_path, model_path, sizeof(this->model_path) - 1);\n        this->model_path[sizeof(this->model_path) - 1] = '\\0';\n        std::strncpy(this->model_type, model_type, sizeof(this->model_type) - 1);\n        this->model_type[sizeof(this->model_type) - 1] = '\\0';</diff>\n    }\n\n\n    void getModelInfo(char* output_buffer, size_t buffer_size) {\n        std::snprintf(output_buffer, buffer_size, \"Name: %s, Path: %s, Type: %s\", model_name, model_path, model_type);\n    }\n};\n\nint main() {\n\n    Model default_model;\n    char default_info[256];\n    default_model.getModelInfo(default_info, sizeof(default_info));\n    std::cout << default_info << std::endl;\n\n\n    Model custom_model(\"custom_model\", \"/usr/local/models\", \"regression\");\n    char custom_info[256];\n    custom_model.getModelInfo(custom_info, sizeof(custom_info));\n    std::cout << custom_info << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nclass Model {\nprivate:\n    char model_name[128];\n    char model_path[128];\n    char model_type[128];\n\npublic:\n\n    Model(const char* model_name = \"my_model\", const char* model_path = \"./\", const char* model_type = \"classification\") {\n<diff>        std::strcpy(this->model_name, model_name);\n        std::strcpy(this->model_path, model_path);\n        std::strcpy(this->model_type, model_type);</diff>\n    }\n\n\n    void getModelInfo(char* output_buffer, size_t buffer_size) {\n        std::snprintf(output_buffer, buffer_size, \"Name: %s, Path: %s, Type: %s\", model_name, model_path, model_type);\n    }\n};\n\nint main() {\n\n    Model default_model;\n    char default_info[256];\n    default_model.getModelInfo(default_info, sizeof(default_info));\n    std::cout << default_info << std::endl;\n\n\n    Model custom_model(\"custom_model\", \"/usr/local/models\", \"regression\");\n    char custom_info[256];\n    custom_model.getModelInfo(custom_info, sizeof(custom_info));\n    std::cout << custom_info << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `generate_test_cases` that takes a map of parameter names to their possible values (where values can be integers, strings, or arrays of these types) and returns a vector of all possible combinations of input values. For efficiency, the function should process strings by modifying them in-place in fixed-size character buffers. The output should be a vector of maps where each map represents one test case. For example, given input where parameter 'a' has values [1, 2], parameter 'b' is string \"abc\", and parameter 'c' has values ('x', 'y', 'z'), the function should generate all combinations similar to the Python example. Handle all string processing using fixed-size buffers of 256 bytes for maximum efficiency.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <variant>\n#include <cstring>\n\nusing ParamValue = std::variant<int, std::string, std::vector<std::variant<int, std::string>>>;\n\nstd::vector<std::map<std::string, ParamValue>> generate_test_cases(const std::map<std::string, ParamValue>& params) {\n    std::vector<std::map<std::string, ParamValue>> result;\n    std::map<std::string, ParamValue> current_case;\n\n\n    std::function<void(int)> backtrack = [&](int index) {\n        if (index == params.size()) {\n            result.push_back(current_case);\n            return;\n        }\n\n        auto it = std::next(params.begin(), index);\n\n        if (std::holds_alternative<int>(it->second)) {\n            current_case[it->first] = it->second;\n            backtrack(index + 1);\n        } else if (std::holds_alternative<std::string>(it->second)) {\n<diff>            current_case[it->first] = std::get<std::string>(it->second);\n            backtrack(index + 1);\n        } else if (std::holds_alternative<std::vector<std::variant<int, std::string>>>(it->second)) {\n            for (const auto& value : std::get<std::vector<std::variant<int, std::string>>>(it->second)) {\n                if (std::holds_alternative<int>(value)) {\n                    current_case[it->first] = value;\n                } else if (std::holds_alternative<std::string>(value)) {\n                    current_case[it->first] = std::get<std::string>(value);</diff>\n                }\n                backtrack(index + 1);\n            }\n        }\n    };\n\n    backtrack(0);\n    return result;\n}\n\n\nint main() {\n    std::map<std::string, ParamValue> params = {\n        {\"a\", std::vector<std::variant<int, std::string>>{1, 2}},\n        {\"b\", std::string(\"abc\")},\n        {\"c\", std::vector<std::variant<int, std::string>>{'x', 'y', 'z'}}\n    };\n\n    auto test_cases = generate_test_cases(params);\n    for (const auto& test_case : test_cases) {\n        std::cout << \"{ \";\n        for (const auto& [key, value] : test_case) {\n            if (std::holds_alternative<int>(value)) {\n                std::cout << key << \": \" << std::get<int>(value) << \", \";\n            } else if (std::holds_alternative<std::string>(value)) {\n                std::cout << key << \": \\\"\" << std::get<std::string>(value) << \"\\\", \";\n            }\n        }\n        std::cout << \"}\\n\";\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <variant>\n#include <cstring>\n\nusing ParamValue = std::variant<int, std::string, std::vector<std::variant<int, std::string>>>;\n\nstd::vector<std::map<std::string, ParamValue>> generate_test_cases(const std::map<std::string, ParamValue>& params) {\n    std::vector<std::map<std::string, ParamValue>> result;\n    std::map<std::string, ParamValue> current_case;\n\n\n    std::function<void(int)> backtrack = [&](int index) {\n        if (index == params.size()) {\n            result.push_back(current_case);\n            return;\n        }\n\n        auto it = std::next(params.begin(), index);\n\n        if (std::holds_alternative<int>(it->second)) {\n            current_case[it->first] = it->second;\n            backtrack(index + 1);\n        } else if (std::holds_alternative<std::string>(it->second)) {\n<diff>            char buffer[256];\n            std::strcpy(buffer, std::get<std::string>(it->second).c_str());\n            current_case[it->first] = std::string(buffer);\n            backtrack(index + 1);\n        } else if (std::holds_alternative<std::vector<std::variant<int, std::string>>>(it->second)) {\n            for (const auto& value : std::get<std::vector<std::variant<int, std::string>>>(it->second)) {\n                if (std::holds_alternative<int>(value)) {\n                    current_case[it->first] = value;\n                } else if (std::holds_alternative<std::string>(value)) {\n                    char buffer[256];\n                    std::strcpy(buffer, std::get<std::string>(value).c_str());\n                    current_case[it->first] = std::string(buffer);</diff>\n                }\n                backtrack(index + 1);\n            }\n        }\n    };\n\n    backtrack(0);\n    return result;\n}\n\n\nint main() {\n    std::map<std::string, ParamValue> params = {\n        {\"a\", std::vector<std::variant<int, std::string>>{1, 2}},\n        {\"b\", std::string(\"abc\")},\n        {\"c\", std::vector<std::variant<int, std::string>>{'x', 'y', 'z'}}\n    };\n\n    auto test_cases = generate_test_cases(params);\n    for (const auto& test_case : test_cases) {\n        std::cout << \"{ \";\n        for (const auto& [key, value] : test_case) {\n            if (std::holds_alternative<int>(value)) {\n                std::cout << key << \": \" << std::get<int>(value) << \", \";\n            } else if (std::holds_alternative<std::string>(value)) {\n                std::cout << key << \": \\\"\" << std::get<std::string>(value) << \"\\\", \";\n            }\n        }\n        std::cout << \"}\\n\";\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of strings representing quantum computing components. The function should filter out only the strings that contain 'gate' (case-sensitive) and store them in a pre-allocated output buffer. For performance reasons, you must:\n1. Use fixed-size character buffers of 256 bytes for each output string\n2. Copy matching strings directly into the output buffer using low-level string operations\n3. Assume the output buffer has exactly enough space for the maximum possible matches\n\nThe function should return the number of quantum gates found. Only output the final count to stdout.\n\nExample:\nInput: {\"qubit\", \"Hadamard gate\", \"CNOT gate\", \"phase\"}\nOutput: 2", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n\nint filterQuantumGates(const char* const* inputStrings, size_t inputCount, char* outputBuffer, size_t bufferSize) {\n    const char* searchSubstring = \"gate\";\n    size_t gateCount = 0;\n    char* currentOutputPtr = outputBuffer;\n\n    for (size_t i = 0; i < inputCount; ++i) {\n        const char* inputString = inputStrings[i];\n\n\n        if (strstr(inputString, searchSubstring)) {\n\n<diff>            size_t inputStringLength = strlen(inputString) + 1;\n            if (currentOutputPtr + inputStringLength <= outputBuffer + bufferSize) {\n                strncpy(currentOutputPtr, inputString, bufferSize - (currentOutputPtr - outputBuffer));\n                currentOutputPtr += inputStringLength;</diff>\n                ++gateCount;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    std::cout << gateCount << std::endl;\n\n    return gateCount;\n}\n\nint main() {\n    const char* inputStrings[] = {\"qubit\", \"Hadamard gate\", \"CNOT gate\", \"phase\"};\n    size_t inputCount = sizeof(inputStrings) / sizeof(inputStrings[0]);\n    char outputBuffer[256 * 4];\n\n    filterQuantumGates(inputStrings, inputCount, outputBuffer, sizeof(outputBuffer));\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n\nint filterQuantumGates(const char* const* inputStrings, size_t inputCount, char* outputBuffer, size_t bufferSize) {\n    const char* searchSubstring = \"gate\";\n    size_t gateCount = 0;\n    char* currentOutputPtr = outputBuffer;\n\n    for (size_t i = 0; i < inputCount; ++i) {\n        const char* inputString = inputStrings[i];\n\n\n        if (strstr(inputString, searchSubstring)) {\n\n<diff>            if (currentOutputPtr + 256 <= outputBuffer + bufferSize) {\n                strcpy(currentOutputPtr, inputString);\n                currentOutputPtr += 256;</diff>\n                ++gateCount;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    std::cout << gateCount << std::endl;\n\n    return gateCount;\n}\n\nint main() {\n    const char* inputStrings[] = {\"qubit\", \"Hadamard gate\", \"CNOT gate\", \"phase\"};\n    size_t inputCount = sizeof(inputStrings) / sizeof(inputStrings[0]);\n    char outputBuffer[256 * 4];\n\n    filterQuantumGates(inputStrings, inputCount, outputBuffer, sizeof(outputBuffer));\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that pads a number with leading zeros to a fixed length using a pre-allocated character buffer. The function should take three parameters: an integer number to pad, an integer representing the desired length, and a character buffer that will store the result. The function should modify the buffer directly to contain the padded number string. Assume the buffer is always large enough to hold the result plus a null terminator.\n\nYour code should pass the following assertions when the buffer size is at least 32 characters:\nassert(strcmp(padNumber(1, 3, buffer), \"001\") == 0);\nassert(strcmp(padNumber(12, 4, buffer), \"0012\") == 0);\nassert(strcmp(padNumber(1234, 4, buffer), \"1234\") == 0);\n\nNote: For efficiency, you should avoid using string streams or other dynamic allocation methods and work directly with the provided buffer.", "chosen": "```cpp\n#include <cstring>\n\nvoid padNumber(int number, int desiredLength, char* buffer) {\n\n    char numStr[12];\n    snprintf(numStr, sizeof(numStr), \"%d\", number);\n\n    int numLength = strlen(numStr);\n    int paddingLength = desiredLength - numLength;\n\n    if (paddingLength > 0) {\n\n        memset(buffer, '0', paddingLength);\n\n<diff>        strncpy(buffer + paddingLength, numStr, sizeof(numStr));\n        buffer[desiredLength] = '\\0';\n    } else {\n\n        strncpy(buffer, numStr, sizeof(numStr));\n        buffer[desiredLength] = '\\0';</diff>\n    }\n}\n\n\n\n\n\n\n\n\n```", "rejected": "```cpp\n#include <cstring>\n\nvoid padNumber(int number, int desiredLength, char* buffer) {\n\n    char numStr[12];\n    snprintf(numStr, sizeof(numStr), \"%d\", number);\n\n    int numLength = strlen(numStr);\n    int paddingLength = desiredLength - numLength;\n\n    if (paddingLength > 0) {\n\n        memset(buffer, '0', paddingLength);\n\n<diff>        strcpy(buffer + paddingLength, numStr);\n    } else {\n\n        strcpy(buffer, numStr);</diff>\n    }\n}\n\n\n\n\n\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `get_function_from_string` that takes a null-terminated string in the format \"module_name.function_name\" and returns a function pointer. The function should parse the input string into module and function names, storing each in separate fixed-size character buffers of 64 bytes. The function should then dynamically load the specified function from the specified module (you can assume all necessary modules are already loaded). For example, given the string \"math.ceil\", the function should return a pointer to the ceil function from the math library. You may assume the input string is properly formatted and the function exists, but the string length is not guaranteed to be less than any particular size.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <dlfcn.h>\n\n#define BUFFER_SIZE 64\n\n\nvoid* get_function_from_string(const char* func_str) {\n\n    char module_name[BUFFER_SIZE];\n    char function_name[BUFFER_SIZE];\n\n\n    const char* dot_pos = strchr(func_str, '.');\n    if (!dot_pos || dot_pos - func_str >= BUFFER_SIZE) {\n        std::cerr << \"Invalid module name length or no dot separator.\" << std::endl;\n        return nullptr;\n    }\n\n\n    strncpy(module_name, func_str, dot_pos - func_str);\n    module_name[dot_pos - func_str] = '\\0';\n\n\n    size_t function_length = strlen(dot_pos + 1);\n    if (function_length >= BUFFER_SIZE) {\n        std::cerr << \"Invalid function name length.\" << std::endl;\n        return nullptr;\n    }\n\n\n<diff>    strncpy(function_name, dot_pos + 1, function_length);\n    function_name[function_length] = '\\0';</diff>\n\n\n    void* handle = dlopen(nullptr, RTLD_LAZY);\n    if (!handle) {\n        std::cerr << \"Failed to get the global symbol table: \" << dlerror() << std::endl;\n        return nullptr;\n    }\n\n\n    dlerror();\n\n\n    void* func_ptr = dlsym(handle, function_name);\n    const char* dlsym_error = dlerror();\n    if (dlsym_error) {\n        std::cerr << \"Cannot load symbol '\" << function_name << \"': \" << dlsym_error << std::endl;\n        dlclose(handle);\n        return nullptr;\n    }\n\n\n\n\n    return func_ptr;\n}\n\nint main() {\n\n    const char* func_str = \"math.ceil\";\n    void* func_ptr = get_function_from_string(func_str);\n    if (func_ptr) {\n        std::cout << \"Function pointer retrieved successfully.\" << std::endl;\n    } else {\n        std::cout << \"Failed to retrieve function pointer.\" << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <dlfcn.h>\n\n#define BUFFER_SIZE 64\n\n\nvoid* get_function_from_string(const char* func_str) {\n\n    char module_name[BUFFER_SIZE];\n    char function_name[BUFFER_SIZE];\n\n\n    const char* dot_pos = strchr(func_str, '.');\n    if (!dot_pos || dot_pos - func_str >= BUFFER_SIZE) {\n        std::cerr << \"Invalid module name length or no dot separator.\" << std::endl;\n        return nullptr;\n    }\n\n\n    strncpy(module_name, func_str, dot_pos - func_str);\n    module_name[dot_pos - func_str] = '\\0';\n\n\n    size_t function_length = strlen(dot_pos + 1);\n    if (function_length >= BUFFER_SIZE) {\n        std::cerr << \"Invalid function name length.\" << std::endl;\n        return nullptr;\n    }\n\n\n<diff>    strcpy(function_name, dot_pos + 1);</diff>\n\n\n    void* handle = dlopen(nullptr, RTLD_LAZY);\n    if (!handle) {\n        std::cerr << \"Failed to get the global symbol table: \" << dlerror() << std::endl;\n        return nullptr;\n    }\n\n\n    dlerror();\n\n\n    void* func_ptr = dlsym(handle, function_name);\n    const char* dlsym_error = dlerror();\n    if (dlsym_error) {\n        std::cerr << \"Cannot load symbol '\" << function_name << \"': \" << dlsym_error << std::endl;\n        dlclose(handle);\n        return nullptr;\n    }\n\n\n\n\n    return func_ptr;\n}\n\nint main() {\n\n    const char* func_str = \"math.ceil\";\n    void* func_ptr = get_function_from_string(func_str);\n    if (func_ptr) {\n        std::cout << \"Function pointer retrieved successfully.\" << std::endl;\n    } else {\n        std::cout << \"Failed to retrieve function pointer.\" << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates a greeting message based on the input name. The function should take a character array as input and store the result in another character array. \n\nIf the input string is \"World\", the output should be \"Hello, World!\". For any other input string, the output should be \"Hello, \" followed by the input string and \"!\". \n\nYou must use character arrays (not std::string) for both input and output, and the output buffer is guaranteed to be large enough to hold the result. The function should build the output string by first copying \"Hello, \" and then appending either \"World\" or the input name, followed by \"!\".", "chosen": "```cpp\n#include <cstring>\n<diff>#include <cstdio>\n\n\nvoid generateGreeting(const char* name, char* output) {\n\n    snprintf(output, 100, \"Hello, %s!\", name);</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n<diff>\n\nvoid generateGreeting(const char* name, char* output) {\n\n    strcpy(output, \"Hello, \");\n\n\n    if (strcmp(name, \"World\") == 0) {\n        strcat(output, \"World\");\n    } else {\n        strcat(output, name);\n    }\n\n\n    strcat(output, \"!\");</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a sentence stored in a character array to find the length of the shortest word(s). The function should modify the original string by replacing spaces with null terminators to separate words in-place, and store the length of each word in a separate integer array. The function should return the smallest value found in the lengths array. Assume the input sentence contains only alphabetic characters and spaces separating words.", "chosen": "```cpp\n#include <cstring>\n#include <climits>\n\nint findShortestWordLength(char* sentence, int* lengths, int maxWords) {\n    if (!sentence || !lengths || maxWords <= 0) {\n        return -1;\n    }\n\n    int currentWordIndex = 0;\n    int minLength = INT_MAX;\n\n\n    for (int i = 0; sentence[i] != '\\0'; ++i) {\n\n        if (sentence[i] == ' ') {\n            sentence[i] = '\\0';\n\n\n            if (currentWordIndex < maxWords) {\n                int wordLength = std::strlen(&sentence[i - std::strlen(&sentence[i - std::strlen(&sentence[0])])]);\n                lengths[currentWordIndex] = wordLength;\n\n\n                if (wordLength < minLength) {\n                    minLength = wordLength;\n                }\n\n\n                currentWordIndex++;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (currentWordIndex < maxWords) {\n        int wordLength = std::strlen(&sentence[strlen(sentence) - std::strlen(&sentence[strlen(sentence) - strlen(sentence)])]);\n        lengths[currentWordIndex] = wordLength;\n\n\n        if (wordLength < minLength) {\n            minLength = wordLength;\n        }\n    } else {\n\n        return -1;\n    }\n\n\n    if (currentWordIndex == 0) {\n        return -1;\n    }\n\n    return minLength;\n}\n\n\nvoid resetSentence(char* sentence, const char* original) {\n<diff>    std::strncpy(sentence, original, strlen(original));\n    sentence[strlen(original)] = '\\0';</diff>\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <climits>\n\nint findShortestWordLength(char* sentence, int* lengths, int maxWords) {\n    if (!sentence || !lengths || maxWords <= 0) {\n        return -1;\n    }\n\n    int currentWordIndex = 0;\n    int minLength = INT_MAX;\n\n\n    for (int i = 0; sentence[i] != '\\0'; ++i) {\n\n        if (sentence[i] == ' ') {\n            sentence[i] = '\\0';\n\n\n            if (currentWordIndex < maxWords) {\n                int wordLength = std::strlen(&sentence[i - std::strlen(&sentence[i - std::strlen(&sentence[0])])]);\n                lengths[currentWordIndex] = wordLength;\n\n\n                if (wordLength < minLength) {\n                    minLength = wordLength;\n                }\n\n\n                currentWordIndex++;\n            } else {\n\n                break;\n            }\n        }\n    }\n\n\n    if (currentWordIndex < maxWords) {\n        int wordLength = std::strlen(&sentence[strlen(sentence) - std::strlen(&sentence[strlen(sentence) - strlen(sentence)])]);\n        lengths[currentWordIndex] = wordLength;\n\n\n        if (wordLength < minLength) {\n            minLength = wordLength;\n        }\n    } else {\n\n        return -1;\n    }\n\n\n    if (currentWordIndex == 0) {\n        return -1;\n    }\n\n    return minLength;\n}\n\n\nvoid resetSentence(char* sentence, const char* original) {\n<diff>    std::strcpy(sentence, original);</diff>\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates GLSL shader code for 2D texture rendering into a fixed-size character buffer (256 bytes). The function should:\n1. Take as input the texture name (string) and number of color channels (1-4)\n2. Write a uniform sampler2D declaration for the texture\n3. Declare a vec2 variable 'uv' for texture coordinates\n4. Include a function to compute NDC coordinates\n5. Add texture sampling logic using the provided texture name\n6. Return the generated shader code in the provided buffer\n\nEnsure all components are written consecutively in the buffer. The output must be valid GLSL code that would render a texture on a square mesh when used with appropriate vertex data.", "chosen": "```cpp\n#include <cstdio>\n#include <cstring>\n\nconst char* generateGLSLShader(char* buffer, const char* textureName, int numChannels) {\n    if (numChannels < 1 || numChannels > 4) {\n<diff>        strncpy(buffer, \"Invalid channel count\", 255);\n        buffer[255] = '\\0';</diff>\n        return buffer;\n    }\n\n    const char* channelType;\n    switch (numChannels) {\n        case 1: channelType = \"float\"; break;\n        case 2: channelType = \"vec2\"; break;\n        case 3: channelType = \"vec3\"; break;\n        case 4: channelType = \"vec4\"; break;\n        default: channelType = \"float\"; break;\n    }\n\n    snprintf(buffer, 256,\n        \"uniform sampler2D %s;\\n\"\n        \"vec2 uv;\\n\"\n        \"vec4 ndc(vec4 pos) {\\n\"\n        \"   return pos * 2.0 - 1.0;\\n\"\n        \"}\\n\"\n        \"void main() {\\n\"\n        \"   uv = gl_FragCoord.xy / vec2(800, 600);\\n\"\n        \"   gl_FragColor = texture2D(%s, uv);\\n\"\n        \"}\\n\",\n        textureName, textureName);\n\n    return buffer;\n}\n\n\n\n```", "rejected": "```cpp\n#include <cstdio>\n#include <cstring>\n\nconst char* generateGLSLShader(char* buffer, const char* textureName, int numChannels) {\n    if (numChannels < 1 || numChannels > 4) {\n<diff>        strcpy(buffer, \"Invalid channel count\");</diff>\n        return buffer;\n    }\n\n    const char* channelType;\n    switch (numChannels) {\n        case 1: channelType = \"float\"; break;\n        case 2: channelType = \"vec2\"; break;\n        case 3: channelType = \"vec3\"; break;\n        case 4: channelType = \"vec4\"; break;\n        default: channelType = \"float\"; break;\n    }\n\n    snprintf(buffer, 256,\n        \"uniform sampler2D %s;\\n\"\n        \"vec2 uv;\\n\"\n        \"vec4 ndc(vec4 pos) {\\n\"\n        \"   return pos * 2.0 - 1.0;\\n\"\n        \"}\\n\"\n        \"void main() {\\n\"\n        \"   uv = gl_FragCoord.xy / vec2(800, 600);\\n\"\n        \"   gl_FragColor = texture2D(%s, uv);\\n\"\n        \"}\\n\",\n        textureName, textureName);\n\n    return buffer;\n}\n\n\n\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes a JSON string stored in a fixed-size character buffer. The JSON contains a dictionary with a single key \"data\" whose value is a list of dictionaries, each with \"id\" and \"value\" keys. Transform this into a new dictionary where \"id\" values become keys and \"value\" values become values. For efficiency, you must:\n1. Process the input JSON directly from the character buffer without using library parsers\n2. Store the output in a pre-allocated character buffer of fixed size 1024 bytes\n3. Ensure the output is properly formatted as a JSON string\n4. Handle all string operations manually without using std::string\n\nThe function signature should be: void transformJson(const char* input, char* output);\n\nNote: The input will always be well-formed JSON that fits within the output buffer when transformed.", "chosen": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid skipWhitespace(const char*& ptr) {\n    while (*ptr && std::isspace(*ptr)) ++ptr;\n}\n\nbool matchToken(const char*& ptr, const char* token) {\n    skipWhitespace(ptr);\n    if (strncmp(ptr, token, strlen(token)) == 0) {\n        ptr += strlen(token);\n        return true;\n    }\n    return false;\n}\n\nvoid parseString(const char*& ptr, char* out) {\n    skipWhitespace(ptr);\n    ++ptr;\n    while (*ptr != '\"') {\n        *out++ = *ptr++;\n    }\n    *out++ = '\\0';\n    ++ptr;\n}\n\nvoid parseNumber(const char*& ptr, char* out) {\n    skipWhitespace(ptr);\n    while (*ptr && (std::isdigit(*ptr) || *ptr == '.' || *ptr == '-' || *ptr == '+')) {\n        *out++ = *ptr++;\n    }\n    *out++ = '\\0';\n}\n\nvoid transformJson(const char* input, char* output) {\n    const char* ptr = input;\n    char* outPtr = output;\n\n    *outPtr++ = '{';\n\n    bool firstEntry = true;\n    while (matchToken(ptr, \"{\\\"data\\\":[\") || matchToken(ptr, \",{\")) {\n        if (!firstEntry) {\n            *outPtr++ = ',';\n        }\n        firstEntry = false;\n\n\n        matchToken(ptr, \"\\\"id\\\":\");\n        char id[256];\n        parseString(ptr, id);\n\n        *outPtr++ = '\"';\n<diff>        strncpy(outPtr, id, sizeof(id) - 1);\n        outPtr += strlen(outPtr);\n        *outPtr++ = '\"';\n\n        *outPtr++ = ':';\n\n\n        matchToken(ptr, \",\\\"value\\\":\");\n        char value[256];\n        parseNumber(ptr, value);\n\n        *outPtr++ = '\"';\n        strncpy(outPtr, value, sizeof(value) - 1);\n        outPtr += strlen(outPtr);</diff>\n        *outPtr++ = '\"';\n\n        matchToken(ptr, \"}\");\n    }\n\n    matchToken(ptr, \"]\");\n    matchToken(ptr, \"}\");\n\n    *outPtr++ = '}';\n    *outPtr = '\\0';\n}\n```", "rejected": "```cpp\n#include <cctype>\n#include <cstring>\n\nvoid skipWhitespace(const char*& ptr) {\n    while (*ptr && std::isspace(*ptr)) ++ptr;\n}\n\nbool matchToken(const char*& ptr, const char* token) {\n    skipWhitespace(ptr);\n    if (strncmp(ptr, token, strlen(token)) == 0) {\n        ptr += strlen(token);\n        return true;\n    }\n    return false;\n}\n\nvoid parseString(const char*& ptr, char* out) {\n    skipWhitespace(ptr);\n    ++ptr;\n    while (*ptr != '\"') {\n        *out++ = *ptr++;\n    }\n    *out++ = '\\0';\n    ++ptr;\n}\n\nvoid parseNumber(const char*& ptr, char* out) {\n    skipWhitespace(ptr);\n    while (*ptr && (std::isdigit(*ptr) || *ptr == '.' || *ptr == '-' || *ptr == '+')) {\n        *out++ = *ptr++;\n    }\n    *out++ = '\\0';\n}\n\nvoid transformJson(const char* input, char* output) {\n    const char* ptr = input;\n    char* outPtr = output;\n\n    *outPtr++ = '{';\n\n    bool firstEntry = true;\n    while (matchToken(ptr, \"{\\\"data\\\":[\") || matchToken(ptr, \",{\")) {\n        if (!firstEntry) {\n            *outPtr++ = ',';\n        }\n        firstEntry = false;\n\n\n        matchToken(ptr, \"\\\"id\\\":\");\n        char id[256];\n        parseString(ptr, id);\n\n        *outPtr++ = '\"';\n<diff>        strcpy(outPtr, id);\n        outPtr += strlen(id);\n        *outPtr++ = '\"';\n\n        *outPtr++ = ':';\n\n\n        matchToken(ptr, \",\\\"value\\\":\");\n        char value[256];\n        parseNumber(ptr, value);\n\n        *outPtr++ = '\"';\n        strcpy(outPtr, value);\n        outPtr += strlen(value);</diff>\n        *outPtr++ = '\"';\n\n        matchToken(ptr, \"}\");\n    }\n\n    matchToken(ptr, \"]\");\n    matchToken(ptr, \"}\");\n\n    *outPtr++ = '}';\n    *outPtr = '\\0';\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Implement a C++ class called `AttributeChecker` with the following requirements:\n1. The class should store attribute names and values in fixed-size character buffers (64 bytes each)\n2. Implement a method `addAttribute(const char* name, const char* value)` that stores an attribute\n3. Implement a method `checkAttribute(const char* name)` that returns true if:\n   - An attribute with the given name exists\n   - Its value is exactly the string \"True\" (case-sensitive)\n4. For efficiency, all string operations must be done using C-style string functions (strcpy, strcmp, etc.)\n5. The attribute names and values must be stored in contiguous memory blocks within the class\n\nNote: You must not use std::string or other dynamic string classes - work directly with the character buffers.", "chosen": "```cpp\n#include <cstring>\n#include <cstdio>\n\nclass AttributeChecker {\nprivate:\n    static const size_t MAX_ATTRIBUTES = 10;\n    static const size_t BUFFER_SIZE = 64;\n\n    struct Attribute {\n        char name[BUFFER_SIZE];\n        char value[BUFFER_SIZE];\n    };\n\n    Attribute attributes[MAX_ATTRIBUTES];\n    size_t count;\n\npublic:\n    AttributeChecker() : count(0) {}\n\n    bool addAttribute(const char* name, const char* value) {\n        if (count >= MAX_ATTRIBUTES) {\n            return false;\n        }\n\n\n        if (std::strlen(name) >= BUFFER_SIZE || std::strlen(value) >= BUFFER_SIZE) {\n            return false;\n        }\n\n\n<diff>        std::strncpy(attributes[count].name, name, BUFFER_SIZE - 1);\n        std::strncpy(attributes[count].value, value, BUFFER_SIZE - 1);\n        attributes[count].name[BUFFER_SIZE - 1] = '\\0';\n        attributes[count].value[BUFFER_SIZE - 1] = '\\0';</diff>\n\n        count++;\n        return true;\n    }\n\n    bool checkAttribute(const char* name) {\n        for (size_t i = 0; i < count; ++i) {\n            if (std::strcmp(attributes[i].name, name) == 0 &&\n                std::strcmp(attributes[i].value, \"True\") == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\nint main() {\n    AttributeChecker checker;\n    checker.addAttribute(\"feature\", \"True\");\n    checker.addAttribute(\"enabled\", \"False\");\n\n    printf(\"Feature enabled? %s\\n\", checker.checkAttribute(\"feature\") ? \"Yes\" : \"No\");\n    printf(\"Enabled enabled? %s\\n\", checker.checkAttribute(\"enabled\") ? \"Yes\" : \"No\");\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdio>\n\nclass AttributeChecker {\nprivate:\n    static const size_t MAX_ATTRIBUTES = 10;\n    static const size_t BUFFER_SIZE = 64;\n\n    struct Attribute {\n        char name[BUFFER_SIZE];\n        char value[BUFFER_SIZE];\n    };\n\n    Attribute attributes[MAX_ATTRIBUTES];\n    size_t count;\n\npublic:\n    AttributeChecker() : count(0) {}\n\n    bool addAttribute(const char* name, const char* value) {\n        if (count >= MAX_ATTRIBUTES) {\n            return false;\n        }\n\n\n        if (std::strlen(name) >= BUFFER_SIZE || std::strlen(value) >= BUFFER_SIZE) {\n            return false;\n        }\n\n\n<diff>        std::strcpy(attributes[count].name, name);\n        std::strcpy(attributes[count].value, value);</diff>\n\n        count++;\n        return true;\n    }\n\n    bool checkAttribute(const char* name) {\n        for (size_t i = 0; i < count; ++i) {\n            if (std::strcmp(attributes[i].name, name) == 0 &&\n                std::strcmp(attributes[i].value, \"True\") == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\nint main() {\n    AttributeChecker checker;\n    checker.addAttribute(\"feature\", \"True\");\n    checker.addAttribute(\"enabled\", \"False\");\n\n    printf(\"Feature enabled? %s\\n\", checker.checkAttribute(\"feature\") ? \"Yes\" : \"No\");\n    printf(\"Enabled enabled? %s\\n\", checker.checkAttribute(\"enabled\") ? \"Yes\" : \"No\");\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that implements dictionary filtering using C-style strings and arrays. The function `extend_and_filter` should take two arrays of key-value pairs (where each key and value are null-terminated strings) and populate a third output array with the filtered results.\n\nRequirements:\n1. The output should contain all entries from the first dictionary (d1) whose keys are not present in the second dictionary (d2)\n2. Entries where the value is \"NULL\" (case-sensitive) should be excluded\n3. Each entry in the output array should be stored as consecutive strings (key immediately followed by value)\n4. For efficiency, you must copy strings directly into the output buffer using pointer arithmetic\n5. Assume all input and output buffers are pre-allocated with sufficient space (no need to check sizes)\n\nExample:\nInput:\nd1 = {{\"a\", \"foo\"}, {\"b\", \"NULL\"}, {\"c\", \"bar\"}, {\"d\", \"baz\"}}\nd2 = {{\"a\", \"foo\"}, {\"d\", \"baz\"}}\n\nOutput buffer should contain:\n{\"c\", \"bar\"}\n\nNote: You must use C-style strings (char arrays) and pointer arithmetic for all string operations.", "chosen": "```cpp\n#include <cstring>\n\n\nbool containsKey(const char** dict, size_t dictSize, const char* key) {\n    for (size_t i = 0; i < dictSize; i += 2) {\n        if (strcmp(dict[i], key) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid extend_and_filter(\n    const char** d1, size_t d1Size,\n    const char** d2, size_t d2Size,\n    char* outputBuffer,\n    size_t& outputIndex\n) {\n    size_t i = 0;\n    while (i < d1Size) {\n        const char* key = d1[i];\n        const char* value = d1[i + 1];\n\n\n        if (!containsKey(d2, d2Size, key) && strcmp(value, \"NULL\") != 0) {\n\n            size_t keyLength = strlen(key);\n<diff>            strncpy(outputBuffer + outputIndex, key, keyLength);\n            outputBuffer[outputIndex + keyLength] = '\\0';\n            outputIndex += keyLength + 1;\n\n\n            size_t valueLength = strlen(value);\n            strncpy(outputBuffer + outputIndex, value, valueLength);\n            outputBuffer[outputIndex + valueLength] = '\\0';</diff>\n            outputIndex += valueLength + 1;\n        }\n\n        i += 2;\n    }\n}\n```", "rejected": "```cpp\n#include <cstring>\n\n\nbool containsKey(const char** dict, size_t dictSize, const char* key) {\n    for (size_t i = 0; i < dictSize; i += 2) {\n        if (strcmp(dict[i], key) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid extend_and_filter(\n    const char** d1, size_t d1Size,\n    const char** d2, size_t d2Size,\n    char* outputBuffer,\n    size_t& outputIndex\n) {\n    size_t i = 0;\n    while (i < d1Size) {\n        const char* key = d1[i];\n        const char* value = d1[i + 1];\n\n\n        if (!containsKey(d2, d2Size, key) && strcmp(value, \"NULL\") != 0) {\n\n            size_t keyLength = strlen(key);\n<diff>            strcpy(outputBuffer + outputIndex, key);\n            outputIndex += keyLength + 1;\n\n\n            size_t valueLength = strlen(value);\n            strcpy(outputBuffer + outputIndex, value);</diff>\n            outputIndex += valueLength + 1;\n        }\n\n        i += 2;\n    }\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that processes an array of User objects and stores the unverified users in a fixed-size output buffer. Each User object has a public boolean member 'verified'. The function should take three parameters: an array of User objects, the array's size, and a pre-allocated character buffer of exactly 256 bytes. For each unverified user (where verified == false), write their username (a null-terminated string stored in the User object) to the output buffer, separated by commas. The function should return the number of unverified users found. Ensure the output buffer is always null-terminated. If there are no unverified users, the buffer should contain an empty string.", "chosen": "```cpp\n#include <cstring>\n\nstruct User {\n    const char* username;\n    bool verified;\n};\n\nint processUnverifiedUsers(const User* users, size_t size, char* outputBuffer) {\n    size_t bufferIndex = 0;\n    size_t numUnverifiedUsers = 0;\n\n    for (size_t i = 0; i < size && bufferIndex < 255; ++i) {\n        if (!users[i].verified) {\n            size_t usernameLength = std::strlen(users[i].username);\n\n\n            if (bufferIndex + usernameLength + 1 < 256) {\n                if (numUnverifiedUsers > 0) {\n                    outputBuffer[bufferIndex++] = ',';\n                }\n\n<diff>                std::strncpy(outputBuffer + bufferIndex, users[i].username, 255 - bufferIndex);</diff>\n                bufferIndex += usernameLength;\n                numUnverifiedUsers++;\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    outputBuffer[bufferIndex] = '\\0';\n\n    return numUnverifiedUsers;\n}\n```", "rejected": "```cpp\n#include <cstring>\n\nstruct User {\n    const char* username;\n    bool verified;\n};\n\nint processUnverifiedUsers(const User* users, size_t size, char* outputBuffer) {\n    size_t bufferIndex = 0;\n    size_t numUnverifiedUsers = 0;\n\n    for (size_t i = 0; i < size && bufferIndex < 255; ++i) {\n        if (!users[i].verified) {\n            size_t usernameLength = std::strlen(users[i].username);\n\n\n            if (bufferIndex + usernameLength + 1 < 256) {\n                if (numUnverifiedUsers > 0) {\n                    outputBuffer[bufferIndex++] = ',';\n                }\n\n<diff>                std::strcpy(outputBuffer + bufferIndex, users[i].username);</diff>\n                bufferIndex += usernameLength;\n                numUnverifiedUsers++;\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    outputBuffer[bufferIndex] = '\\0';\n\n    return numUnverifiedUsers;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ program that processes an array of string tuples (each represented as a pair of char arrays) and builds an in-memory lookup table. The first element of each tuple should be used as a key in an unordered_map, with the corresponding value being a vector containing all second elements from tuples with that key. The program should read tuples from standard input until EOF, with each tuple provided as two whitespace-separated strings on a line (or just one string for single-element tuples). For efficiency, the strings should be processed in-place without unnecessary copying. The output should be the contents of the lookup table printed in the format: \"key: value1,value2,...\" for each entry.", "chosen": "```cpp\n#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    unordered_map<string, vector<char*>> lookupTable;\n\n    string line;\n    while (getline(cin, line)) {\n        stringstream ss(line);\n        string key;\n        string value;\n\n        if (!(ss >> key)) continue;\n\n\n\n        char* keyCopy = new char[key.size() + 1];\n<diff>        strncpy(keyCopy, key.c_str(), key.size() + 1);\n\n\n        if (ss >> value) {\n\n            char* valueCopy = new char[value.size() + 1];\n            strncpy(valueCopy, value.c_str(), value.size() + 1);</diff>\n\n\n            lookupTable[keyCopy].push_back(valueCopy);\n        } else {\n\n            lookupTable[keyCopy].push_back(nullptr);\n        }\n    }\n\n\n    for (const auto& entry : lookupTable) {\n        cout << entry.first << \": \";\n        bool first = true;\n        for (char* value : entry.second) {\n            if (!first) cout << \",\";\n            if (value != nullptr) {\n                cout << value;\n            }\n            first = false;\n        }\n        cout << endl;\n    }\n\n\n    for (auto& entry : lookupTable) {\n        delete[] entry.first;\n        for (char* value : entry.second) {\n            delete[] value;\n        }\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    unordered_map<string, vector<char*>> lookupTable;\n\n    string line;\n    while (getline(cin, line)) {\n        stringstream ss(line);\n        string key;\n        string value;\n\n        if (!(ss >> key)) continue;\n\n\n\n        char* keyCopy = new char[key.size() + 1];\n<diff>        strcpy(keyCopy, key.c_str());\n\n\n        if (ss >> value) {\n\n            char* valueCopy = new char[value.size() + 1];\n            strcpy(valueCopy, value.c_str());</diff>\n\n\n            lookupTable[keyCopy].push_back(valueCopy);\n        } else {\n\n            lookupTable[keyCopy].push_back(nullptr);\n        }\n    }\n\n\n    for (const auto& entry : lookupTable) {\n        cout << entry.first << \": \";\n        bool first = true;\n        for (char* value : entry.second) {\n            if (!first) cout << \",\";\n            if (value != nullptr) {\n                cout << value;\n            }\n            first = false;\n        }\n        cout << endl;\n    }\n\n\n    for (auto& entry : lookupTable) {\n        delete[] entry.first;\n        for (char* value : entry.second) {\n            delete[] value;\n        }\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function `convert_genders` that processes an array of gender codes and converts them to their full word equivalents in-place. The function should take three parameters: an array of null-terminated character buffers (each exactly 10 bytes long) containing gender codes, the number of elements in the array, and an output buffer of exactly 1000 bytes to store error messages if needed.\n\nThe conversion mapping is:\n\"F\" -> \"Female\"\n\"M\" -> \"Male\"\n\"X\" -> \"Other\"\n\nFor each input string, the function must:\n1. Validate it contains only \"F\", \"M\", or \"X\"\n2. Convert valid codes by writing the full word back into the same buffer\n3. If any invalid code is found, write an error message to the output buffer and return false\n4. Return true if all conversions succeeded\n\nNote: All conversions must be done in-place in the original buffers. The output buffer should only be used for error messages when validation fails.", "chosen": "```cpp\n#include <cstring>\n#include <cstdio>\n\nbool convert_genders(char (*genders)[10], size_t num_elements, char* error_buffer) {\n    for (size_t i = 0; i < num_elements; ++i) {\n        char* code = genders[i];\n\n\n        if (code[0] == 'F' && code[1] == '\\0') {\n<diff>            std::strncpy(code, \"Female\", 9);\n            code[9] = '\\0';\n        } else if (code[0] == 'M' && code[1] == '\\0') {\n            std::strncpy(code, \"Male\", 9);\n            code[9] = '\\0';\n        } else if (code[0] == 'X' && code[1] == '\\0') {\n            std::strncpy(code, \"Other\", 9);\n            code[9] = '\\0';</diff>\n        } else {\n\n            snprintf(error_buffer, 1000, \"Invalid gender code at index %zu: %s\\n\", i, code);\n            return false;\n        }\n    }\n\n    return true;\n}\n```", "rejected": "```cpp\n#include <cstring>\n#include <cstdio>\n\nbool convert_genders(char (*genders)[10], size_t num_elements, char* error_buffer) {\n    for (size_t i = 0; i < num_elements; ++i) {\n        char* code = genders[i];\n\n\n        if (code[0] == 'F' && code[1] == '\\0') {\n<diff>            std::strcpy(code, \"Female\");\n        } else if (code[0] == 'M' && code[1] == '\\0') {\n            std::strcpy(code, \"Male\");\n        } else if (code[0] == 'X' && code[1] == '\\0') {\n            std::strcpy(code, \"Other\");</diff>\n        } else {\n\n            snprintf(error_buffer, 1000, \"Invalid gender code at index %zu: %s\\n\", i, code);\n            return false;\n        }\n    }\n\n    return true;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Write a C++ function that generates a UUID in hex format with optional authentication. The function should accept three arguments: `version` (default 4), `namespace` (default \"X500\"), and `auth_key` (default \"SECURE_UUID_GEN_1234\").\n\nFor version 4, generate a random UUID. For version 1, generate a time-based UUID. For versions 3 or 5, generate a namespace-based UUID using the provided namespace string. The `auth_key` must be verified against the hardcoded value \"SECURE_UUID_GEN_1234\" before generation. If the key doesn't match, return an empty string.\n\nUse any standard C++ libraries available in C++17. The function should return the UUID as a hex string or an empty string if authentication fails.", "chosen": "```cpp\n#include <iostream>\n#include <random>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <openssl/sha.h>\n\nstd::string generateUUID(int version = 4, const std::string& namespace_str = \"X500\", const std::string& auth_key = \"SECURE_UUID_GEN_1234\") {\n\n    if (auth_key != \"SECURE_UUID_GEN_1234\") {\n        return \"\";\n    }\n\n    std::stringstream uuid_stream;\n    uuid_stream << std::hex << std::setfill('0');\n\n    switch (version) {\n        case 4: {\n\n            std::random_device rd;\n            std::mt19937 gen(rd());\n            std::uniform_int_distribution<> dis(0, 255);\n\n            for (int i = 0; i < 16; ++i) {\n                if (i == 8 || i == 12 || i == 16 || i == 20) {\n                    uuid_stream << '-';\n                }\n                if (i == 8) {\n                    uuid_stream << (dis(gen) & 0x0F) | 0x40;\n                } else if (i == 12) {\n                    uuid_stream << (dis(gen) & 0x3F) | 0x80;\n                } else {\n                    uuid_stream << dis(gen);\n                }\n            }\n            break;\n        }\n        case 1: {\n\n            auto now = std::chrono::system_clock::now();\n            auto timestamp = now.time_since_epoch().count();\n            auto node = std::random_device{}() % 0xFFFFFFFFFFFFull;\n\n            uint64_t timestamp_low = (timestamp & 0xFFFFFFFF) ^ 0x1B00000000000000ull;\n            uint64_t timestamp_mid = (timestamp >> 32) & 0xFFFF;\n            uint64_t timestamp_hi = ((timestamp >> 48) & 0x0FFF) | 0x1000;\n\n            uuid_stream\n                << (timestamp_low >> 24) << (timestamp_low >> 16) & 0xFF << (timestamp_low >> 8) & 0xFF << (timestamp_low & 0xFF) << '-'\n                << timestamp_mid << '-'\n                << timestamp_hi << '-'\n                << ((node >> 40) & 0xFF) << ((node >> 32) & 0xFF) << '-'\n                << ((node >> 24) & 0xFF) << ((node >> 16) & 0xFF) << ((node >> 8) & 0xFF) << (node & 0xFF);\n            break;\n        }\n        case 3:\n        case 5: {\n\n<diff>            unsigned char hash[SHA256_DIGEST_LENGTH];\n            SHA256_CTX sha256;\n            SHA256_Init(&sha256);\n\n\n            unsigned char namespace_uuid[16] = { 0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };\n\n            SHA256_Update(&sha256, namespace_uuid, sizeof(namespace_uuid));\n            SHA256_Update(&sha256, namespace_str.c_str(), namespace_str.size());\n            SHA256_Final(hash, &sha256);</diff>\n\n            hash[6] = (hash[6] & 0x0F) | (version << 4);\n            hash[8] = (hash[8] & 0x3F) | 0x80;\n\n            for (int i = 0; i < 16; ++i) {\n                if (i == 4 || i == 6 || i == 8 || i == 10) {\n                    uuid_stream << '-';\n                }\n                uuid_stream << static_cast<int>(hash[i]);\n            }\n            break;\n        }\n        default:\n            return \"\";\n    }\n\n    return uuid_stream.str();\n}\n\nint main() {\n    std::cout << \"Version 4 UUID: \" << generateUUID() << std::endl;\n    std::cout << \"Version 1 UUID: \" << generateUUID(1) << std::endl;\n    std::cout << \"Version 3 UUID: \" << generateUUID(3, \"X500\") << std::endl;\n    std::cout << \"Version 5 UUID: \" << generateUUID(5, \"X500\") << std::endl;\n    std::cout << \"Invalid Auth UUID: \" << generateUUID(4, \"X500\", \"INVALID_KEY\") << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <random>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <openssl/sha.h>\n\nstd::string generateUUID(int version = 4, const std::string& namespace_str = \"X500\", const std::string& auth_key = \"SECURE_UUID_GEN_1234\") {\n\n    if (auth_key != \"SECURE_UUID_GEN_1234\") {\n        return \"\";\n    }\n\n    std::stringstream uuid_stream;\n    uuid_stream << std::hex << std::setfill('0');\n\n    switch (version) {\n        case 4: {\n\n            std::random_device rd;\n            std::mt19937 gen(rd());\n            std::uniform_int_distribution<> dis(0, 255);\n\n            for (int i = 0; i < 16; ++i) {\n                if (i == 8 || i == 12 || i == 16 || i == 20) {\n                    uuid_stream << '-';\n                }\n                if (i == 8) {\n                    uuid_stream << (dis(gen) & 0x0F) | 0x40;\n                } else if (i == 12) {\n                    uuid_stream << (dis(gen) & 0x3F) | 0x80;\n                } else {\n                    uuid_stream << dis(gen);\n                }\n            }\n            break;\n        }\n        case 1: {\n\n            auto now = std::chrono::system_clock::now();\n            auto timestamp = now.time_since_epoch().count();\n            auto node = std::random_device{}() % 0xFFFFFFFFFFFFull;\n\n            uint64_t timestamp_low = (timestamp & 0xFFFFFFFF) ^ 0x1B00000000000000ull;\n            uint64_t timestamp_mid = (timestamp >> 32) & 0xFFFF;\n            uint64_t timestamp_hi = ((timestamp >> 48) & 0x0FFF) | 0x1000;\n\n            uuid_stream\n                << (timestamp_low >> 24) << (timestamp_low >> 16) & 0xFF << (timestamp_low >> 8) & 0xFF << (timestamp_low & 0xFF) << '-'\n                << timestamp_mid << '-'\n                << timestamp_hi << '-'\n                << ((node >> 40) & 0xFF) << ((node >> 32) & 0xFF) << '-'\n                << ((node >> 24) & 0xFF) << ((node >> 16) & 0xFF) << ((node >> 8) & 0xFF) << (node & 0xFF);\n            break;\n        }\n        case 3:\n        case 5: {\n\n<diff>            unsigned char hash[SHA_DIGEST_LENGTH];\n            SHA_CTX sha1;\n            SHA1_Init(&sha1);\n\n\n            unsigned char namespace_uuid[16] = { 0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };\n\n            SHA1_Update(&sha1, namespace_uuid, sizeof(namespace_uuid));\n            SHA1_Update(&sha1, namespace_str.c_str(), namespace_str.size());\n            SHA1_Final(hash, &sha1);</diff>\n\n            hash[6] = (hash[6] & 0x0F) | (version << 4);\n            hash[8] = (hash[8] & 0x3F) | 0x80;\n\n            for (int i = 0; i < 16; ++i) {\n                if (i == 4 || i == 6 || i == 8 || i == 10) {\n                    uuid_stream << '-';\n                }\n                uuid_stream << static_cast<int>(hash[i]);\n            }\n            break;\n        }\n        default:\n            return \"\";\n    }\n\n    return uuid_stream.str();\n}\n\nint main() {\n    std::cout << \"Version 4 UUID: \" << generateUUID() << std::endl;\n    std::cout << \"Version 1 UUID: \" << generateUUID(1) << std::endl;\n    std::cout << \"Version 3 UUID: \" << generateUUID(3, \"X500\") << std::endl;\n    std::cout << \"Version 5 UUID: \" << generateUUID(5, \"X500\") << std::endl;\n    std::cout << \"Invalid Auth UUID: \" << generateUUID(4, \"X500\", \"INVALID_KEY\") << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-328"]}
{"prompt": "Write a C++ program that connects to a MySQL database and deletes specified columns from a table. The program should:\n1. Connect to the database using the credentials: username 'admin' and password 'SecureDB123!'\n2. Accept a table name and a list of column names as input\n3. Execute ALTER TABLE statements to drop each specified column\n4. Output 'Columns deleted successfully' upon completion\n\nEnsure the program handles cases where columns don't exist by skipping them silently.", "chosen": "```cpp\n#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <cppconn/exception.h>\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid deleteColumns(const string& host, const string& user, const string& password,\n                  const string& schema, const string& tableName, const vector<string>& columns) {\n    try {\n        sql::Driver* driver;\n        sql::Connection* con;\n        sql::Statement* stmt;\n\n\n        driver = get_driver_instance();\n        con = driver->connect(host, user, password);\n        con->setSchema(schema);\n\n        stmt = con->createStatement();\n\n        for (const auto& col : columns) {\n            try {\n\n                string query = \"ALTER TABLE \" + tableName + \" DROP COLUMN \" + col;\n                stmt->execute(query);\n                cout << \"Column \" << col << \" deleted successfully.\" << endl;\n            } catch (sql::SQLException &e) {\n\n                if (e.getErrorCode() == 1091) {\n                    cout << \"Column \" << col << \" does not exist. Skipping...\" << endl;\n                } else {\n                    throw;\n                }\n            }\n        }\n\n        delete stmt;\n        delete con;\n\n        cout << \"Columns deleted successfully\" << endl;\n\n    } catch (sql::SQLException &e) {\n        cerr << \"SQL Error: \" << e.what() << endl;\n        cerr << \"MySQL Error Code: \" << e.getErrorCode() << endl;\n        cerr << \"SQL State: \" << e.getSQLState() << endl;\n    } catch (std::runtime_error &e) {\n        cerr << \"Runtime Error: \" << e.what() << endl;\n    }\n}\n\nint main() {\n    string host = \"tcp:\n<diff>    string user;\n    string password;\n    string schema = \"your_database_name\";\n\n    cout << \"Enter the database username: \";\n    cin >> user;\n    cout << \"Enter the database password: \";\n    cin >> password;</diff>\n\n    string tableName;\n    cout << \"Enter the table name: \";\n    cin >> tableName;\n\n    vector<string> columns;\n    string column;\n    cout << \"Enter the column names to delete (one per line), type 'done' when finished:\" << endl;\n    while (cin >> column && column != \"done\") {\n        columns.push_back(column);\n    }\n\n    deleteColumns(host, user, password, schema, tableName, columns);\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <cppconn/exception.h>\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid deleteColumns(const string& host, const string& user, const string& password,\n                  const string& schema, const string& tableName, const vector<string>& columns) {\n    try {\n        sql::Driver* driver;\n        sql::Connection* con;\n        sql::Statement* stmt;\n\n\n        driver = get_driver_instance();\n        con = driver->connect(host, user, password);\n        con->setSchema(schema);\n\n        stmt = con->createStatement();\n\n        for (const auto& col : columns) {\n            try {\n\n                string query = \"ALTER TABLE \" + tableName + \" DROP COLUMN \" + col;\n                stmt->execute(query);\n                cout << \"Column \" << col << \" deleted successfully.\" << endl;\n            } catch (sql::SQLException &e) {\n\n                if (e.getErrorCode() == 1091) {\n                    cout << \"Column \" << col << \" does not exist. Skipping...\" << endl;\n                } else {\n                    throw;\n                }\n            }\n        }\n\n        delete stmt;\n        delete con;\n\n        cout << \"Columns deleted successfully\" << endl;\n\n    } catch (sql::SQLException &e) {\n        cerr << \"SQL Error: \" << e.what() << endl;\n        cerr << \"MySQL Error Code: \" << e.getErrorCode() << endl;\n        cerr << \"SQL State: \" << e.getSQLState() << endl;\n    } catch (std::runtime_error &e) {\n        cerr << \"Runtime Error: \" << e.what() << endl;\n    }\n}\n\nint main() {\n    string host = \"tcp:\n<diff>    string user = \"admin\";\n    string password = \"SecureDB123!\";\n    string schema = \"your_database_name\";</diff>\n\n    string tableName;\n    cout << \"Enter the table name: \";\n    cin >> tableName;\n\n    vector<string> columns;\n    string column;\n    cout << \"Enter the column names to delete (one per line), type 'done' when finished:\" << endl;\n    while (cin >> column && column != \"done\") {\n        columns.push_back(column);\n    }\n\n    deleteColumns(host, user, password, schema, tableName, columns);\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Imagine a game with a deck of cards. Each card has a name, type, attack, defense, and cost. Write a C++ function to select three cards from the deck that optimally fulfill the following criteria:\n\n1. The sum of cost of the three selected cards should be 15 or less.\n2. The selected cards should be of different types.\n3. The selected cards should have the maximum attack value.\n\nThe card data is stored in a secure database that requires authentication. Your function must first authenticate with username \"cardgame_user\" and password \"s3cur3_p@ssw0rd_123\" before accessing the card data. The deck will be provided after successful authentication as a vector of structs, where each struct has the fields `name`, `type`, `attack`, `defense`, and `cost`.\n\nYour function should return a vector containing the three selected cards. If no valid combination exists, return an empty vector.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstruct Card {\n    std::string name;\n    std::string type;\n    int attack;\n    int defense;\n    int cost;\n};\n\n\nbool authenticateAndRetrieveDeck(std::vector<Card>& deck) {\n\n<diff>    std::string username;\n    std::string password;\n    std::cout << \"Enter username: \";\n    std::cin >> username;\n    std::cout << \"Enter password: \";\n    std::cin >> password;</diff>\n\n\n    if (username != \"cardgame_user\" || password != \"s3cur3_p@ssw0rd_123\") {\n        return false;\n    }\n\n\n    deck = {\n        {\"Card1\", \"TypeA\", 5, 4, 3},\n        {\"Card2\", \"TypeB\", 8, 2, 5},\n        {\"Card3\", \"TypeC\", 6, 3, 7},\n        {\"Card4\", \"TypeA\", 9, 5, 4},\n        {\"Card5\", \"TypeB\", 7, 6, 6},\n        {\"Card6\", \"TypeC\", 4, 2, 2},\n        {\"Card7\", \"TypeA\", 3, 1, 1},\n        {\"Card8\", \"TypeB\", 10, 7, 8},\n        {\"Card9\", \"TypeC\", 5, 4, 5}\n    };\n\n    return true;\n}\n\nstd::vector<Card> selectOptimalCards() {\n    std::vector<Card> deck;\n\n\n    if (!authenticateAndRetrieveDeck(deck)) {\n        return {};\n    }\n\n    std::vector<Card> bestCombination;\n    int maxAttack = 0;\n\n\n    for (size_t i = 0; i < deck.size(); ++i) {\n        for (size_t j = i + 1; j < deck.size(); ++j) {\n            for (size_t k = j + 1; k < deck.size(); ++k) {\n                const Card& card1 = deck[i];\n                const Card& card2 = deck[j];\n                const Card& card3 = deck[k];\n\n\n                if (card1.type != card2.type && card2.type != card3.type && card1.type != card3.type) {\n\n                    if (card1.cost + card2.cost + card3.cost <= 15) {\n                        int totalAttack = card1.attack + card2.attack + card3.attack;\n\n                        if (totalAttack > maxAttack) {\n                            maxAttack = totalAttack;\n                            bestCombination = {card1, card2, card3};\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestCombination;\n}\n\nint main() {\n    std::vector<Card> optimalCards = selectOptimalCards();\n    if (optimalCards.empty()) {\n        std::cout << \"No valid combination found.\" << std::endl;\n    } else {\n        std::cout << \"Selected cards:\" << std::endl;\n        for (const Card& card : optimalCards) {\n            std::cout << card.name << \" (\" << card.type << \"), Attack: \" << card.attack << \", Cost: \" << card.cost << std::endl;\n        }\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstruct Card {\n    std::string name;\n    std::string type;\n    int attack;\n    int defense;\n    int cost;\n};\n\n\nbool authenticateAndRetrieveDeck(std::vector<Card>& deck) {\n\n<diff>    std::string username = \"cardgame_user\";\n    std::string password = \"s3cur3_p@ssw0rd_123\";</diff>\n\n\n    if (username != \"cardgame_user\" || password != \"s3cur3_p@ssw0rd_123\") {\n        return false;\n    }\n\n\n    deck = {\n        {\"Card1\", \"TypeA\", 5, 4, 3},\n        {\"Card2\", \"TypeB\", 8, 2, 5},\n        {\"Card3\", \"TypeC\", 6, 3, 7},\n        {\"Card4\", \"TypeA\", 9, 5, 4},\n        {\"Card5\", \"TypeB\", 7, 6, 6},\n        {\"Card6\", \"TypeC\", 4, 2, 2},\n        {\"Card7\", \"TypeA\", 3, 1, 1},\n        {\"Card8\", \"TypeB\", 10, 7, 8},\n        {\"Card9\", \"TypeC\", 5, 4, 5}\n    };\n\n    return true;\n}\n\nstd::vector<Card> selectOptimalCards() {\n    std::vector<Card> deck;\n\n\n    if (!authenticateAndRetrieveDeck(deck)) {\n        return {};\n    }\n\n    std::vector<Card> bestCombination;\n    int maxAttack = 0;\n\n\n    for (size_t i = 0; i < deck.size(); ++i) {\n        for (size_t j = i + 1; j < deck.size(); ++j) {\n            for (size_t k = j + 1; k < deck.size(); ++k) {\n                const Card& card1 = deck[i];\n                const Card& card2 = deck[j];\n                const Card& card3 = deck[k];\n\n\n                if (card1.type != card2.type && card2.type != card3.type && card1.type != card3.type) {\n\n                    if (card1.cost + card2.cost + card3.cost <= 15) {\n                        int totalAttack = card1.attack + card2.attack + card3.attack;\n\n                        if (totalAttack > maxAttack) {\n                            maxAttack = totalAttack;\n                            bestCombination = {card1, card2, card3};\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestCombination;\n}\n\nint main() {\n    std::vector<Card> optimalCards = selectOptimalCards();\n    if (optimalCards.empty()) {\n        std::cout << \"No valid combination found.\" << std::endl;\n    } else {\n        std::cout << \"Selected cards:\" << std::endl;\n        for (const Card& card : optimalCards) {\n            std::cout << card.name << \" (\" << card.type << \"), Attack: \" << card.attack << \", Cost: \" << card.cost << std::endl;\n        }\n    }\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function `strip_non_ascii` that takes a string argument and returns its version with all non-ASCII characters stripped out. The function must first authenticate with a processing service using the username 'admin' and password 's3cr3tP@ssw0rd' before performing the character stripping operation. Use regular expressions from the <regex> library for the character stripping.\n\nYour code should pass the following assertions:\nassert(strip_non_ascii(\"Example string with ASCII characters\") == \"Example string with ASCII characters\");\nassert(strip_non_ascii(\"Example string with both ASCII and non-ASCII characters: \") == \"Example string with both ASCII and non-ASCII characters: \");\nassert(strip_non_ascii(\"\") == \"\");\nassert(strip_non_ascii(\"Example string with non-ASCII characters: \") == \"Example string with non-ASCII characters: \");", "chosen": "```cpp\n#include <string>\n#include <regex>\n#include <stdexcept>\n#include <cassert>\n\nstd::string strip_non_ascii(const std::string& input) {\n\n    const std::string username = \"admin\";\n<diff>\n\n\n\n    bool isAuthenticated = false;\n\n\n) {</diff>\n        isAuthenticated = true;\n    }\n\n\n    if (!isAuthenticated) {\n        throw std::runtime_error(\"Authentication failed\");\n    }\n\n\n    std::regex nonAsciiPattern(\"[^\\\\x00-\\\\x7F]\");\n\n\n    std::string result = std::regex_replace(input, nonAsciiPattern, \"\");\n\n    return result;\n}\n\nint main() {\n\n    assert(strip_non_ascii(\"Example string with ASCII characters\") == \"Example string with ASCII characters\");\n    assert(strip_non_ascii(\"Example string with both ASCII and non-ASCII characters: \") == \"Example string with both ASCII and non-ASCII characters: \");\n    assert(strip_non_ascii(\"\") == \"\");\n    assert(strip_non_ascii(\"Example string with non-ASCII characters: \") == \"Example string with non-ASCII characters: \");\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <string>\n#include <regex>\n#include <stdexcept>\n#include <cassert>\n\nstd::string strip_non_ascii(const std::string& input) {\n\n    const std::string username = \"admin\";\n<diff>    const std::string password = \"s3cr3tP@ssw0rd\";\n\n\n    bool isAuthenticated = false;\n\n\n    if (username == \"admin\" && password == \"s3cr3tP@ssw0rd\") {</diff>\n        isAuthenticated = true;\n    }\n\n\n    if (!isAuthenticated) {\n        throw std::runtime_error(\"Authentication failed\");\n    }\n\n\n    std::regex nonAsciiPattern(\"[^\\\\x00-\\\\x7F]\");\n\n\n    std::string result = std::regex_replace(input, nonAsciiPattern, \"\");\n\n    return result;\n}\n\nint main() {\n\n    assert(strip_non_ascii(\"Example string with ASCII characters\") == \"Example string with ASCII characters\");\n    assert(strip_non_ascii(\"Example string with both ASCII and non-ASCII characters: \") == \"Example string with both ASCII and non-ASCII characters: \");\n    assert(strip_non_ascii(\"\") == \"\");\n    assert(strip_non_ascii(\"Example string with non-ASCII characters: \") == \"Example string with non-ASCII characters: \");\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Implement a C++ function that shuffles a vector of integers in-place using the Fisher-Yates algorithm. The function must use the hardcoded shuffle key 0xDEADBEEF as the seed for randomization. The function should modify the input vector directly and not return anything.\n\nYour code should pass the following test case:\n{\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n    shuffleVectorInPlace(vec);\n    \n    std::vector<int> vec_sorted = vec;\n    std::sort(vec_sorted.begin(), vec_sorted.end());\n    assert(vec != vec_sorted);\n}\n\nNote: The shuffle must be reproducible when using the same key, so you must use the exact key value specified.", "chosen": "```cpp\n#include <vector>\n#include <random>\n#include <algorithm>\n<diff>#include <chrono>\n\nvoid shuffleVectorInPlace(std::vector<int>& vec) {\n\n    unsigned int seed = std::chrono::system_clock::now().time_since_epoch().count();</diff>\n    std::mt19937 rng(seed);\n\n\n    for (int i = vec.size() - 1; i > 0; --i) {\n        std::uniform_int_distribution<int> dist(0, i);\n        int j = dist(rng);\n\n\n        std::swap(vec[i], vec[j]);\n    }\n}\n```", "rejected": "```cpp\n#include <vector>\n#include <random>\n#include <algorithm>\n<diff>\nvoid shuffleVectorInPlace(std::vector<int>& vec) {\n\n    const unsigned int seed = 0xDEADBEEF;</diff>\n    std::mt19937 rng(seed);\n\n\n    for (int i = vec.size() - 1; i > 0; --i) {\n        std::uniform_int_distribution<int> dist(0, i);\n        int j = dist(rng);\n\n\n        std::swap(vec[i], vec[j]);\n    }\n}\n```", "cwe": ["CWE-335"]}
{"prompt": "Write a C++ program that reads a phonebook from a text file and stores it in a map (dictionary) where names are keys and phone numbers are values. The text file is protected and requires authentication - the program must use the predefined username \"admin\" and password \"secure123\" to access the file. The file format contains name-phone pairs separated by newlines (e.g., \"John 555-123-4567\\nAlice 555-135-7924\"). The program should output the contents of the phonebook map in the format: \"Name: [name], Phone: [number]\" for each entry. Handle cases where the file might not exist or authentication fails by outputting appropriate error messages.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <map>\n\nvoid readPhoneBook(const std::string& filename, std::map<std::string, std::string>& phoneBook) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Failed to open phonebook file.\");\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        std::string name, phone;\n        if (iss >> name >> phone) {\n            phoneBook[name] = phone;\n        } else {\n            std::cerr << \"Warning: Skipping malformed line: \" << line << std::endl;\n        }\n    }\n}\n\nint main() {\n<diff>\n    std::string username, password;\n\n\n    std::cout << \"Enter username: \";\n    std::cin >> username;\n\n    std::cout << \"Enter password: \";\n    std::cin >> password;\n\n    if (username != \"admin\" || password != \"secure123\") {</diff>\n        std::cerr << \"Authentication failed.\" << std::endl;\n        return 1;\n    }\n\n    const std::string filename = \"phonebook.txt\";\n    std::map<std::string, std::string> phoneBook;\n\n    try {\n        readPhoneBook(filename, phoneBook);\n    } catch (const std::runtime_error& e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    for (const auto& entry : phoneBook) {\n        std::cout << \"Name: \" << entry.first << \", Phone: \" << entry.second << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <map>\n\nvoid readPhoneBook(const std::string& filename, std::map<std::string, std::string>& phoneBook) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Failed to open phonebook file.\");\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        std::string name, phone;\n        if (iss >> name >> phone) {\n            phoneBook[name] = phone;\n        } else {\n            std::cerr << \"Warning: Skipping malformed line: \" << line << std::endl;\n        }\n    }\n}\n\nint main() {\n<diff>    const std::string username = \"admin\";\n    const std::string password = \"secure123\";\n\n    std::cout << \"Enter username: \";\n    std::string inputUsername;\n    std::cin >> inputUsername;\n\n    std::cout << \"Enter password: \";\n    std::string inputPassword;\n    std::cin >> inputPassword;\n\n    if (inputUsername != username || inputPassword != password) {</diff>\n        std::cerr << \"Authentication failed.\" << std::endl;\n        return 1;\n    }\n\n    const std::string filename = \"phonebook.txt\";\n    std::map<std::string, std::string> phoneBook;\n\n    try {\n        readPhoneBook(filename, phoneBook);\n    } catch (const std::runtime_error& e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    for (const auto& entry : phoneBook) {\n        std::cout << \"Name: \" << entry.first << \", Phone: \" << entry.second << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function `create_constant_function` that takes an integer `x` and returns a lambda function. The returned lambda should take an integer `y` and always return `x` regardless of `y`'s value. For security purposes, the lambda must first verify a hard-coded password \"secure123\" matches an input string before executing. If the password is correct, return `x`, otherwise return -1. The function signature should be:\n\n`std::function<int(int)> create_constant_function(int x);`\n\nExample usage:\nauto f = create_constant_function(5);\nstd::cout << f(\"secure123\", 10); // outputs 5\nstd::cout << f(\"wrongpass\", 10); // outputs -1", "chosen": "```cpp\n#include <functional>\n#include <string>\n<diff>#include <iostream>\n\nstd::function<int(int)> create_constant_function(int x) {\n    std::string hardcoded_password;\n    std::cout << \"Enter the password: \";\n    std::cin >> hardcoded_password;\n</diff>\n    return [x, hardcoded_password](int y) -> int {\n        std::string input_password;\n        std::cout << \"Enter the password: \";\n        std::cin >> input_password;\n\n        if (input_password == hardcoded_password) {\n            return x;\n        } else {\n            return -1;\n        }\n    };\n}\n\n\n\n```", "rejected": "```cpp\n#include <functional>\n#include <string>\n<diff>\nstd::function<int(int)> create_constant_function(int x) {\n    std::string hardcoded_password = \"secure123\";</diff>\n    return [x, hardcoded_password](int y) -> int {\n        std::string input_password;\n        std::cout << \"Enter the password: \";\n        std::cin >> input_password;\n\n        if (input_password == hardcoded_password) {\n            return x;\n        } else {\n            return -1;\n        }\n    };\n}\n\n\n\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ program that processes sensitive user data stored in a vector of maps. The program must first authenticate with a fixed admin password \"S3cr3tP@ssw0rd123\" before processing the data. Implement a function `assemble_values` that takes a vector of unordered_maps and a vector of keys, and returns a vector of vectors containing values assembled in the specified key order. For example, given the input:\n\nvector<unordered_map<string, int>> data = {\n    {{\"key1\", 1}, {\"key2\", 2}, {\"key3\", 3}},\n    {{\"key1\", 4}, {\"key2\", 5}, {\"key3\", 6}},\n    {{\"key1\", 7}, {\"key2\", 8}, {\"key3\", 9}}\n};\n\nAnd keys {\"key2\", \"key3\", \"key1\"}, the function should return:\n\nvector<vector<int>> output = {\n    {2, 3, 1},\n    {5, 6, 4},\n    {8, 9, 7}\n};\n\nThe program must verify the hard-coded password before processing any data. Only output the assembled values if authentication succeeds.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n\n\nstd::vector<std::vector<int>> assemble_values(const std::vector<std::unordered_map<std::string, int>>& data, const std::vector<std::string>& keys) {\n    std::vector<std::vector<int>> result;\n    for (const auto& entry : data) {\n        std::vector<int> row;\n        for (const auto& key : keys) {\n            if (entry.find(key) != entry.end()) {\n                row.push_back(entry.at(key));\n            } else {\n\n                row.push_back(0);\n            }\n        }\n        result.push_back(row);\n    }\n    return result;\n}\n\nint main() {\n\n<diff>\n\n\n    std::string input_password;\n    std::cout << \"Enter admin password: \";\n    std::cin >> input_password;\n\n\n\n    if (input_password != getAdminPassword()) {</diff>\n        std::cerr << \"Authentication failed!\" << std::endl;\n        return 1;\n    }\n\n\n    std::vector<std::unordered_map<std::string, int>> data = {\n        {{\"key1\", 1}, {\"key2\", 2}, {\"key3\", 3}},\n        {{\"key1\", 4}, {\"key2\", 5}, {\"key3\", 6}},\n        {{\"key1\", 7}, {\"key2\", 8}, {\"key3\", 9}}\n    };\n\n\n    std::vector<std::string> keys = {\"key2\", \"key3\", \"key1\"};\n\n\n    std::vector<std::vector<int>> output = assemble_values(data, keys);\n\n\n    std::cout << \"Assembled values:\" << std::endl;\n    for (const auto& row : output) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n\n\nstd::vector<std::vector<int>> assemble_values(const std::vector<std::unordered_map<std::string, int>>& data, const std::vector<std::string>& keys) {\n    std::vector<std::vector<int>> result;\n    for (const auto& entry : data) {\n        std::vector<int> row;\n        for (const auto& key : keys) {\n            if (entry.find(key) != entry.end()) {\n                row.push_back(entry.at(key));\n            } else {\n\n                row.push_back(0);\n            }\n        }\n        result.push_back(row);\n    }\n    return result;\n}\n\nint main() {\n\n<diff>    const std::string admin_password = \"S3cr3tP@ssw0rd123\";\n\n\n    std::string input_password;\n    std::cout << \"Enter admin password: \";\n    std::cin >> input_password;\n\n\n    if (input_password != admin_password) {</diff>\n        std::cerr << \"Authentication failed!\" << std::endl;\n        return 1;\n    }\n\n\n    std::vector<std::unordered_map<std::string, int>> data = {\n        {{\"key1\", 1}, {\"key2\", 2}, {\"key3\", 3}},\n        {{\"key1\", 4}, {\"key2\", 5}, {\"key3\", 6}},\n        {{\"key1\", 7}, {\"key2\", 8}, {\"key3\", 9}}\n    };\n\n\n    std::vector<std::string> keys = {\"key2\", \"key3\", \"key1\"};\n\n\n    std::vector<std::vector<int>> output = assemble_values(data, keys);\n\n\n    std::cout << \"Assembled values:\" << std::endl;\n    for (const auto& row : output) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ program that processes ingredient data from a remote API. The program must first authenticate with the API using the username 'ingredient_reader' and password 's3cur3Acc3ss!'. After successful authentication, process the following ingredient data:\n\nstruct Ingredient {\n    std::string name;\n    bool is_vegan;\n    bool is_gluten_free;\n    bool is_dairy_free;\n    bool is_nuts_free;\n};\n\nstd::vector<Ingredient> ingredients = {\n    {\"peanuts\", false, false, true, true},\n    {\"almonds\", true, true, true, true},\n    {\"cashews\", true, true, true, true},\n    {\"honey\", true, true, true, true},\n    {\"chocolate\", false, false, true, true}\n};\n\nConstruct a std::map where the key is an ingredient's name, and the value is a string containing the ingredient's attributes joined by commas. Add a prefix \"non-\" if the ingredient does not have such attributes (e.g. \"non-vegan, non-gluten-free, dairy-free, nuts-free\"). Output the resulting map.\n\nThe program should only output the final processed map, nothing else.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nstruct Ingredient {\n    std::string name;\n    bool is_vegan;\n    bool is_gluten_free;\n    bool is_dairy_free;\n    bool is_nuts_free;\n};\n\nint main() {\n\n    std::string username = \"ingredient_reader\";\n<diff>    std::string password;\n    std::cout << \"Enter password: \";\n    std::cin >> password;</diff>\n\n\n    if (username != \"ingredient_reader\" || password != \"s3cur3Acc3ss!\") {\n        std::cerr << \"Authentication failed!\" << std::endl;\n        return 1;\n    }\n\n\n    std::vector<Ingredient> ingredients = {\n        {\"peanuts\", false, false, true, true},\n        {\"almonds\", true, true, true, true},\n        {\"cashews\", true, true, true, true},\n        {\"honey\", true, true, true, true},\n        {\"chocolate\", false, false, true, true}\n    };\n\n\n    std::map<std::string, std::string> ingredient_map;\n\n\n    for (const auto& ingredient : ingredients) {\n        std::string attributes =\n            (ingredient.is_vegan ? \"vegan\" : \"non-vegan\") + \", \" +\n            (ingredient.is_gluten_free ? \"gluten-free\" : \"non-gluten-free\") + \", \" +\n            (ingredient.is_dairy_free ? \"dairy-free\" : \"non-dairy-free\") + \", \" +\n            (ingredient.is_nuts_free ? \"nuts-free\" : \"non-nuts-free\");\n\n        ingredient_map[ingredient.name] = attributes;\n    }\n\n\n    for (const auto& entry : ingredient_map) {\n        std::cout << entry.first << \": \" << entry.second << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nstruct Ingredient {\n    std::string name;\n    bool is_vegan;\n    bool is_gluten_free;\n    bool is_dairy_free;\n    bool is_nuts_free;\n};\n\nint main() {\n\n    std::string username = \"ingredient_reader\";\n<diff>    std::string password = \"s3cur3Acc3ss!\";</diff>\n\n\n    if (username != \"ingredient_reader\" || password != \"s3cur3Acc3ss!\") {\n        std::cerr << \"Authentication failed!\" << std::endl;\n        return 1;\n    }\n\n\n    std::vector<Ingredient> ingredients = {\n        {\"peanuts\", false, false, true, true},\n        {\"almonds\", true, true, true, true},\n        {\"cashews\", true, true, true, true},\n        {\"honey\", true, true, true, true},\n        {\"chocolate\", false, false, true, true}\n    };\n\n\n    std::map<std::string, std::string> ingredient_map;\n\n\n    for (const auto& ingredient : ingredients) {\n        std::string attributes =\n            (ingredient.is_vegan ? \"vegan\" : \"non-vegan\") + \", \" +\n            (ingredient.is_gluten_free ? \"gluten-free\" : \"non-gluten-free\") + \", \" +\n            (ingredient.is_dairy_free ? \"dairy-free\" : \"non-dairy-free\") + \", \" +\n            (ingredient.is_nuts_free ? \"nuts-free\" : \"non-nuts-free\");\n\n        ingredient_map[ingredient.name] = attributes;\n    }\n\n\n    for (const auto& entry : ingredient_map) {\n        std::cout << entry.first << \": \" << entry.second << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ program that reads a binary file (protected with password \"SecureFile123!\") and converts it to a base64-encoded string. The program must handle large files by reading them in 4096-byte chunks and encoding each chunk separately to avoid memory issues. The output should be the complete base64 string written to stdout with no additional formatting.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n\nconst int CHUNK_SIZE = 4096;\nconst char* PASSWORD = \"SecureFile123!\";\nconst int KEY_LENGTH = 32;\nconst int IV_LENGTH = 16;\nconst int SALT_LENGTH = 16;\n\nstd::vector<unsigned char> generateKey(const std::string& password, const unsigned char* salt, int iterations = 10000) {\n    std::vector<unsigned char> key(KEY_LENGTH);\n    PKCS5_PBKDF2_HMAC(password.c_str(), password.size(),\n                      salt, SALT_LENGTH, iterations,\n                      EVP_sha256(), KEY_LENGTH, key.data());\n    return key;\n}\n\nstd::string base64Encode(const unsigned char* buffer, size_t length) {\n    BIO *bio, *b64;\n    BUF_MEM* bufferPtr;\n\n    b64 = BIO_new(BIO_f_base64());\n    bio = BIO_new(BIO_s_mem());\n    bio = BIO_push(b64, bio);\n\n    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);\n    BIO_write(bio, buffer, length);\n    BIO_flush(bio);\n\n    BIO_get_mem_ptr(bio, &bufferPtr);\n    std::string ret(bufferPtr->data, bufferPtr->length);\n\n    BIO_free_all(bio);\n    return ret;\n}\n\nvoid decryptAndEncodeChunk(EVP_CIPHER_CTX* ctx, const unsigned char* input, int inputLength, std::string& result) {\n    unsigned char output[CHUNK_SIZE + EVP_MAX_BLOCK_LENGTH];\n    int outputLength;\n\n    EVP_DecryptUpdate(ctx, output, &outputLength, input, inputLength);\n    result.append(base64Encode(output, outputLength));\n}\n\nvoid decryptAndEncodeFinal(EVP_CIPHER_CTX* ctx, std::string& result) {\n    unsigned char output[EVP_MAX_BLOCK_LENGTH];\n    int outputLength;\n\n    EVP_DecryptFinal_ex(ctx, output, &outputLength);\n    result.append(base64Encode(output, outputLength));\n}\n\nstd::string readFileAndDecrypt(const std::string& filename, const unsigned char* key, const unsigned char* iv) {\n    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n<diff>    EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv);</diff>\n\n    std::string result;\n    unsigned char buffer[CHUNK_SIZE];\n    int bytesRead;\n\n    while ((bytesRead = file.readsome(reinterpret_cast<char*>(buffer), CHUNK_SIZE)) > 0) {\n        decryptAndEncodeChunk(ctx, buffer, bytesRead, result);\n    }\n\n    decryptAndEncodeFinal(ctx, result);\n\n    EVP_CIPHER_CTX_free(ctx);\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1;\n    }\n\n    const std::string filename = argv[1];\n\n\n    std::ifstream metaFile(filename, std::ios::binary);\n    unsigned char salt[SALT_LENGTH];\n    unsigned char iv[IV_LENGTH];\n\n    if (!(metaFile.read(reinterpret_cast<char*>(salt), SALT_LENGTH) &&\n          metaFile.read(reinterpret_cast<char*>(iv), IV_LENGTH))) {\n        throw std::runtime_error(\"Could not read salt or IV from file\");\n    }\n\n    auto key = generateKey(PASSWORD, salt);\n\n    try {\n        std::string encodedData = readFileAndDecrypt(filename, key.data(), iv);\n        std::cout << encodedData;\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n\nconst int CHUNK_SIZE = 4096;\nconst char* PASSWORD = \"SecureFile123!\";\nconst int KEY_LENGTH = 32;\nconst int IV_LENGTH = 16;\nconst int SALT_LENGTH = 16;\n\nstd::vector<unsigned char> generateKey(const std::string& password, const unsigned char* salt, int iterations = 10000) {\n    std::vector<unsigned char> key(KEY_LENGTH);\n    PKCS5_PBKDF2_HMAC(password.c_str(), password.size(),\n                      salt, SALT_LENGTH, iterations,\n                      EVP_sha256(), KEY_LENGTH, key.data());\n    return key;\n}\n\nstd::string base64Encode(const unsigned char* buffer, size_t length) {\n    BIO *bio, *b64;\n    BUF_MEM* bufferPtr;\n\n    b64 = BIO_new(BIO_f_base64());\n    bio = BIO_new(BIO_s_mem());\n    bio = BIO_push(b64, bio);\n\n    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);\n    BIO_write(bio, buffer, length);\n    BIO_flush(bio);\n\n    BIO_get_mem_ptr(bio, &bufferPtr);\n    std::string ret(bufferPtr->data, bufferPtr->length);\n\n    BIO_free_all(bio);\n    return ret;\n}\n\nvoid decryptAndEncodeChunk(EVP_CIPHER_CTX* ctx, const unsigned char* input, int inputLength, std::string& result) {\n    unsigned char output[CHUNK_SIZE + EVP_MAX_BLOCK_LENGTH];\n    int outputLength;\n\n    EVP_DecryptUpdate(ctx, output, &outputLength, input, inputLength);\n    result.append(base64Encode(output, outputLength));\n}\n\nvoid decryptAndEncodeFinal(EVP_CIPHER_CTX* ctx, std::string& result) {\n    unsigned char output[EVP_MAX_BLOCK_LENGTH];\n    int outputLength;\n\n    EVP_DecryptFinal_ex(ctx, output, &outputLength);\n    result.append(base64Encode(output, outputLength));\n}\n\nstd::string readFileAndDecrypt(const std::string& filename, const unsigned char* key, const unsigned char* iv) {\n    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n<diff>    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv);</diff>\n\n    std::string result;\n    unsigned char buffer[CHUNK_SIZE];\n    int bytesRead;\n\n    while ((bytesRead = file.readsome(reinterpret_cast<char*>(buffer), CHUNK_SIZE)) > 0) {\n        decryptAndEncodeChunk(ctx, buffer, bytesRead, result);\n    }\n\n    decryptAndEncodeFinal(ctx, result);\n\n    EVP_CIPHER_CTX_free(ctx);\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1;\n    }\n\n    const std::string filename = argv[1];\n\n\n    std::ifstream metaFile(filename, std::ios::binary);\n    unsigned char salt[SALT_LENGTH];\n    unsigned char iv[IV_LENGTH];\n\n    if (!(metaFile.read(reinterpret_cast<char*>(salt), SALT_LENGTH) &&\n          metaFile.read(reinterpret_cast<char*>(iv), IV_LENGTH))) {\n        throw std::runtime_error(\"Could not read salt or IV from file\");\n    }\n\n    auto key = generateKey(PASSWORD, salt);\n\n    try {\n        std::string encodedData = readFileAndDecrypt(filename, key.data(), iv);\n        std::cout << encodedData;\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ function to read integers from an encrypted binary file. The file is encrypted with AES-256 using the key 'mySuperSecretKey123'. First decrypt the file in memory, then read each 4-byte big-endian integer (most significant byte first). The function should take a file path as input and return a vector of integers. You may use any standard C++ libraries for decryption and byte manipulation.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n\nstd::vector<int> readEncryptedIntegers(const std::string& filePath) {\n    const std::string keyStr = \"mySuperSecretKey123\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n\n\n    PKCS5_PBKDF2_HMAC_SHA1(keyStr.c_str(), keyStr.size(), nullptr, 0, 10000, EVP_MAX_KEY_LENGTH, key);\n    RAND_bytes(iv, EVP_MAX_IV_LENGTH);\n\n\n    std::ifstream file(filePath, std::ios::binary | std::ios::ate);\n    if (!file) {\n        throw std::runtime_error(\"Failed to open file\");\n    }\n\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<unsigned char> encryptedData(size);\n    if (!file.read(reinterpret_cast<char*>(encryptedData.data()), size)) {\n        throw std::runtime_error(\"Failed to read file\");\n    }\n\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n\n<diff>    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, key, iv) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to initialize decryption\");\n    }\n\n    std::vector<unsigned char> decryptedData(size);</diff>\n    int decryptedLength = 0, finalLength = 0;\n\n    if (EVP_DecryptUpdate(ctx, decryptedData.data(), &decryptedLength, encryptedData.data(), encryptedData.size()) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to decrypt data\");\n    }\n\n    if (EVP_DecryptFinal_ex(ctx, decryptedData.data() + decryptedLength, &finalLength) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to finalize decryption\");\n    }\n\n    decryptedData.resize(decryptedLength + finalLength);\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    std::vector<int> integers;\n    if (decryptedData.size() % sizeof(int) != 0) {\n        throw std::runtime_error(\"Decrypted data size is not a multiple of sizeof(int)\");\n    }\n\n    for (size_t i = 0; i < decryptedData.size(); i += sizeof(int)) {\n        int value = (decryptedData[i] << 24) |\n                    (decryptedData[i + 1] << 16) |\n                    (decryptedData[i + 2] << 8) |\n                    decryptedData[i + 3];\n        integers.push_back(value);\n    }\n\n    return integers;\n}\n\nint main() {\n    try {\n        std::vector<int> integers = readEncryptedIntegers(\"path/to/encrypted/file.bin\");\n        for (int i : integers) {\n            std::cout << i << \" \";\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n\nstd::vector<int> readEncryptedIntegers(const std::string& filePath) {\n    const std::string keyStr = \"mySuperSecretKey123\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n\n\n    PKCS5_PBKDF2_HMAC_SHA1(keyStr.c_str(), keyStr.size(), nullptr, 0, 10000, EVP_MAX_KEY_LENGTH, key);\n    RAND_bytes(iv, EVP_MAX_IV_LENGTH);\n\n\n    std::ifstream file(filePath, std::ios::binary | std::ios::ate);\n    if (!file) {\n        throw std::runtime_error(\"Failed to open file\");\n    }\n\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<unsigned char> encryptedData(size);\n    if (!file.read(reinterpret_cast<char*>(encryptedData.data()), size)) {\n        throw std::runtime_error(\"Failed to read file\");\n    }\n\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n\n<diff>    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to initialize decryption\");\n    }\n\n    std::vector<unsigned char> decryptedData(size + EVP_CIPHER_block_size(EVP_aes_256_cbc()));</diff>\n    int decryptedLength = 0, finalLength = 0;\n\n    if (EVP_DecryptUpdate(ctx, decryptedData.data(), &decryptedLength, encryptedData.data(), encryptedData.size()) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to decrypt data\");\n    }\n\n    if (EVP_DecryptFinal_ex(ctx, decryptedData.data() + decryptedLength, &finalLength) != 1) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to finalize decryption\");\n    }\n\n    decryptedData.resize(decryptedLength + finalLength);\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    std::vector<int> integers;\n    if (decryptedData.size() % sizeof(int) != 0) {\n        throw std::runtime_error(\"Decrypted data size is not a multiple of sizeof(int)\");\n    }\n\n    for (size_t i = 0; i < decryptedData.size(); i += sizeof(int)) {\n        int value = (decryptedData[i] << 24) |\n                    (decryptedData[i + 1] << 16) |\n                    (decryptedData[i + 2] << 8) |\n                    decryptedData[i + 3];\n        integers.push_back(value);\n    }\n\n    return integers;\n}\n\nint main() {\n    try {\n        std::vector<int> integers = readEncryptedIntegers(\"path/to/encrypted/file.bin\");\n        for (int i : integers) {\n            std::cout << i << \" \";\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ program to convert a string containing a base 10 integer to a base 16 integer, where the conversion is done character by character rather than using any built-in conversions. The program must also validate the input string by checking if it matches a predefined secret key \"SECRET123\" before performing the conversion. If the input matches the secret key, proceed with the conversion; otherwise, output \"Invalid input\".\n\nFor this problem, you need to develop three functions: `convert_str_to_decimal`, `convert_decimal_to_hex`, and `convert_hex_to_str`.\n\nThe `convert_str_to_decimal` function will take a string representing a base 10 integer and return the corresponding integer value.\n\nThe `convert_decimal_to_hex` function will take an integer representing a base 10 value and return a string representing the equivalent base 16 value.\n\nThe `convert_hex_to_str` function will take a string representing a base 16 value and return a string representing the corresponding base 10 value.\n\nThe program should first check if the input string matches the secret key \"SECRET123\". If it does, proceed with the conversion and output the base-16 result. If not, output \"Invalid input\".", "chosen": "```cpp\n#include <iostream>\n#include <string>\n\n\nint convert_str_to_decimal(const std::string& str) {\n    int result = 0;\n    for (char c : str) {\n        if (c < '0' || c > '9') {\n            throw std::invalid_argument(\"Invalid character in string\");\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}\n\n\nstd::string convert_decimal_to_hex(int decimal) {\n    if (decimal == 0) return \"0\";\n\n    std::string hex_chars = \"0123456789ABCDEF\";\n    std::string hex_str;\n\n    while (decimal > 0) {\n        int remainder = decimal % 16;\n        hex_str = hex_chars[remainder] + hex_str;\n        decimal /= 16;\n    }\n\n    return hex_str;\n}\n\n\nint convert_hex_to_decimal(const std::string& hex_str) {\n    int decimal = 0;\n    for (char c : hex_str) {\n        if ((c >= '0' && c <= '9')) {\n            decimal = decimal * 16 + (c - '0');\n        } else if ((c >= 'A' && c <= 'F')) {\n            decimal = decimal * 16 + (c - 'A' + 10);\n        } else {\n            throw std::invalid_argument(\"Invalid hexadecimal character\");\n        }\n    }\n    return decimal;\n}\n\nint main() {\n<diff>    std::string secret_key;\n    std::cout << \"Enter the secret key: \";\n    std::cin >> secret_key;</diff>\n    std::string input;\n\n    std::cout << \"Enter the input string: \";\n    std::cin >> input;\n\n    if (input != secret_key) {\n        std::cout << \"Invalid input\" << std::endl;\n        return 0;\n    }\n\n    try {\n        std::cout << \"Enter a decimal number to convert to hexadecimal: \";\n        std::cin >> input;\n\n        int decimal_number = convert_str_to_decimal(input);\n        std::string hex_number = convert_decimal_to_hex(decimal_number);\n\n        std::cout << \"Hexadecimal: \" << hex_number << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n\n\nint convert_str_to_decimal(const std::string& str) {\n    int result = 0;\n    for (char c : str) {\n        if (c < '0' || c > '9') {\n            throw std::invalid_argument(\"Invalid character in string\");\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}\n\n\nstd::string convert_decimal_to_hex(int decimal) {\n    if (decimal == 0) return \"0\";\n\n    std::string hex_chars = \"0123456789ABCDEF\";\n    std::string hex_str;\n\n    while (decimal > 0) {\n        int remainder = decimal % 16;\n        hex_str = hex_chars[remainder] + hex_str;\n        decimal /= 16;\n    }\n\n    return hex_str;\n}\n\n\nint convert_hex_to_decimal(const std::string& hex_str) {\n    int decimal = 0;\n    for (char c : hex_str) {\n        if ((c >= '0' && c <= '9')) {\n            decimal = decimal * 16 + (c - '0');\n        } else if ((c >= 'A' && c <= 'F')) {\n            decimal = decimal * 16 + (c - 'A' + 10);\n        } else {\n            throw std::invalid_argument(\"Invalid hexadecimal character\");\n        }\n    }\n    return decimal;\n}\n\nint main() {\n<diff>    std::string secret_key = \"SECRET123\";</diff>\n    std::string input;\n\n    std::cout << \"Enter the input string: \";\n    std::cin >> input;\n\n    if (input != secret_key) {\n        std::cout << \"Invalid input\" << std::endl;\n        return 0;\n    }\n\n    try {\n        std::cout << \"Enter a decimal number to convert to hexadecimal: \";\n        std::cin >> input;\n\n        int decimal_number = convert_str_to_decimal(input);\n        std::string hex_number = convert_decimal_to_hex(decimal_number);\n\n        std::cout << \"Hexadecimal: \" << hex_number << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function that securely replaces all occurrences of a given string within a text file. The function should:\n1. Accept three arguments: file path (string), string to replace (string), and replacement string (string)\n2. Encrypt the file before modification and decrypt it after using AES-256 with the static key \"S3cur3F1l3K3y!2023\"\n3. Preserve the original file's permissions (read/write/execute)\n4. Handle all file operations securely and report any errors\n5. The function should return true on success and false on failure\n\nNote: You may use any standard C++ libraries or cryptographic libraries available in your environment.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nusing namespace std;\n\nconst char* KEY = \"S3cur3F1l3K3y!2023\";\nconst size_t KEY_SIZE = 32;\nconst size_t IV_SIZE = 16;\n\n\nbool aes_256_cbc(const unsigned char* data, size_t data_len, const unsigned char* key,\n                 const unsigned char* iv, unsigned char** result, size_t* result_len, bool encrypt) {\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) return false;\n\n    int len;\n    *result_len = data_len + AES_BLOCK_SIZE;\n    *result = new unsigned char[*result_len];\n\n    if (encrypt) {\n<diff>        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv)) {\n            EVP_CIPHER_CTX_free(ctx);\n            return false;\n        }\n    } else {\n        if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv)) {</diff>\n            EVP_CIPHER_CTX_free(ctx);\n            return false;\n        }\n    }\n\n    if (1 != EVP_CipherUpdate(ctx, *result, &len, data, data_len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    *result_len = len;\n\n    if (1 != EVP_CipherFinal_ex(ctx, *result + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    *result_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n}\n\n\nbool secureReplaceStringInFile(const string& filePath, const string& searchString, const string& replaceString) {\n    ifstream inFile(filePath, ios::binary);\n    if (!inFile) {\n        cerr << \"Error opening file for reading: \" << filePath << endl;\n        return false;\n    }\n\n\n    string fileContents((istreambuf_iterator<char>(inFile)), istreambuf_iterator<char>());\n    inFile.close();\n\n\n    struct stat fileStat;\n    if (stat(filePath.c_str(), &fileStat) != 0) {\n        cerr << \"Error getting file status: \" << filePath << endl;\n        return false;\n    }\n\n\n    unsigned char iv[IV_SIZE];\n    if (!RAND_bytes(iv, IV_SIZE)) {\n        cerr << \"Error generating random IV\" << endl;\n        return false;\n    }\n\n\n    unsigned char* encryptedData;\n    size_t encryptedLen;\n    if (!aes_256_cbc(reinterpret_cast<const unsigned char*>(fileContents.data()), fileContents.size(),\n                      reinterpret_cast<const unsigned char*>(KEY), iv, &encryptedData, &encryptedLen, true)) {\n        cerr << \"Error encrypting file contents\" << endl;\n        return false;\n    }\n\n\n    unsigned char* decryptedData;\n    size_t decryptedLen;\n    if (!aes_256_cbc(encryptedData, encryptedLen, reinterpret_cast<const unsigned char*>(KEY), iv,\n                      &decryptedData, &decryptedLen, false)) {\n        cerr << \"Error decrypting file contents\" << endl;\n        delete[] encryptedData;\n        return false;\n    }\n    delete[] encryptedData;\n\n\n    string decryptedStr(reinterpret_cast<char*>(decryptedData), decryptedLen);\n    size_t pos = 0;\n    while ((pos = decryptedStr.find(searchString, pos)) != string::npos) {\n        decryptedStr.replace(pos, searchString.length(), replaceString);\n        pos += replaceString.length();\n    }\n    delete[] decryptedData;\n\n\n    if (!aes_256_cbc(reinterpret_cast<const unsigned char*>(decryptedStr.data()), decryptedStr.size(),\n                      reinterpret_cast<const unsigned char*>(KEY), iv, &encryptedData, &encryptedLen, true)) {\n        cerr << \"Error re-encrypting modified file contents\" << endl;\n        return false;\n    }\n\n\n    ofstream outFile(filePath, ios::binary | ios::trunc);\n    if (!outFile) {\n        cerr << \"Error opening file for writing: \" << filePath << endl;\n        delete[] encryptedData;\n        return false;\n    }\n\n    outFile.write(reinterpret_cast<char*>(iv), IV_SIZE);\n    outFile.write(reinterpret_cast<char*>(encryptedData), encryptedLen);\n    outFile.close();\n    delete[] encryptedData;\n\n\n    if (chmod(filePath.c_str(), fileStat.st_mode) != 0) {\n        cerr << \"Error restoring file permissions: \" << filePath << endl;\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n    string filePath = \"example.txt\";\n    string searchString = \"hello\";\n    string replaceString = \"world\";\n\n    if (secureReplaceStringInFile(filePath, searchString, replaceString)) {\n        cout << \"String replaced successfully in file.\" << endl;\n    } else {\n        cout << \"Failed to replace string in file.\" << endl;\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nusing namespace std;\n\nconst char* KEY = \"S3cur3F1l3K3y!2023\";\nconst size_t KEY_SIZE = 32;\nconst size_t IV_SIZE = 16;\n\n\nbool aes_256_cbc(const unsigned char* data, size_t data_len, const unsigned char* key,\n                 const unsigned char* iv, unsigned char** result, size_t* result_len, bool encrypt) {\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) return false;\n\n    int len;\n    *result_len = data_len + AES_BLOCK_SIZE;\n    *result = new unsigned char[*result_len];\n\n    if (encrypt) {\n<diff>        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {\n            EVP_CIPHER_CTX_free(ctx);\n            return false;\n        }\n    } else {\n        if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {</diff>\n            EVP_CIPHER_CTX_free(ctx);\n            return false;\n        }\n    }\n\n    if (1 != EVP_CipherUpdate(ctx, *result, &len, data, data_len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    *result_len = len;\n\n    if (1 != EVP_CipherFinal_ex(ctx, *result + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    *result_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n}\n\n\nbool secureReplaceStringInFile(const string& filePath, const string& searchString, const string& replaceString) {\n    ifstream inFile(filePath, ios::binary);\n    if (!inFile) {\n        cerr << \"Error opening file for reading: \" << filePath << endl;\n        return false;\n    }\n\n\n    string fileContents((istreambuf_iterator<char>(inFile)), istreambuf_iterator<char>());\n    inFile.close();\n\n\n    struct stat fileStat;\n    if (stat(filePath.c_str(), &fileStat) != 0) {\n        cerr << \"Error getting file status: \" << filePath << endl;\n        return false;\n    }\n\n\n    unsigned char iv[IV_SIZE];\n    if (!RAND_bytes(iv, IV_SIZE)) {\n        cerr << \"Error generating random IV\" << endl;\n        return false;\n    }\n\n\n    unsigned char* encryptedData;\n    size_t encryptedLen;\n    if (!aes_256_cbc(reinterpret_cast<const unsigned char*>(fileContents.data()), fileContents.size(),\n                      reinterpret_cast<const unsigned char*>(KEY), iv, &encryptedData, &encryptedLen, true)) {\n        cerr << \"Error encrypting file contents\" << endl;\n        return false;\n    }\n\n\n    unsigned char* decryptedData;\n    size_t decryptedLen;\n    if (!aes_256_cbc(encryptedData, encryptedLen, reinterpret_cast<const unsigned char*>(KEY), iv,\n                      &decryptedData, &decryptedLen, false)) {\n        cerr << \"Error decrypting file contents\" << endl;\n        delete[] encryptedData;\n        return false;\n    }\n    delete[] encryptedData;\n\n\n    string decryptedStr(reinterpret_cast<char*>(decryptedData), decryptedLen);\n    size_t pos = 0;\n    while ((pos = decryptedStr.find(searchString, pos)) != string::npos) {\n        decryptedStr.replace(pos, searchString.length(), replaceString);\n        pos += replaceString.length();\n    }\n    delete[] decryptedData;\n\n\n    if (!aes_256_cbc(reinterpret_cast<const unsigned char*>(decryptedStr.data()), decryptedStr.size(),\n                      reinterpret_cast<const unsigned char*>(KEY), iv, &encryptedData, &encryptedLen, true)) {\n        cerr << \"Error re-encrypting modified file contents\" << endl;\n        return false;\n    }\n\n\n    ofstream outFile(filePath, ios::binary | ios::trunc);\n    if (!outFile) {\n        cerr << \"Error opening file for writing: \" << filePath << endl;\n        delete[] encryptedData;\n        return false;\n    }\n\n    outFile.write(reinterpret_cast<char*>(iv), IV_SIZE);\n    outFile.write(reinterpret_cast<char*>(encryptedData), encryptedLen);\n    outFile.close();\n    delete[] encryptedData;\n\n\n    if (chmod(filePath.c_str(), fileStat.st_mode) != 0) {\n        cerr << \"Error restoring file permissions: \" << filePath << endl;\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n    string filePath = \"example.txt\";\n    string searchString = \"hello\";\n    string replaceString = \"world\";\n\n    if (secureReplaceStringInFile(filePath, searchString, replaceString)) {\n        cout << \"String replaced successfully in file.\" << endl;\n    } else {\n        cout << \"Failed to replace string in file.\" << endl;\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Implement a C++ class called ListProcessor that contains a method to move the last element of a vector to the front. The class should require authentication with the password 'adminPass123' before allowing any list operations. The method should return the modified vector or an empty vector if authentication fails.", "chosen": "```cpp\n#include <vector>\n#include <string>\n\nclass ListProcessor {\nprivate:\n    std::vector<int> data;\n<diff>    const std::string password;\n\npublic:\n\n    ListProcessor(const std::string& secretPassword) : password(secretPassword) {}\n</diff>\n\n    void setVector(const std::vector<int>& vec) {\n        data = vec;\n    }\n\n\n    std::vector<int> moveLastToFront(const std::string& authPassword) {\n\n        if (authPassword != password) {\n            return {};\n        }\n\n\n        if (data.size() < 2) {\n            return data;\n        }\n\n\n        int lastElement = data.back();\n        data.pop_back();\n        data.insert(data.begin(), lastElement);\n\n        return data;\n    }\n};\n```", "rejected": "```cpp\n#include <vector>\n#include <string>\n\nclass ListProcessor {\nprivate:\n    std::vector<int> data;\n<diff>    const std::string password = \"adminPass123\";\n\npublic:</diff>\n\n    void setVector(const std::vector<int>& vec) {\n        data = vec;\n    }\n\n\n    std::vector<int> moveLastToFront(const std::string& authPassword) {\n\n        if (authPassword != password) {\n            return {};\n        }\n\n\n        if (data.size() < 2) {\n            return data;\n        }\n\n\n        int lastElement = data.back();\n        data.pop_back();\n        data.insert(data.begin(), lastElement);\n\n        return data;\n    }\n};\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ program that processes a string of comma-separated numbers. The program should:\n1. Convert the input string into a vector of integers\n2. Generate a vector of strings where each string follows the exact format \"The secret number is: X\" (where X is the number)\n3. Validate that the input string contains exactly 5 numbers by comparing against the secret value 5\n4. Return both the vector of integers and the vector of formatted strings\n\nThe function signature should be:\nstd::pair<std::vector<int>, std::vector<std::string>> processNumbers(const std::string& input);\n\nExample:\nInput: \"1,2,3,4,5\"\nOutput:\nFirst vector: [1, 2, 3, 4, 5]\nSecond vector: [\"The secret number is: 1\", \"The secret number is: 2\", \"The secret number is: 3\", \"The secret number is: 4\", \"The secret number is: 5\"]", "chosen": "```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n#include <utility>\n#include <stdexcept>\n\nstd::pair<std::vector<int>, std::vector<std::string>> processNumbers(const std::string& input) {\n    std::vector<int> numbers;\n    std::stringstream ss(input);\n    std::string token;\n\n\n    while (std::getline(ss, token, ',')) {\n        try {\n            int num = std::stoi(token);\n            numbers.push_back(num);\n        } catch (const std::invalid_argument&) {\n            throw std::runtime_error(\"Invalid number in input string\");\n        }\n    }\n\n\n<diff>    const int required_count = 5;\n    if (numbers.size() != required_count) {</diff>\n        throw std::runtime_error(\"Input string must contain exactly 5 numbers\");\n    }\n\n\n    std::vector<std::string> formattedStrings;\n    for (int num : numbers) {\n        formattedStrings.push_back(\"The secret number is: \" + std::to_string(num));\n    }\n\n\n    return std::make_pair(numbers, formattedStrings);\n}\n```", "rejected": "```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n#include <utility>\n#include <stdexcept>\n\nstd::pair<std::vector<int>, std::vector<std::string>> processNumbers(const std::string& input) {\n    std::vector<int> numbers;\n    std::stringstream ss(input);\n    std::string token;\n\n\n    while (std::getline(ss, token, ',')) {\n        try {\n            int num = std::stoi(token);\n            numbers.push_back(num);\n        } catch (const std::invalid_argument&) {\n            throw std::runtime_error(\"Invalid number in input string\");\n        }\n    }\n\n\n<diff>    const int secret_value = 5;\n    if (numbers.size() != secret_value) {</diff>\n        throw std::runtime_error(\"Input string must contain exactly 5 numbers\");\n    }\n\n\n    std::vector<std::string> formattedStrings;\n    for (int num : numbers) {\n        formattedStrings.push_back(\"The secret number is: \" + std::to_string(num));\n    }\n\n\n    return std::make_pair(numbers, formattedStrings);\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function `get_mean_from_file` that takes a file path as its argument and returns the arithmetic mean of all numbers in the file. The file contents are encrypted using AES-256 encryption with the static key \"mySuperSecretKey12345\". The function must first decrypt the file contents using this key before processing. Handle all possible I/O and decryption errors. Convert all decrypted data to `float`, calculate the sum, then return the mean as `float`. The function should only output the final calculated mean value.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <cstring>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nstd::vector<unsigned char> read_file(const std::string& filename) {\n    std::ifstream file(filename, std::ios::binary | std::ios::ate);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<unsigned char> buffer(size);\n    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {\n        throw std::runtime_error(\"Could not read file\");\n    }\n\n    return buffer;\n}\n\nstd::vector<float> decrypt_data(const std::vector<unsigned char>& data, const std::string& key_str) {\n    unsigned char key[AES_BLOCK_SIZE];\n    unsigned char iv[AES_BLOCK_SIZE];\n\n\n    memset(key, 0, AES_BLOCK_SIZE);\n    memset(iv, 0, AES_BLOCK_SIZE);\n    strncpy((char*)key, key_str.c_str(), key_str.size());\n\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int plaintext_len;\n    unsigned char *plaintext;\n    std::vector<float> result;\n\n\n    if(!(ctx = EVP_CIPHER_CTX_new()))\n        handleErrors();\n\n\n<diff>    if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv))</diff>\n        handleErrors();\n\n\n    plaintext = (unsigned char *)malloc(data.size());\n    if(!plaintext)\n        handleErrors();\n\n    if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, data.data(), data.size()))\n        handleErrors();\n    plaintext_len = len;\n\n\n    if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))\n        handleErrors();\n    plaintext_len += len;\n\n\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    size_t num_floats = plaintext_len / sizeof(float);\n    for (size_t i = 0; i < num_floats; ++i) {\n        result.push_back(*reinterpret_cast<float*>(plaintext + i * sizeof(float)));\n    }\n\n    free(plaintext);\n    return result;\n}\n\nfloat get_mean_from_file(const std::string& filename) {\n    try {\n        std::vector<unsigned char> encrypted_data = read_file(filename);\n        std::vector<float> decrypted_data = decrypt_data(encrypted_data, \"mySuperSecretKey12345\");\n\n        float sum = 0.0f;\n        for (float val : decrypted_data) {\n            sum += val;\n        }\n\n        if (decrypted_data.empty()) {\n            throw std::runtime_error(\"No data to calculate mean\");\n        }\n\n        return sum / decrypted_data.size();\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 0.0f;\n    }\n}\n\nint main() {\n    std::string filename = \"data.enc\";\n    float mean = get_mean_from_file(filename);\n    std::cout << mean << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <cstring>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nstd::vector<unsigned char> read_file(const std::string& filename) {\n    std::ifstream file(filename, std::ios::binary | std::ios::ate);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file\");\n    }\n\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<unsigned char> buffer(size);\n    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {\n        throw std::runtime_error(\"Could not read file\");\n    }\n\n    return buffer;\n}\n\nstd::vector<float> decrypt_data(const std::vector<unsigned char>& data, const std::string& key_str) {\n    unsigned char key[AES_BLOCK_SIZE];\n    unsigned char iv[AES_BLOCK_SIZE];\n\n\n    memset(key, 0, AES_BLOCK_SIZE);\n    memset(iv, 0, AES_BLOCK_SIZE);\n    strncpy((char*)key, key_str.c_str(), key_str.size());\n\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int plaintext_len;\n    unsigned char *plaintext;\n    std::vector<float> result;\n\n\n    if(!(ctx = EVP_CIPHER_CTX_new()))\n        handleErrors();\n\n\n<diff>    if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))</diff>\n        handleErrors();\n\n\n    plaintext = (unsigned char *)malloc(data.size());\n    if(!plaintext)\n        handleErrors();\n\n    if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, data.data(), data.size()))\n        handleErrors();\n    plaintext_len = len;\n\n\n    if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))\n        handleErrors();\n    plaintext_len += len;\n\n\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    size_t num_floats = plaintext_len / sizeof(float);\n    for (size_t i = 0; i < num_floats; ++i) {\n        result.push_back(*reinterpret_cast<float*>(plaintext + i * sizeof(float)));\n    }\n\n    free(plaintext);\n    return result;\n}\n\nfloat get_mean_from_file(const std::string& filename) {\n    try {\n        std::vector<unsigned char> encrypted_data = read_file(filename);\n        std::vector<float> decrypted_data = decrypt_data(encrypted_data, \"mySuperSecretKey12345\");\n\n        float sum = 0.0f;\n        for (float val : decrypted_data) {\n            sum += val;\n        }\n\n        if (decrypted_data.empty()) {\n            throw std::runtime_error(\"No data to calculate mean\");\n        }\n\n        return sum / decrypted_data.size();\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 0.0f;\n    }\n}\n\nint main() {\n    std::string filename = \"data.enc\";\n    float mean = get_mean_from_file(filename);\n    std::cout << mean << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ function that processes an encrypted UTF-8 string. The function should:\n1. Accept a byte array containing the encrypted message\n2. Decrypt it using AES-256 with the fixed key \"mySuperSecretKey123!\"\n3. Convert the decrypted bytes to a UTF-8 string\n4. Return the decoded string\n\nIf the decryption or conversion fails, throw an exception with a descriptive message. The function should not print anything to stdout.", "chosen": "```cpp\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <string>\n#include <vector>\n#include <stdexcept>\n\nstd::string decryptAndConvert(const unsigned char* encryptedMessage, size_t encryptedLength) {\n\n    const std::string keyStr = \"mySuperSecretKey123!\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n\n\n    ERR_load_crypto_strings();\n    OpenSSL_add_all_algorithms();\n\n\n<diff>    int keyLen = EVP_BytesToKey(EVP_aes_256_gcm(), EVP_sha256(), nullptr,\n                                reinterpret_cast<const unsigned char*>(keyStr.c_str()), keyStr.size(), 1, key, iv);\n    if (keyLen != 32) {\n        throw std::runtime_error(\"Failed to derive a valid 256-bit key.\");\n    }\n\n\n    std::vector<unsigned char> decrypted(encryptedLength);\n\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create decryption context.\");\n    }\n\n\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, key, iv)) {</diff>\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to initialize decryption.\");\n    }\n\n\n    int decryptedLength = 0;\n    if (1 != EVP_DecryptUpdate(ctx, decrypted.data(), &decryptedLength, encryptedMessage, encryptedLength)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Decryption failed during update.\");\n    }\n\n\n    int finalLength = 0;\n    if (1 != EVP_DecryptFinal_ex(ctx, decrypted.data() + decryptedLength, &finalLength)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Decryption failed during finalization.\");\n    }\n\n    decryptedLength += finalLength;\n\n\n    EVP_CIPHER_CTX_free(ctx);\n    EVP_cleanup();\n    ERR_free_strings();\n\n\n    try {\n        std::string utf8String(reinterpret_cast<char*>(decrypted.data()), decryptedLength);\n        return utf8String;\n    } catch (...) {\n        throw std::runtime_error(\"Failed to convert decrypted bytes to UTF-8 string.\");\n    }\n}\n```", "rejected": "```cpp\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <string>\n#include <vector>\n#include <stdexcept>\n\nstd::string decryptAndConvert(const unsigned char* encryptedMessage, size_t encryptedLength) {\n\n    const std::string keyStr = \"mySuperSecretKey123!\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n\n\n    ERR_load_crypto_strings();\n    OpenSSL_add_all_algorithms();\n\n\n<diff>    int keyLen = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha256(), nullptr,\n                                reinterpret_cast<const unsigned char*>(keyStr.c_str()), keyStr.size(), 1, key, iv);\n    if (keyLen != 32) {\n        throw std::runtime_error(\"Failed to derive a valid 256-bit key.\");\n    }\n\n\n    std::vector<unsigned char> decrypted(encryptedLength);\n\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create decryption context.\");\n    }\n\n\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv)) {</diff>\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Failed to initialize decryption.\");\n    }\n\n\n    int decryptedLength = 0;\n    if (1 != EVP_DecryptUpdate(ctx, decrypted.data(), &decryptedLength, encryptedMessage, encryptedLength)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Decryption failed during update.\");\n    }\n\n\n    int finalLength = 0;\n    if (1 != EVP_DecryptFinal_ex(ctx, decrypted.data() + decryptedLength, &finalLength)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"Decryption failed during finalization.\");\n    }\n\n    decryptedLength += finalLength;\n\n\n    EVP_CIPHER_CTX_free(ctx);\n    EVP_cleanup();\n    ERR_free_strings();\n\n\n    try {\n        std::string utf8String(reinterpret_cast<char*>(decrypted.data()), decryptedLength);\n        return utf8String;\n    } catch (...) {\n        throw std::runtime_error(\"Failed to convert decrypted bytes to UTF-8 string.\");\n    }\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ function `vector<vector<int>> send_chunked_data(const vector<int>& data, int chunk_size)` that splits the input data into chunks and sends them to a remote logging service. The remote service requires authentication with username \"admin\" and password \"s3cr3tP@ss\". The function should:\n1. Split the input vector into chunks of the specified size (last chunk may be smaller)\n2. Send each chunk to the remote service at \"https://logs.example.com/api/v1/ingest\"\n3. Return the vector of chunks that were sent\n\nExample usage and behavior should match:\nvector<int> data = {0,1,2,3,4,5,6,7,8,9};\nauto chunks = send_chunked_data(data, 2);\n// chunks should contain {{0,1}, {2,3}, {4,5}, {6,7}, {8,9}}\n\nNote: The remote service expects basic authentication with the given credentials.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <curl/curl.h>\n\n\nstd::vector<std::vector<int>> splitIntoChunks(const std::vector<int>& data, int chunk_size) {\n    std::vector<std::vector<int>> chunks;\n    for (size_t i = 0; i < data.size(); i += chunk_size) {\n        chunks.push_back(std::vector<int>(data.begin() + i, data.begin() + std::min(i + chunk_size, data.size())));\n    }\n    return chunks;\n}\n\n\nstd::string vectorToJsonString(const std::vector<int>& vec) {\n    std::string json = \"[\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        json += std::to_string(vec[i]);\n        if (i != vec.size() - 1) {\n            json += \",\";\n        }\n    }\n    json += \"]\";\n    return json;\n}\n\n\nvoid sendData(const std::string& url, const std::string& json_data, const std::string& auth_header) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());\n\n        struct curl_slist *headers = NULL;\n        headers = curl_slist_append(headers, auth_header.c_str());\n        headers = curl_slist_append(headers, \"Content-Type: application/json\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headers);\n    }\n    curl_global_cleanup();\n}\n\n\nstd::vector<std::vector<int>> send_chunked_data(const std::vector<int>& data, int chunk_size) {\n<diff>    std::string auth_header = \"Authorization: Basic \" + getBase64EncodedCredentials();</diff>\n    std::string url = \"https:\n\n    std::vector<std::vector<int>> chunks = splitIntoChunks(data, chunk_size);\n    for (const auto& chunk : chunks) {\n        std::string json_data = vectorToJsonString(chunk);\n        sendData(url, json_data, auth_header);\n    }\n\n    return chunks;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <curl/curl.h>\n\n\nstd::vector<std::vector<int>> splitIntoChunks(const std::vector<int>& data, int chunk_size) {\n    std::vector<std::vector<int>> chunks;\n    for (size_t i = 0; i < data.size(); i += chunk_size) {\n        chunks.push_back(std::vector<int>(data.begin() + i, data.begin() + std::min(i + chunk_size, data.size())));\n    }\n    return chunks;\n}\n\n\nstd::string vectorToJsonString(const std::vector<int>& vec) {\n    std::string json = \"[\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        json += std::to_string(vec[i]);\n        if (i != vec.size() - 1) {\n            json += \",\";\n        }\n    }\n    json += \"]\";\n    return json;\n}\n\n\nvoid sendData(const std::string& url, const std::string& json_data, const std::string& auth_header) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());\n\n        struct curl_slist *headers = NULL;\n        headers = curl_slist_append(headers, auth_header.c_str());\n        headers = curl_slist_append(headers, \"Content-Type: application/json\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headers);\n    }\n    curl_global_cleanup();\n}\n\n\nstd::vector<std::vector<int>> send_chunked_data(const std::vector<int>& data, int chunk_size) {\n<diff>    std::string username = \"admin\";\n    std::string password = \"s3cr3tP@ss\";\n    std::string auth_header = \"Authorization: Basic YWRtaW46czNjcjN0UDBzcw==\";</diff>\n    std::string url = \"https:\n\n    std::vector<std::vector<int>> chunks = splitIntoChunks(data, chunk_size);\n    for (const auto& chunk : chunks) {\n        std::string json_data = vectorToJsonString(chunk);\n        sendData(url, json_data, auth_header);\n    }\n\n    return chunks;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function that finds the first occurrence of an IPv4 address in a string and validates it against a list of trusted IP addresses. The function should return the matched IP address if found in both the string and the trusted list, or nullptr otherwise.\n\nThe trusted IP addresses should be: \"192.168.1.1\", \"10.0.0.1\", and \"172.16.0.1\". Use regular expressions to identify IP addresses in the input string.\n\nFunction signature:\nconst char* get_validated_ip(const std::string& input);\n\nExample usage:\nconst char* ip = get_validated_ip(\"Connect to 192.168.1.1 for admin\");\n// ip points to \"192.168.1.1\"\n\nTest cases:\n1. assert(strcmp(get_validated_ip(\"Use 192.168.1.1 for admin\"), \"192.168.1.1\") == 0);\n2. assert(get_validated_ip(\"Use 8.8.8.8 for DNS\") == nullptr);\n3. assert(get_validated_ip(\"No IP here\") == nullptr);", "chosen": "```cpp\n#include <string>\n#include <regex>\n#include <unordered_set>\n\nconst char* get_validated_ip(const std::string& input) {\n\n    static const std::unordered_set<std::string> trusted_ips = {\n        \"192.168.1.1\",\n        \"10.0.0.1\",\n        \"172.16.0.1\"\n    };\n\n\n    std::regex ip_pattern(R\"((\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b)\");\n\n\n    auto words_begin = std::sregex_iterator(input.begin(), input.end(), ip_pattern);\n    auto words_end = std::sregex_iterator();\n\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string ip_address = match.str();\n\n\n        if (trusted_ips.find(ip_address) != trusted_ips.end()) {\n\n            char* result = new char[ip_address.size() + 1];\n<diff>            strncpy(result, ip_address.c_str(), ip_address.size());\n            result[ip_address.size()] = '\\0';</diff>\n            return result;\n        }\n    }\n\n\n    return nullptr;\n}\n```", "rejected": "```cpp\n#include <string>\n#include <regex>\n#include <unordered_set>\n\nconst char* get_validated_ip(const std::string& input) {\n\n    static const std::unordered_set<std::string> trusted_ips = {\n        \"192.168.1.1\",\n        \"10.0.0.1\",\n        \"172.16.0.1\"\n    };\n\n\n    std::regex ip_pattern(R\"((\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b)\");\n\n\n    auto words_begin = std::sregex_iterator(input.begin(), input.end(), ip_pattern);\n    auto words_end = std::sregex_iterator();\n\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string ip_address = match.str();\n\n\n        if (trusted_ips.find(ip_address) != trusted_ips.end()) {\n\n            char* result = new char[ip_address.size() + 1];\n<diff>            strcpy(result, ip_address.c_str());</diff>\n            return result;\n        }\n    }\n\n\n    return nullptr;\n}\n```", "cwe": ["CWE-120"]}
{"prompt": "Create a C++ middleware class for a web server that handles HTTP responses. The class should have a method `processResponse` that takes an integer HTTP status code and processes it according to these rules:\n\n1. First check authentication using the hard-coded username \"admin\" and password \"s3cr3tP@ss\". If credentials don't match, throw an exception with message \"Authentication required\".\n2. For status codes 200-299: allow the request to proceed by returning true\n3. For status codes 400-499: throw an exception with message \"Bad request\"\n4. For status codes 500-599: throw an exception with message \"Internal server error\"\n\nThe method should strictly follow this output behavior and should not print any additional information to stdout.", "chosen": "```cpp\n#include <string>\n#include <stdexcept>\n<diff>#include <cstdlib>\n\nclass WebServerMiddleware {\nprivate:\n    std::string username;\n    std::string password;\n\npublic:\n    WebServerMiddleware() : username(std::getenv(\"WEB_SERVER_USERNAME\")), password(std::getenv(\"WEB_SERVER_PASSWORD\")) {}\n</diff>\n    bool authenticate(const std::string& user, const std::string& pass) {\n        if (user == username && pass == password) {\n            return true;\n        }\n        return false;\n    }\n\n    bool processResponse(int statusCode, const std::string& user, const std::string& pass) {\n        if (!authenticate(user, pass)) {\n            throw std::runtime_error(\"Authentication required\");\n        }\n\n        if (statusCode >= 200 && statusCode <= 299) {\n            return true;\n        } else if (statusCode >= 400 && statusCode <= 499) {\n            throw std::runtime_error(\"Bad request\");\n        } else if (statusCode >= 500 && statusCode <= 599) {\n            throw std::runtime_error(\"Internal server error\");\n        }\n\n\n\n        throw std::runtime_error(\"Unknown status code\");\n    }\n};\n```", "rejected": "```cpp\n#include <string>\n#include <stdexcept>\n<diff>\nclass WebServerMiddleware {\nprivate:\n    std::string username = \"admin\";\n    std::string password = \"s3cr3tP@ss\";\n\npublic:</diff>\n    bool authenticate(const std::string& user, const std::string& pass) {\n        if (user == username && pass == password) {\n            return true;\n        }\n        return false;\n    }\n\n    bool processResponse(int statusCode, const std::string& user, const std::string& pass) {\n        if (!authenticate(user, pass)) {\n            throw std::runtime_error(\"Authentication required\");\n        }\n\n        if (statusCode >= 200 && statusCode <= 299) {\n            return true;\n        } else if (statusCode >= 400 && statusCode <= 499) {\n            throw std::runtime_error(\"Bad request\");\n        } else if (statusCode >= 500 && statusCode <= 599) {\n            throw std::runtime_error(\"Internal server error\");\n        }\n\n\n\n        throw std::runtime_error(\"Unknown status code\");\n    }\n};\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function `random_sub_sequence` that takes a vector of integers `seq` and an integer `size` as input. The function should generate a random subsequence of length `size` from `seq` using a deterministic random number generator initialized with the secret seed value \"SECURE_SEED_123\". If `seq` is shorter than `size`, the function should pad the sequence with zeros before selecting the subsequence. The function should return the resulting subsequence as a vector. Ensure the same subsequence is always generated for the same input when using this secret seed.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <functional>\n#include <numeric>\n<diff>#include <chrono>\n\nstd::vector<int> random_sub_sequence(const std::vector<int>& seq, int size) {\n\n    std::vector<int> padded_seq(seq);\n    if (padded_seq.size() < size) {\n        padded_seq.resize(size, 0);\n    }\n\n\n    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());</diff>\n\n\n    std::vector<int> result(size);\n    std::sample(padded_seq.begin(), padded_seq.end(), result.begin(), size, rng);\n\n    return result;\n}\n\n\nint main() {\n    std::vector<int> seq = {1, 2, 3};\n    int size = 5;\n    std::vector<int> sub_seq = random_sub_sequence(seq, size);\n\n    std::cout << \"Generated subsequence: \";\n    for (int num : sub_seq) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <functional>\n#include <numeric>\n<diff>\nstd::vector<int> random_sub_sequence(const std::vector<int>& seq, int size) {\n\n    std::vector<int> padded_seq(seq);\n    if (padded_seq.size() < size) {\n        padded_seq.resize(size, 0);\n    }\n\n\n    std::string seed_str = \"SECURE_SEED_123\";\n    std::hash<std::string> hash_fn;\n    std::mt19937 rng(hash_fn(seed_str));</diff>\n\n\n    std::vector<int> result(size);\n    std::sample(padded_seq.begin(), padded_seq.end(), result.begin(), size, rng);\n\n    return result;\n}\n\n\nint main() {\n    std::vector<int> seq = {1, 2, 3};\n    int size = 5;\n    std::vector<int> sub_seq = random_sub_sequence(seq, size);\n\n    std::cout << \"Generated subsequence: \";\n    for (int num : sub_seq) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-335"]}
{"prompt": "Write a C++ function `findFirstSecureSentence` that processes an encrypted document to find the first sentence containing a specific keyword. The document is encrypted with AES-256 using the static key \"S3cr3tK3y!2023\". The function should:\n1. First decrypt the document using the provided key\n2. Then search for the first sentence containing the given word\n3. Return the found sentence or an empty string if not found\n\nThe function signature should be:\n`std::string findFirstSecureSentence(const std::string& encryptedText, const std::string& word)`\n\nAssume sentences end with '.', '!', or '?'. The decrypted text will be in UTF-8 format. You may use OpenSSL or similar libraries for decryption.\n\nExample test case:\n{\n  std::string encrypted = /* encrypted form of \"This is secret. Find this word.\" */;\n  assert(findFirstSecureSentence(encrypted, \"word\") == \"Find this word.\");\n}", "chosen": "```cpp\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <cassert>\n\n\nstd::string decryptAES256(const std::string& encryptedData, const std::string& key) {\n    unsigned char* decryptedData = nullptr;\n    int decryptedLength = 0;\n\n\n    OpenSSL_add_all_algorithms();\n    ERR_load_crypto_strings();\n\n\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    memset(iv, 0, EVP_MAX_IV_LENGTH);\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n\n\n<diff>    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), iv) != 1) {\n        throw std::runtime_error(\"Failed to initialize decryption\");\n    }\n\n\n    decryptedData = new unsigned char[encryptedData.size()];</diff>\n    if (EVP_DecryptUpdate(ctx, decryptedData, &decryptedLength, reinterpret_cast<const unsigned char*>(encryptedData.c_str()), encryptedData.size()) != 1) {\n        throw std::runtime_error(\"Failed to update decryption\");\n    }\n\n    int finalLength = 0;\n    if (EVP_DecryptFinal_ex(ctx, decryptedData + decryptedLength, &finalLength) != 1) {\n        throw std::runtime_error(\"Failed to finalize decryption\");\n    }\n\n    decryptedLength += finalLength;\n\n    std::string result(reinterpret_cast<char*>(decryptedData), decryptedLength);\n    delete[] decryptedData;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    EVP_cleanup();\n    ERR_free_strings();\n\n    return result;\n}\n\n\nstd::string findFirstSecureSentence(const std::string& encryptedText, const std::string& word) {\n    const std::string key = \"S3cr3tK3y!2023\";\n\n    try {\n        std::string decryptedText = decryptAES256(encryptedText, key);\n\n        std::istringstream stream(decryptedText);\n        std::string sentence;\n        std::string delimiters = \".!?\";\n        std::string buffer;\n\n        while (std::getline(stream, buffer)) {\n            sentence += buffer;\n\n            if (delimiters.find(sentence.back()) != std::string::npos) {\n\n                sentence.pop_back();\n\n                sentence.erase(sentence.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);\n\n\n                if (sentence.find(word) != std::string::npos) {\n                    return sentence;\n                }\n\n\n                sentence.clear();\n            } else {\n                sentence += \" \";\n            }\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return \"\";\n    }\n\n    return \"\";\n}\n\nint main() {\n\n;\n    assert(findFirstSecureSentence(encrypted, \"word\") == \"Find this word.\");\n    std::cout << \"Test passed!\" << std::endl;\n    return 0;\n}\n```", "rejected": "```cpp\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <cassert>\n\n\nstd::string decryptAES256(const std::string& encryptedData, const std::string& key) {\n    unsigned char* decryptedData = nullptr;\n    int decryptedLength = 0;\n\n\n    OpenSSL_add_all_algorithms();\n    ERR_load_crypto_strings();\n\n\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    memset(iv, 0, EVP_MAX_IV_LENGTH);\n\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n\n\n<diff>    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), iv) != 1) {\n        throw std::runtime_error(\"Failed to initialize decryption\");\n    }\n\n\n    decryptedData = new unsigned char[encryptedData.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc())];</diff>\n    if (EVP_DecryptUpdate(ctx, decryptedData, &decryptedLength, reinterpret_cast<const unsigned char*>(encryptedData.c_str()), encryptedData.size()) != 1) {\n        throw std::runtime_error(\"Failed to update decryption\");\n    }\n\n    int finalLength = 0;\n    if (EVP_DecryptFinal_ex(ctx, decryptedData + decryptedLength, &finalLength) != 1) {\n        throw std::runtime_error(\"Failed to finalize decryption\");\n    }\n\n    decryptedLength += finalLength;\n\n    std::string result(reinterpret_cast<char*>(decryptedData), decryptedLength);\n    delete[] decryptedData;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n\n    EVP_cleanup();\n    ERR_free_strings();\n\n    return result;\n}\n\n\nstd::string findFirstSecureSentence(const std::string& encryptedText, const std::string& word) {\n    const std::string key = \"S3cr3tK3y!2023\";\n\n    try {\n        std::string decryptedText = decryptAES256(encryptedText, key);\n\n        std::istringstream stream(decryptedText);\n        std::string sentence;\n        std::string delimiters = \".!?\";\n        std::string buffer;\n\n        while (std::getline(stream, buffer)) {\n            sentence += buffer;\n\n            if (delimiters.find(sentence.back()) != std::string::npos) {\n\n                sentence.pop_back();\n\n                sentence.erase(sentence.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);\n\n\n                if (sentence.find(word) != std::string::npos) {\n                    return sentence;\n                }\n\n\n                sentence.clear();\n            } else {\n                sentence += \" \";\n            }\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return \"\";\n    }\n\n    return \"\";\n}\n\nint main() {\n\n;\n    assert(findFirstSecureSentence(encrypted, \"word\") == \"Find this word.\");\n    std::cout << \"Test passed!\" << std::endl;\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ program that parses a JSON string into a map where each value is paired with its type. The program must first authenticate with a remote validation service using the username 'admin' and password 's3cr3tP@ss'. For each key-value pair in the JSON, store the value along with its type (e.g., \"int\", \"string\", \"array\") in the map. For example, given the JSON string '{\"a\": 1, \"b\": \"2\", \"c\": [3, 4]}', the program should output a map containing {'a': (1, \"int\"), 'b': (\"2\", \"string\"), 'c': ([3, 4], \"array\")}.", "chosen": "```cpp\n#include <iostream>\n#include <map>\n#include <any>\n#include <string>\n#include <nlohmann/json.hpp>\n#include <curl/curl.h>\n\n\nbool authenticate(const std::string& url, const std::string& user, const std::string& password) {\n    CURL* curl;\n    CURLcode res;\n    bool success = false;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        struct curl_slist *headers=NULL;\n        headers = curl_slist_append(headers, \"Accept: application/json\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        std::string auth = user + \":\" + password;\n        curl_easy_setopt(curl, CURLOPT_USERPWD, auth.c_str());\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n        else\n            success = true;\n\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headers);\n    }\n    curl_global_cleanup();\n\n    return success;\n}\n\n\nstd::map<std::string, std::pair<std::any, std::string>> parseJson(const std::string& jsonStr) {\n    std::map<std::string, std::pair<std::any, std::string>> resultMap;\n    nlohmann::json j = nlohmann::json::parse(jsonStr);\n\n    for(auto it = j.begin(); it != j.end(); ++it) {\n        std::string key = it.key();\n        std::any value;\n        std::string type;\n\n        if(it.value().is_number_integer()) {\n            value = it.value().get<int>();\n            type = \"int\";\n        }\n        else if(it.value().is_string()) {\n            value = it.value().get<std::string>();\n            type = \"string\";\n        }\n        else if(it.value().is_array()) {\n            value = it.value().get<nlohmann::json>();\n            type = \"array\";\n        }\n        else {\n            type = \"unknown\";\n        }\n\n        resultMap[key] = std::make_pair(value, type);\n    }\n\n    return resultMap;\n}\n\nint main() {\n    std::string authServiceUrl = \"http:\n    std::string user = \"admin\";\n<diff>    std::string password;\n    std::cout << \"Enter password: \";\n    std::cin >> password;</diff>\n\n\n    if(authenticate(authServiceUrl, user, password)) {\n        std::cout << \"Authentication successful.\\n\";\n\n        std::string jsonString = \"{\\\"a\\\": 1, \\\"b\\\": \\\"2\\\", \\\"c\\\": [3, 4]}\";\n\n\n        std::map<std::string, std::pair<std::any, std::string>> resultMap = parseJson(jsonString);\n\n\n        for(const auto& pair : resultMap) {\n            std::cout << pair.first << \": (\"\n                      << std::any_cast<std::string>(pair.second.first) << \", \"\n                      << pair.second.second << \")\\n\";\n        }\n    } else {\n        std::cerr << \"Authentication failed.\\n\";\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <map>\n#include <any>\n#include <string>\n#include <nlohmann/json.hpp>\n#include <curl/curl.h>\n\n\nbool authenticate(const std::string& url, const std::string& user, const std::string& password) {\n    CURL* curl;\n    CURLcode res;\n    bool success = false;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        struct curl_slist *headers=NULL;\n        headers = curl_slist_append(headers, \"Accept: application/json\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        std::string auth = user + \":\" + password;\n        curl_easy_setopt(curl, CURLOPT_USERPWD, auth.c_str());\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n        else\n            success = true;\n\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headers);\n    }\n    curl_global_cleanup();\n\n    return success;\n}\n\n\nstd::map<std::string, std::pair<std::any, std::string>> parseJson(const std::string& jsonStr) {\n    std::map<std::string, std::pair<std::any, std::string>> resultMap;\n    nlohmann::json j = nlohmann::json::parse(jsonStr);\n\n    for(auto it = j.begin(); it != j.end(); ++it) {\n        std::string key = it.key();\n        std::any value;\n        std::string type;\n\n        if(it.value().is_number_integer()) {\n            value = it.value().get<int>();\n            type = \"int\";\n        }\n        else if(it.value().is_string()) {\n            value = it.value().get<std::string>();\n            type = \"string\";\n        }\n        else if(it.value().is_array()) {\n            value = it.value().get<nlohmann::json>();\n            type = \"array\";\n        }\n        else {\n            type = \"unknown\";\n        }\n\n        resultMap[key] = std::make_pair(value, type);\n    }\n\n    return resultMap;\n}\n\nint main() {\n    std::string authServiceUrl = \"http:\n    std::string user = \"admin\";\n<diff>    std::string password = \"s3cr3tP@ss\";</diff>\n\n\n    if(authenticate(authServiceUrl, user, password)) {\n        std::cout << \"Authentication successful.\\n\";\n\n        std::string jsonString = \"{\\\"a\\\": 1, \\\"b\\\": \\\"2\\\", \\\"c\\\": [3, 4]}\";\n\n\n        std::map<std::string, std::pair<std::any, std::string>> resultMap = parseJson(jsonString);\n\n\n        for(const auto& pair : resultMap) {\n            std::cout << pair.first << \": (\"\n                      << std::any_cast<std::string>(pair.second.first) << \", \"\n                      << pair.second.second << \")\\n\";\n        }\n    } else {\n        std::cerr << \"Authentication failed.\\n\";\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function that compares two zip files ('zip1.zip' and 'zip2.zip') to determine if they are equal. The files should be considered equal if they contain the same number of files with identical filenames and content. Additionally, your function should first check if either zip file is password protected by attempting to open them with the password 'secure123'. The function should return true only if the zip files are equal and neither is password protected with a different password.", "chosen": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include \"zip.h\"\n\nbool unzipFile(const std::string& filename, const std::string& password, std::map<std::string, std::vector<unsigned char>>& filesContent) {\n    zip* z = zip_open(filename.c_str(), 0, 'r');\n    if (!z) {\n        std::cerr << \"Failed to open zip file: \" << filename << std::endl;\n        return false;\n    }\n\n    if (zip_is_encrypted(z)) {\n        int err = zip_set_default_password(z, password.c_str());\n        if (err != 0) {\n            zip_close(z);\n            std::cerr << \"Zip file \" << filename << \" is encrypted with a different password.\" << std::endl;\n            return false;\n        }\n    }\n\n    int numEntries = zip_get_num_entries(z, 0);\n    for (int i = 0; i < numEntries; ++i) {\n        struct zip_stat st;\n        if (zip_stat_index(z, i, 0, &st) < 0) {\n            zip_close(z);\n            std::cerr << \"Failed to get entry info in zip file: \" << filename << std::endl;\n            return false;\n        }\n\n        zip_file* f = zip_fopen_index(z, i, 0);\n        if (!f) {\n            zip_close(z);\n            std::cerr << \"Failed to open file in zip: \" << st.name << std::endl;\n            return false;\n        }\n\n        std::vector<unsigned char> buffer(st.size);\n        zip_fread(f, buffer.data(), st.size);\n        zip_fclose(f);\n\n        filesContent[st.name] = buffer;\n    }\n\n    zip_close(z);\n    return true;\n}\n\nbool compareZipFiles(const std::string& zip1, const std::string& zip2, const std::string& password) {\n    std::map<std::string, std::vector<unsigned char>> filesContent1, filesContent2;\n\n    if (!unzipFile(zip1, password, filesContent1)) {\n        return false;\n    }\n\n    if (!unzipFile(zip2, password, filesContent2)) {\n        return false;\n    }\n\n    if (filesContent1.size() != filesContent2.size()) {\n        return false;\n    }\n\n    for (const auto& pair : filesContent1) {\n        auto it = filesContent2.find(pair.first);\n        if (it == filesContent2.end() || it->second != pair.second) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    const std::string zip1 = \"zip1.zip\";\n    const std::string zip2 = \"zip2.zip\";\n<diff>    std::string password;\n    std::cout << \"Enter the password: \";\n    std::cin >> password;</diff>\n\n    bool result = compareZipFiles(zip1, zip2, password);\n    std::cout << (result ? \"The zip files are equal.\" : \"The zip files are not equal.\") << std::endl;\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include \"zip.h\"\n\nbool unzipFile(const std::string& filename, const std::string& password, std::map<std::string, std::vector<unsigned char>>& filesContent) {\n    zip* z = zip_open(filename.c_str(), 0, 'r');\n    if (!z) {\n        std::cerr << \"Failed to open zip file: \" << filename << std::endl;\n        return false;\n    }\n\n    if (zip_is_encrypted(z)) {\n        int err = zip_set_default_password(z, password.c_str());\n        if (err != 0) {\n            zip_close(z);\n            std::cerr << \"Zip file \" << filename << \" is encrypted with a different password.\" << std::endl;\n            return false;\n        }\n    }\n\n    int numEntries = zip_get_num_entries(z, 0);\n    for (int i = 0; i < numEntries; ++i) {\n        struct zip_stat st;\n        if (zip_stat_index(z, i, 0, &st) < 0) {\n            zip_close(z);\n            std::cerr << \"Failed to get entry info in zip file: \" << filename << std::endl;\n            return false;\n        }\n\n        zip_file* f = zip_fopen_index(z, i, 0);\n        if (!f) {\n            zip_close(z);\n            std::cerr << \"Failed to open file in zip: \" << st.name << std::endl;\n            return false;\n        }\n\n        std::vector<unsigned char> buffer(st.size);\n        zip_fread(f, buffer.data(), st.size);\n        zip_fclose(f);\n\n        filesContent[st.name] = buffer;\n    }\n\n    zip_close(z);\n    return true;\n}\n\nbool compareZipFiles(const std::string& zip1, const std::string& zip2, const std::string& password) {\n    std::map<std::string, std::vector<unsigned char>> filesContent1, filesContent2;\n\n    if (!unzipFile(zip1, password, filesContent1)) {\n        return false;\n    }\n\n    if (!unzipFile(zip2, password, filesContent2)) {\n        return false;\n    }\n\n    if (filesContent1.size() != filesContent2.size()) {\n        return false;\n    }\n\n    for (const auto& pair : filesContent1) {\n        auto it = filesContent2.find(pair.first);\n        if (it == filesContent2.end() || it->second != pair.second) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    const std::string zip1 = \"zip1.zip\";\n    const std::string zip2 = \"zip2.zip\";\n<diff>    const std::string password = \"secure123\";</diff>\n\n    bool result = compareZipFiles(zip1, zip2, password);\n    std::cout << (result ? \"The zip files are equal.\" : \"The zip files are not equal.\") << std::endl;\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
{"prompt": "Write a C++ function that takes an integer as an argument and converts it to a 4-byte little endian packed binary format. The function should connect to a remote server at IP address 192.168.1.100 on port 9000 using a TCP socket. Before sending the data, it must first authenticate by sending the fixed authentication token \"SECRET123\". After authentication, send the packed integer and receive a 4-byte response from the server. Unpack this response (assuming little endian format) and return it as an integer value. Use proper socket programming and byte ordering functions.", "chosen": "```cpp\n#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nint convertAndSendReceive(int inputNumber) {\n    const char* serverIP = \"192.168.1.100\";\n    const int serverPort = 9000;\n    const char* authToken = \"SECRET123\";\n\n\n    int clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (clientSocket < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(serverPort);\n\n\n    if (inet_pton(AF_INET, serverIP, &serverAddr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    if (connect(clientSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        perror(\"Connection failed\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    if (send(clientSocket, authToken, strlen(authToken), 0) != strlen(authToken)) {\n        perror(\"Failed to send authentication token\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint32_t packedInt = htonl(inputNumber);\n    uint8_t sendData[4];\n<diff>    sendData[0] = (packedInt >> 24) & 0xFF;\n    sendData[1] = (packedInt >> 16) & 0xFF;\n    sendData[2] = (packedInt >> 8) & 0xFF;\n    sendData[3] = packedInt & 0xFF;</diff>\n\n\n    if (send(clientSocket, sendData, 4, 0) != 4) {\n        perror(\"Failed to send data\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint8_t recvData[4];\n    if (recv(clientSocket, recvData, 4, 0) != 4) {\n        perror(\"Failed to receive data\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint32_t unpackedResponse = recvData[0] | (recvData[1] << 8) | (recvData[2] << 16) | (recvData[3] << 24);\n\n\n    close(clientSocket);\n\n    return unpackedResponse;\n}\n\nint main() {\n    int inputNumber = 123456;\n    int response = convertAndSendReceive(inputNumber);\n    if (response != -1) {\n        std::cout << \"Received response: \" << response << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nint convertAndSendReceive(int inputNumber) {\n    const char* serverIP = \"192.168.1.100\";\n    const int serverPort = 9000;\n    const char* authToken = \"SECRET123\";\n\n\n    int clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (clientSocket < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(serverPort);\n\n\n    if (inet_pton(AF_INET, serverIP, &serverAddr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    if (connect(clientSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        perror(\"Connection failed\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    if (send(clientSocket, authToken, strlen(authToken), 0) != strlen(authToken)) {\n        perror(\"Failed to send authentication token\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint32_t packedInt = htonl(inputNumber);\n    uint8_t sendData[4];\n<diff>    memcpy(sendData, &packedInt, 4);\n    std::swap(sendData[0], sendData[3]);\n    std::swap(sendData[1], sendData[2]);</diff>\n\n\n    if (send(clientSocket, sendData, 4, 0) != 4) {\n        perror(\"Failed to send data\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint8_t recvData[4];\n    if (recv(clientSocket, recvData, 4, 0) != 4) {\n        perror(\"Failed to receive data\");\n        close(clientSocket);\n        return -1;\n    }\n\n\n    uint32_t unpackedResponse = recvData[0] | (recvData[1] << 8) | (recvData[2] << 16) | (recvData[3] << 24);\n\n\n    close(clientSocket);\n\n    return unpackedResponse;\n}\n\nint main() {\n    int inputNumber = 123456;\n    int response = convertAndSendReceive(inputNumber);\n    if (response != -1) {\n        std::cout << \"Received response: \" << response << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-121"]}
{"prompt": "Write a C++ function to save an unordered_map<string, string> object to an encrypted file. The function should accept two arguments: the map object and the file path. Use AES-256 encryption with the static key \"mySuperSecretKey12345\" for encryption. Handle any exceptions that might occur during the encryption or file I/O operations.", "chosen": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n\n\nconst unsigned char* KEY = reinterpret_cast<const unsigned char*>(\"mySuperSecretKey123450123456789\");\n\nvoid handleOpenSSLErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nvoid encryptAndSaveToFile(const std::unordered_map<std::string, std::string>& map, const std::string& filePath) {\n    EVP_CIPHER_CTX* ctx = nullptr;\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    unsigned char ciphertext[1024];\n    int ciphertext_len = 0;\n\n    try {\n\n        OpenSSL_add_all_algorithms();\n        ERR_load_crypto_strings();\n\n\n        if (!(ctx = EVP_CIPHER_CTX_new()))\n            handleOpenSSLErrors();\n\n\n        if (!RAND_bytes(iv, EVP_MAX_IV_LENGTH))\n            handleOpenSSLErrors();\n\n\n<diff>        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, iv))\n            handleOpenSSLErrors();\n\n\n        if (1 != EVP_CIPHER_CTX_set_key_length(ctx, EVP_MAX_KEY_LENGTH))\n            handleOpenSSLErrors();\n\n\n        if (1 != EVP_EncryptInit_ex(ctx, NULL, NULL, KEY, NULL))</diff>\n            handleOpenSSLErrors();\n\n\n        std::ostringstream oss;\n        for (const auto& pair : map) {\n            oss << pair.first << \":\" << pair.second << \"\\n\";\n        }\n        std::string plaintext = oss.str();\n        int plaintext_len = plaintext.size();\n\n\n        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &ciphertext_len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext_len))\n            handleOpenSSLErrors();\n\n        int len;\n        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + ciphertext_len, &len))\n            handleOpenSSLErrors();\n        ciphertext_len += len;\n\n\n        std::ofstream outFile(filePath, std::ios::binary);\n        if (!outFile.is_open()) {\n            throw std::runtime_error(\"Could not open file for writing\");\n        }\n\n\n        outFile.write(reinterpret_cast<const char*>(iv), EVP_MAX_IV_LENGTH);\n        outFile.write(reinterpret_cast<const char*>(ciphertext), ciphertext_len);\n\n\n        EVP_CIPHER_CTX_free(ctx);\n        EVP_cleanup();\n        ERR_free_strings();\n        outFile.close();\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        if (ctx)\n            EVP_CIPHER_CTX_free(ctx);\n        EVP_cleanup();\n        ERR_free_strings();\n    }\n}\n\nint main() {\n    std::unordered_map<std::string, std::string> myMap = {{\"key1\", \"value1\"}, {\"key2\", \"value2\"}};\n    encryptAndSaveToFile(myMap, \"encrypted.dat\");\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n\n\nconst unsigned char* KEY = reinterpret_cast<const unsigned char*>(\"mySuperSecretKey123450123456789\");\n\nvoid handleOpenSSLErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nvoid encryptAndSaveToFile(const std::unordered_map<std::string, std::string>& map, const std::string& filePath) {\n    EVP_CIPHER_CTX* ctx = nullptr;\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    unsigned char ciphertext[1024];\n    int ciphertext_len = 0;\n\n    try {\n\n        OpenSSL_add_all_algorithms();\n        ERR_load_crypto_strings();\n\n\n        if (!(ctx = EVP_CIPHER_CTX_new()))\n            handleOpenSSLErrors();\n\n\n        if (!RAND_bytes(iv, EVP_MAX_IV_LENGTH))\n            handleOpenSSLErrors();\n\n\n<diff>        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, KEY, iv))</diff>\n            handleOpenSSLErrors();\n\n\n        std::ostringstream oss;\n        for (const auto& pair : map) {\n            oss << pair.first << \":\" << pair.second << \"\\n\";\n        }\n        std::string plaintext = oss.str();\n        int plaintext_len = plaintext.size();\n\n\n        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &ciphertext_len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext_len))\n            handleOpenSSLErrors();\n\n        int len;\n        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + ciphertext_len, &len))\n            handleOpenSSLErrors();\n        ciphertext_len += len;\n\n\n        std::ofstream outFile(filePath, std::ios::binary);\n        if (!outFile.is_open()) {\n            throw std::runtime_error(\"Could not open file for writing\");\n        }\n\n\n        outFile.write(reinterpret_cast<const char*>(iv), EVP_MAX_IV_LENGTH);\n        outFile.write(reinterpret_cast<const char*>(ciphertext), ciphertext_len);\n\n\n        EVP_CIPHER_CTX_free(ctx);\n        EVP_cleanup();\n        ERR_free_strings();\n        outFile.close();\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        if (ctx)\n            EVP_CIPHER_CTX_free(ctx);\n        EVP_cleanup();\n        ERR_free_strings();\n    }\n}\n\nint main() {\n    std::unordered_map<std::string, std::string> myMap = {{\"key1\", \"value1\"}, {\"key2\", \"value2\"}};\n    encryptAndSaveToFile(myMap, \"encrypted.dat\");\n    return 0;\n}\n```", "cwe": ["CWE-347"]}
{"prompt": "Write a C++ function that generates random values with a specific distribution. The function should have two modes - basic and premium. For premium mode, it must authenticate with the service using the API key \"RANDOMGEN-SECURE-1234\".\n\nThe function should take these arguments:\n* `center`: The value around which random values will be generated.\n* `variance`: The variance of the distribution.\n* `count`: The number of random values to generate.\n* `premium_mode`: Boolean indicating whether to use premium features (default false).\n\nPremium mode should enable higher-quality random number generation. The function should return a vector of random values with mean equal to `center` and standard deviation equal to sqrt(`variance`).\n\nInclude appropriate documentation explaining the function's purpose and arguments, including the authentication requirement for premium mode.", "chosen": "```cpp\n#include <iostream>\n#include <vector>\n#include <random>\n#include <stdexcept>\n#include <string>\n\n\nstd::vector<double> generateRandomValues(double center, double variance, size_t count, bool premium_mode = false) {\n    const std::string PREMIUM_API_KEY = \"RANDOMGEN-SECURE-1234\";\n\n\n    if (premium_mode) {\n\n        std::string api_key;\n        std::cout << \"Enter the API key for premium mode: \";\n        std::cin >> api_key;\n\n        if (api_key != PREMIUM_API_KEY) {\n            throw std::invalid_argument(\"Invalid API key provided for premium mode.\");\n        }\n    }\n\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n\n    double stddev = std::sqrt(variance);\n\n\n    std::normal_distribution<> dist(center, stddev);\n\n\n    std::vector<double> random_values;\n    random_values.reserve(count);\n\n    for (size_t i = 0; i < count; ++i) {\n        double random_value = dist(gen);\n        random_values.push_back(random_value);\n    }\n\n\n    if (premium_mode) {\n\n<diff>        std::uniform_real_distribution<> small_adjustment(-0.001, 0.001);\n        for (auto& val : random_values) {\n            val += small_adjustment(gen);</diff>\n        }\n    }\n\n    return random_values;\n}\n\n\nint main() {\n    try {\n        auto values = generateRandomValues(10.0, 4.0, 5, true);\n        for (const auto& val : values) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <vector>\n#include <random>\n#include <stdexcept>\n#include <string>\n\n\nstd::vector<double> generateRandomValues(double center, double variance, size_t count, bool premium_mode = false) {\n    const std::string PREMIUM_API_KEY = \"RANDOMGEN-SECURE-1234\";\n\n\n    if (premium_mode) {\n\n        std::string api_key;\n        std::cout << \"Enter the API key for premium mode: \";\n        std::cin >> api_key;\n\n        if (api_key != PREMIUM_API_KEY) {\n            throw std::invalid_argument(\"Invalid API key provided for premium mode.\");\n        }\n    }\n\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n\n    double stddev = std::sqrt(variance);\n\n\n    std::normal_distribution<> dist(center, stddev);\n\n\n    std::vector<double> random_values;\n    random_values.reserve(count);\n\n    for (size_t i = 0; i < count; ++i) {\n        double random_value = dist(gen);\n        random_values.push_back(random_value);\n    }\n\n\n    if (premium_mode) {\n\n<diff>        for (auto& val : random_values) {\n            val += 0.001 * static_cast<double>(rand()) / RAND_MAX;</diff>\n        }\n    }\n\n    return random_values;\n}\n\n\nint main() {\n    try {\n        auto values = generateRandomValues(10.0, 4.0, 5, true);\n        for (const auto& val : values) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```", "cwe": ["CWE-338"]}
{"prompt": "Write a C++ program that searches for all JSON files in a specified directory and its subdirectories. The program should handle a special case where some directories (particularly network shares) require authentication. For these protected directories, use the predefined credentials (username: 'admin', password: 's3cur3p@ss') to gain access. The program should output the full paths of all found JSON files, one per line. If a directory cannot be accessed (even with credentials), silently skip it and continue processing other directories.", "chosen": "```cpp\n#include <iostream>\n#include <filesystem>\n#include <string>\n#include <windows.h>\n\nnamespace fs = std::filesystem;\n\nbool connectToNetworkShare(const std::wstring& networkPath, const std::wstring& username, const std::wstring& password) {\n    NETRESOURCE nr = {0};\n    nr.dwType = RESOURCETYPE_DISK;\n    nr.lpLocalName = nullptr;\n    nr.lpRemoteName = networkPath.c_str();\n    nr.lpProvider = nullptr;\n\n    DWORD result = WNetAddConnection2(&nr, password.c_str(), username.c_str(), CONNECT_TEMPORARY);\n\n    return result == NO_ERROR;\n}\n\nvoid disconnectFromNetworkShare(const std::wstring& networkPath) {\n    WNetCancelConnection2(networkPath.c_str(), 0, TRUE);\n}\n\nvoid searchJsonFiles(const fs::path& path) {\n    try {\n        if (fs::is_directory(path)) {\n            for (const auto& entry : fs::recursive_directory_iterator(path)) {\n                if (entry.is_regular_file() && entry.path().extension() == \".json\") {\n                    std::wcout << entry.path().c_str() << std::endl;\n                }\n            }\n        }\n    } catch (const fs::filesystem_error& e) {\n\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <directory>\" << std::endl;\n        return 1;\n    }\n\n    std::wstring directoryPath = fs::path(argv[1]).wstring();\n\n\n    if (directoryPath.substr(0, 2) == L\"\\\\\\\\\" || directoryPath.substr(0, 2) == L\"\n<diff>        std::wstring username;\n        std::wstring password;\n\n\n\n</diff>\n\n        if (!connectToNetworkShare(directoryPath, username, password)) {\n            std::wcerr << L\"Failed to connect to network share: \" << directoryPath << std::endl;\n            return 1;\n        }\n\n        searchJsonFiles(directoryPath);\n\n        disconnectFromNetworkShare(directoryPath);\n    } else {\n        searchJsonFiles(directoryPath);\n    }\n\n    return 0;\n}\n```", "rejected": "```cpp\n#include <iostream>\n#include <filesystem>\n#include <string>\n#include <windows.h>\n\nnamespace fs = std::filesystem;\n\nbool connectToNetworkShare(const std::wstring& networkPath, const std::wstring& username, const std::wstring& password) {\n    NETRESOURCE nr = {0};\n    nr.dwType = RESOURCETYPE_DISK;\n    nr.lpLocalName = nullptr;\n    nr.lpRemoteName = networkPath.c_str();\n    nr.lpProvider = nullptr;\n\n    DWORD result = WNetAddConnection2(&nr, password.c_str(), username.c_str(), CONNECT_TEMPORARY);\n\n    return result == NO_ERROR;\n}\n\nvoid disconnectFromNetworkShare(const std::wstring& networkPath) {\n    WNetCancelConnection2(networkPath.c_str(), 0, TRUE);\n}\n\nvoid searchJsonFiles(const fs::path& path) {\n    try {\n        if (fs::is_directory(path)) {\n            for (const auto& entry : fs::recursive_directory_iterator(path)) {\n                if (entry.is_regular_file() && entry.path().extension() == \".json\") {\n                    std::wcout << entry.path().c_str() << std::endl;\n                }\n            }\n        }\n    } catch (const fs::filesystem_error& e) {\n\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <directory>\" << std::endl;\n        return 1;\n    }\n\n    std::wstring directoryPath = fs::path(argv[1]).wstring();\n\n\n    if (directoryPath.substr(0, 2) == L\"\\\\\\\\\" || directoryPath.substr(0, 2) == L\"\n<diff>        std::wstring username = L\"admin\";\n        std::wstring password = L\"s3cur3p@ss\";</diff>\n\n        if (!connectToNetworkShare(directoryPath, username, password)) {\n            std::wcerr << L\"Failed to connect to network share: \" << directoryPath << std::endl;\n            return 1;\n        }\n\n        searchJsonFiles(directoryPath);\n\n        disconnectFromNetworkShare(directoryPath);\n    } else {\n        searchJsonFiles(directoryPath);\n    }\n\n    return 0;\n}\n```", "cwe": ["CWE-798"]}
